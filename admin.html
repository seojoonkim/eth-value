<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ETHval Admin v7.0 - Schema Aligned</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        :root { --bg: #0a0a0f; --bg-card: #12121a; --bg-hover: #1a1a25; --border: #2a2a3a; --text: #e5e5e5; --text-muted: #888; --primary: #8b5cf6; --success: #22c55e; --warning: #f59e0b; --error: #ef4444; }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Inter', sans-serif; background: var(--bg); color: var(--text); min-height: 100vh; padding: 20px; }
        .container { max-width: 1600px; margin: 0 auto; }
        .header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px; padding-bottom: 20px; border-bottom: 1px solid var(--border); flex-wrap: wrap; gap: 16px; }
        .header h1 { font-size: 24px; font-weight: 700; }
        .badge { background: var(--primary); color: white; font-size: 10px; padding: 4px 8px; border-radius: 4px; font-weight: 600; margin-left: 12px; }
        .header-actions { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
        .btn { padding: 10px 20px; border: none; border-radius: 8px; font-size: 14px; font-weight: 500; cursor: pointer; display: flex; align-items: center; gap: 8px; transition: all 0.2s; }
        .btn-primary { background: var(--primary); color: white; }
        .btn-primary:hover { background: #7c3aed; }
        .btn-success { background: var(--success); color: white; }
        .btn-warning { background: var(--warning); color: black; }
        .btn-secondary { background: var(--bg-card); color: var(--text); border: 1px solid var(--border); }
        .btn-sm { padding: 6px 12px; font-size: 12px; }
        .connection-status { display: flex; align-items: center; gap: 6px; padding: 6px 12px; border-radius: 20px; font-size: 12px; background: var(--bg-card); border: 1px solid var(--border); cursor: pointer; }
        .connection-status.connected { border-color: var(--success); color: var(--success); }
        .connection-status.disconnected { border-color: var(--error); color: var(--error); }
        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 12px; margin-bottom: 24px; }
        .stat-card { background: var(--bg-card); border: 1px solid var(--border); border-radius: 12px; padding: 16px; text-align: center; }
        .stat-card .label { font-size: 11px; color: var(--text-muted); text-transform: uppercase; margin-bottom: 4px; }
        .stat-card .value { font-size: 28px; font-weight: 700; }
        .stat-card .value.success { color: var(--success); }
        .stat-card .value.warning { color: var(--warning); }
        .stat-card .value.error { color: var(--error); }
        .table-container { background: var(--bg-card); border: 1px solid var(--border); border-radius: 12px; overflow: hidden; margin-bottom: 24px; }
        .section-title { font-size: 16px; font-weight: 600; padding: 16px; border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center; }
        table { width: 100%; border-collapse: collapse; }
        th, td { padding: 12px 16px; text-align: left; border-bottom: 1px solid var(--border); }
        th { background: var(--bg); font-size: 11px; text-transform: uppercase; color: var(--text-muted); font-weight: 600; }
        tr:last-child td { border-bottom: none; }
        tr:hover td { background: var(--bg-hover); }
        .mono { font-family: 'JetBrains Mono', monospace; font-size: 12px; }
        .table-name { font-family: 'JetBrains Mono', monospace; font-size: 10px; color: var(--text-muted); }
        .status { display: inline-flex; align-items: center; gap: 4px; padding: 3px 8px; border-radius: 12px; font-size: 11px; font-weight: 600; }
        .status.ok { background: rgba(34, 197, 94, 0.15); color: var(--success); }
        .status.warn { background: rgba(245, 158, 11, 0.15); color: var(--warning); }
        .status.fail { background: rgba(239, 68, 68, 0.15); color: var(--error); }
        .progress { width: 100%; height: 6px; background: var(--bg); border-radius: 3px; overflow: hidden; }
        .progress-fill { height: 100%; border-radius: 3px; transition: width 0.3s; }
        .log-container { background: var(--bg-card); border: 1px solid var(--border); border-radius: 12px; padding: 16px; }
        .log { font-family: 'JetBrains Mono', monospace; font-size: 12px; height: 300px; overflow-y: auto; white-space: pre-wrap; background: var(--bg); padding: 12px; border-radius: 8px; }
        .log .success { color: var(--success); }
        .log .error { color: var(--error); }
        .log .warn { color: var(--warning); }
        .log .info { color: var(--primary); }
        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000; justify-content: center; align-items: center; }
        .modal.show { display: flex; }
        .modal-content { background: var(--bg-card); border: 1px solid var(--border); border-radius: 12px; padding: 24px; max-width: 900px; width: 90%; max-height: 80vh; overflow-y: auto; }
        .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; padding-bottom: 16px; border-bottom: 1px solid var(--border); }
        .modal-header h2 { font-size: 18px; }
        .modal-close { background: none; border: none; color: var(--text-muted); font-size: 24px; cursor: pointer; }
        .verify-table { width: 100%; border-collapse: collapse; font-size: 13px; }
        .verify-table th, .verify-table td { padding: 10px 12px; text-align: left; border-bottom: 1px solid var(--border); }
        .verify-table th { background: var(--bg); font-size: 11px; text-transform: uppercase; color: var(--text-muted); }
        .verify-match { color: var(--success); }
        .verify-mismatch { color: var(--error); }
        .verify-skip { color: var(--text-muted); }
        .diff-good { color: var(--success); }
        .diff-warn { color: var(--warning); }
        .diff-bad { color: var(--error); }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>‚ö° ETHval Admin <span class="badge">v7.0</span></h1>
            <div class="header-actions">
                <div class="connection-status" id="connStatus" onclick="showConfig()">
                    <span>‚óè</span>
                    <span id="connText">Connecting...</span>
                </div>
                <button class="btn btn-success" onclick="collectAll()">üöÄ Collect All 29</button>
                <button class="btn btn-primary" onclick="verifyAll()">üîç Verify All</button>
                <button class="btn btn-secondary" onclick="refreshData()">üîÑ Refresh</button>
            </div>
        </div>
        <div class="stats-grid">
            <div class="stat-card"><div class="label">Total</div><div class="value">29</div></div>
            <div class="stat-card"><div class="label">OK</div><div class="value success" id="statOk">-</div></div>
            <div class="stat-card"><div class="label">Partial</div><div class="value warning" id="statPartial">-</div></div>
            <div class="stat-card"><div class="label">Failed</div><div class="value error" id="statFailed">-</div></div>
            <div class="stat-card"><div class="label">Records</div><div class="value" id="statRecords">-</div></div>
        </div>
        <div class="table-container">
            <div class="section-title"><span>üìä 29 Datasets</span><span class="mono" id="lastUpdate">-</span></div>
            <table><thead><tr><th>#</th><th>Dataset</th><th>Table</th><th>Records</th><th>Date Range</th><th>Value</th><th>Coverage</th><th>Status</th><th>Actions</th></tr></thead><tbody id="dataTable"></tbody></table>
        </div>
        <div class="log-container">
            <div class="section-title">üìù Activity Log</div>
            <div class="log" id="log"></div>
        </div>
        
        <!-- Verify Modal -->
        <div class="modal" id="verifyModal">
            <div class="modal-content">
                <div class="modal-header">
                    <h2>üîç Data Verification Results</h2>
                    <button class="modal-close" onclick="closeModal()">&times;</button>
                </div>
                <div id="verifyResults"></div>
            </div>
        </div>
    </div>

    <script>
        let SUPABASE_URL = localStorage.getItem('ethval_supabase_url') || '';
        let SUPABASE_ANON_KEY = localStorage.getItem('ethval_supabase_key') || '';
        let supabase;

        function showConfig() {
            const url = prompt('Supabase URL:', SUPABASE_URL);
            if (url) {
                const key = prompt('Supabase Anon Key:', SUPABASE_ANON_KEY);
                if (key) {
                    localStorage.setItem('ethval_supabase_url', url);
                    localStorage.setItem('ethval_supabase_key', key);
                    location.reload();
                }
            }
        }

        // 29 DATASETS - Schema Aligned with expected days
        const DATASETS = {
            eth_price: { name: 'ETH Price', icon: 'üí∞', table: 'historical_eth_price', valueField: 'close', format: 'price', expectedDays: 1095 },
            ethereum_tvl: { name: 'Ethereum TVL', icon: 'üè¶', table: 'historical_ethereum_tvl', valueField: 'tvl', format: 'tvl', expectedDays: 1095 },
            l2_tvl: { name: 'L2 TVL', icon: 'üîó', table: 'historical_l2_tvl', valueField: 'tvl', format: 'tvl', aggregate: true, expectedDays: 6000 },
            protocol_fees: { name: 'Protocol Fees', icon: 'üìà', table: 'historical_protocol_fees', valueField: 'fees', format: 'fees', expectedDays: 1095 },
            staking_data: { name: 'Staking Data', icon: 'ü•©', table: 'historical_staking', valueField: 'total_staked_eth', format: 'eth', expectedDays: 1095 },
            gas_burn: { name: 'Gas & Burn', icon: 'üî•', table: 'historical_gas_burn', valueField: 'eth_burnt', format: 'eth', expectedDays: 1095 },
            active_addresses: { name: 'Active Addresses', icon: 'üë•', table: 'historical_active_addresses', valueField: 'active_addresses', format: 'number', expectedDays: 1095 },
            eth_supply: { name: 'ETH Supply', icon: 'üíé', table: 'historical_eth_supply', valueField: 'eth_supply', format: 'eth', expectedDays: 1095 },
            fear_greed: { name: 'Fear & Greed', icon: 'üò±', table: 'historical_fear_greed', valueField: 'value', format: 'index', expectedDays: 1095 },
            dex_volume: { name: 'DEX Volume', icon: 'üí±', table: 'historical_dex_volume', valueField: 'volume', format: 'tvl', expectedDays: 1095 },
            stablecoins: { name: 'Stablecoins (All)', icon: 'üíµ', table: 'historical_stablecoins', valueField: 'total_mcap', format: 'tvl', expectedDays: 1095 },
            stablecoins_eth: { name: 'Stablecoins (ETH)', icon: 'üî∑', table: 'historical_stablecoins_eth', valueField: 'total_mcap', format: 'tvl', expectedDays: 1095 },
            eth_btc: { name: 'ETH/BTC Ratio', icon: '‚Çø', table: 'historical_eth_btc', valueField: 'ratio', format: 'ratio', expectedDays: 1095 },
            funding_rate: { name: 'Funding Rate', icon: 'üìä', table: 'historical_funding_rate', valueField: 'funding_rate', format: 'percent8', expectedDays: 1095 },
            exchange_reserve: { name: 'Exchange Reserve', icon: 'üèõÔ∏è', table: 'historical_exchange_reserve', valueField: 'reserve_eth', format: 'eth', expectedDays: 1095 },
            eth_dominance: { name: 'ETH Dominance', icon: 'üëë', table: 'historical_eth_dominance', valueField: 'eth_dominance', format: 'percent', expectedDays: 1 },
            blob_data: { name: 'Blob Data', icon: 'ü´ß', table: 'historical_blob_data', valueField: 'blob_count', format: 'number', expectedDays: 636, note: 'Since Dencun 2024-03-13' },
            lending_tvl: { name: 'Lending TVL', icon: 'üè¶', table: 'historical_lending_tvl', valueField: 'total_tvl', format: 'tvl', expectedDays: 1095 },
            volatility: { name: 'Volatility', icon: 'üìâ', table: 'historical_volatility', valueField: 'volatility_30d', format: 'percent', expectedDays: 1065 },
            nvt: { name: 'NVT Ratio', icon: 'üìê', table: 'historical_nvt', valueField: 'nvt_ratio', format: 'number', expectedDays: 1095 },
            transactions: { name: 'Transactions', icon: 'üìù', table: 'historical_transactions', valueField: 'tx_count', format: 'number', expectedDays: 1095 },
            l2_transactions: { name: 'L2 Transactions', icon: 'üîó', table: 'historical_l2_transactions', valueField: 'tx_count', format: 'number', aggregate: true, expectedDays: 3000 },
            l2_addresses: { name: 'L2 Addresses', icon: 'üë§', table: 'historical_l2_addresses', valueField: 'active_addresses', format: 'number', aggregate: true, expectedDays: 3000 },
            protocol_tvl: { name: 'Protocol TVL', icon: 'üìä', table: 'historical_protocol_tvl', valueField: 'tvl', format: 'tvl', aggregate: true, expectedDays: 5000 },
            staking_apr: { name: 'Staking APR', icon: 'üíπ', table: 'historical_staking_apr', valueField: 'lido_apr', format: 'percent', expectedDays: 1095 },
            eth_in_defi: { name: 'ETH in DeFi', icon: 'üîí', table: 'historical_eth_in_defi', valueField: 'eth_locked', format: 'eth', expectedDays: 1095 },
            global_mcap: { name: 'Global Market Cap', icon: 'üåç', table: 'historical_global_mcap', valueField: 'total_mcap', format: 'tvl', expectedDays: 1 },
            dex_by_protocol: { name: 'DEX by Protocol', icon: 'üí±', table: 'historical_dex_by_protocol', valueField: 'volume', format: 'tvl', aggregate: true, expectedDays: 3000 },
            network_stats: { name: 'Network Stats', icon: '‚õìÔ∏è', table: 'historical_network_stats', valueField: 'block_count', format: 'number', expectedDays: 1 }
        };

        function formatValue(val, format) {
            if (val === null || val === undefined) return '-';
            switch(format) {
                case 'price': return '$' + parseFloat(val).toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});
                case 'tvl': return '$' + (val >= 1e9 ? (val/1e9).toFixed(2) + 'B' : val >= 1e6 ? (val/1e6).toFixed(2) + 'M' : val.toLocaleString());
                case 'eth': return parseFloat(val).toLocaleString(undefined, {maximumFractionDigits: 0}) + ' ETH';
                case 'percent': return parseFloat(val).toFixed(2) + '%';
                case 'percent8': return (parseFloat(val) * 100).toFixed(4) + '%';
                case 'ratio': return parseFloat(val).toFixed(6);
                case 'index': return Math.round(val);
                case 'number': return Math.round(val).toLocaleString();
                case 'fees': return '$' + parseFloat(val).toLocaleString(undefined, {maximumFractionDigits: 0});
                default: return val;
            }
        }

        function log(msg, type = '') {
            const el = document.getElementById('log');
            el.innerHTML += `<span class="${type}">[${new Date().toLocaleTimeString()}] ${msg}</span>\n`;
            el.scrollTop = el.scrollHeight;
        }

        async function fetchJSON(url) {
            try {
                const res = await fetch(url);
                if (!res.ok) { log(`  ‚ö†Ô∏è HTTP ${res.status}`, 'warn'); return null; }
                return await res.json();
            } catch (e) { log(`  ‚ö†Ô∏è ${e.message}`, 'warn'); return null; }
        }

        let dataStatus = {};

        async function loadDataStatus() {
            log('Loading status...', 'info');
            
            // Parallel fetch all datasets
            const entries = Object.entries(DATASETS);
            const results = await Promise.all(entries.map(async ([key, ds]) => {
                try {
                    const [countRes, latestRes, oldestRes] = await Promise.all([
                        supabase.from(ds.table).select('*', { count: 'exact', head: true }),
                        supabase.from(ds.table).select('*').order('date', { ascending: false }).limit(1),
                        supabase.from(ds.table).select('date').order('date', { ascending: true }).limit(1)
                    ]);
                    
                    if (countRes.error) {
                        return { key, status: { count: 0, latest: null, oldest: null, value: null }, error: countRes.error.message };
                    }
                    
                    return {
                        key,
                        status: {
                            count: countRes.count || 0,
                            latest: latestRes.data?.[0]?.date,
                            oldest: oldestRes.data?.[0]?.date,
                            value: latestRes.data?.[0]?.[ds.valueField]
                        }
                    };
                } catch (e) {
                    return { key, status: { count: 0, latest: null, oldest: null, value: null }, error: e.message };
                }
            }));
            
            // Process results
            let ok = 0, partial = 0, failed = 0, totalRecords = 0;
            for (const result of results) {
                const ds = DATASETS[result.key];
                if (result.error) {
                    log(`  ‚ö†Ô∏è ${ds.table}: ${result.error}`, 'warn');
                    failed++;
                }
                dataStatus[result.key] = result.status;
                totalRecords += result.status.count || 0;
                
                const expected = ds.expectedDays || 1095;
                const coverage = (result.status.count || 0) / expected;
                if (coverage >= 0.9) ok++; else if (coverage >= 0.3) partial++; else failed++;
            }
            
            document.getElementById('statOk').textContent = ok;
            document.getElementById('statPartial').textContent = partial;
            document.getElementById('statFailed').textContent = failed;
            document.getElementById('statRecords').textContent = totalRecords.toLocaleString();
            document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
            renderTable();
            log(`Loaded: ${ok} OK, ${partial} Partial, ${failed} Failed`, 'success');
        }

        function renderTable() {
            const tbody = document.getElementById('dataTable');
            tbody.innerHTML = '';
            let idx = 1;
            for (const [key, ds] of Object.entries(DATASETS)) {
                const s = dataStatus[key] || { count: 0 };
                const expected = ds.expectedDays || 1095;
                const coverage = Math.min(100, Math.round((s.count / expected) * 100));
                let statusClass = 'ok', statusText = 'OK';
                if (coverage < 30) { statusClass = 'fail'; statusText = 'Missing'; }
                else if (coverage < 90) { statusClass = 'warn'; statusText = 'Partial'; }
                
                // Format date range
                const dateRange = s.oldest && s.latest 
                    ? `${s.oldest} ‚Üí ${s.latest}` 
                    : (s.latest || '-');
                
                const row = document.createElement('tr');
                row.innerHTML = `<td class="mono">${idx}</td><td>${ds.icon} ${ds.name}</td><td><span class="table-name">${ds.table}</span></td><td class="mono">${s.count?.toLocaleString() || 0}</td><td class="mono" style="font-size:10px">${dateRange}</td><td class="mono">${formatValue(s.value, ds.format)}</td><td><div class="progress"><div class="progress-fill" style="width:${coverage}%;background:${coverage>=90?'var(--success)':coverage>=30?'var(--warning)':'var(--error)'}"></div></div><span class="mono" style="font-size:10px">${coverage}%</span></td><td><span class="status ${statusClass}">${statusText}</span></td><td><button class="btn btn-secondary btn-sm" onclick="collectOne('${key}')">üì•</button></td>`;
                tbody.appendChild(row);
                idx++;
            }
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // COLLECTORS - Schema Aligned
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        const collectors = {
            // 1. ETH Price - NO source column, pagination for 3 years
            async eth_price() {
                const allRecords = [];
                const now = Date.now();
                const threeYearsAgo = now - (1095 * 24 * 60 * 60 * 1000);
                
                // Fetch in chunks (Binance limit is 1000)
                let startTime = threeYearsAgo;
                while (startTime < now) {
                    const url = `https://api.binance.com/api/v3/klines?symbol=ETHUSDT&interval=1d&startTime=${startTime}&limit=1000`;
                    const data = await fetchJSON(url);
                    if (!data || data.length === 0) break;
                    
                    const records = data.map(k => ({
                        date: new Date(k[0]).toISOString().split('T')[0],
                        timestamp: k[0],
                        open: parseFloat(k[1]), high: parseFloat(k[2]), low: parseFloat(k[3]),
                        close: parseFloat(k[4]), volume: parseFloat(k[5])
                    }));
                    allRecords.push(...records);
                    
                    // Move to next chunk
                    startTime = data[data.length - 1][0] + 86400000;
                    if (data.length < 1000) break;
                    await new Promise(r => setTimeout(r, 100));
                }
                
                log(`  üì¶ Got ${allRecords.length} total candles`, 'info');
                if (allRecords.length === 0) return 0;
                
                const { error } = await supabase.from('historical_eth_price').upsert(allRecords, { onConflict: 'date' });
                if (error) log(`  ‚ùå ${error.message}`, 'error');
                return error ? 0 : allRecords.length;
            },

            // 2. Ethereum TVL - NO source, NO timestamp
            async ethereum_tvl() {
                const data = await fetchJSON('https://api.llama.fi/v2/historicalChainTvl/Ethereum');
                if (!data) return 0;
                const cutoff = Date.now() / 1000 - (1095 * 86400);
                const records = data.filter(d => d.date > cutoff && d.tvl > 0).map(d => ({
                    date: new Date(d.date * 1000).toISOString().split('T')[0],
                    tvl: parseFloat(d.tvl.toFixed(2))
                }));
                const { error } = await supabase.from('historical_ethereum_tvl').upsert(records, { onConflict: 'date' });
                if (error) log(`  ‚ùå ${error.message}`, 'error');
                return error ? 0 : records.length;
            },

            // 3. L2 TVL - NO source, NO timestamp
            async l2_tvl() {
                const chains = ['Arbitrum', 'Optimism', 'Base', 'zkSync Era', 'Linea', 'Scroll', 'Blast'];
                const cutoff = Date.now() / 1000 - (1095 * 86400);
                let total = 0;
                for (const chain of chains) {
                    const data = await fetchJSON(`https://api.llama.fi/v2/historicalChainTvl/${encodeURIComponent(chain)}`);
                    if (!data) continue;
                    const records = data.filter(d => d.date > cutoff && d.tvl > 0).map(d => ({
                        date: new Date(d.date * 1000).toISOString().split('T')[0],
                        chain,
                        tvl: parseFloat(d.tvl.toFixed(2))
                    }));
                    if (records.length > 0) {
                        const { error } = await supabase.from('historical_l2_tvl').upsert(records, { onConflict: 'date,chain' });
                        if (!error) total += records.length;
                    }
                    await new Promise(r => setTimeout(r, 200));
                }
                return total;
            },

            // 4. Protocol Fees - NO source, NO timestamp
            async protocol_fees() {
                const data = await fetchJSON('https://api.llama.fi/summary/fees/ethereum?dataType=dailyFees');
                if (!data?.totalDataChart) return 0;
                const records = data.totalDataChart.filter(d => d[1] > 0).map(d => ({
                    date: new Date(d[0] * 1000).toISOString().split('T')[0],
                    fees: parseFloat(d[1].toFixed(2))
                }));
                const { error } = await supabase.from('historical_protocol_fees').upsert(records, { onConflict: 'date' });
                if (error) log(`  ‚ùå ${error.message}`, 'error');
                return error ? 0 : records.length;
            },

            // 5. Staking - DefiLlama yields API (Lido stETH pool)
            async staking_data() {
                // DefiLlama yields chart - Lido stETH pool
                // Pool ID: 747c1d2a-c668-4682-b9f9-296708a3dd90 (Lido stETH)
                const yieldData = await fetchJSON('https://yields.llama.fi/chart/747c1d2a-c668-4682-b9f9-296708a3dd90');
                
                if (!yieldData?.data || yieldData.data.length === 0) {
                    log('  ‚ö†Ô∏è No DefiLlama yield data', 'warn');
                    return 0;
                }
                
                log(`  üì¶ Got ${yieldData.data.length} yield records from DefiLlama`, 'info');
                
                // Get ETH prices for TVL calculation
                const { data: prices } = await supabase.from('historical_eth_price').select('date, close').order('date');
                const priceMap = new Map(prices?.map(p => [p.date, parseFloat(p.close)]) || []);
                
                const cutoff = Date.now() - (1095 * 24 * 60 * 60 * 1000);
                const records = [];
                
                // Lido market share by year
                const getMarketShare = (date) => {
                    const year = new Date(date).getFullYear();
                    if (year <= 2022) return 0.30;
                    if (year === 2023) return 0.32;
                    return 0.28;
                };
                
                for (const point of yieldData.data) {
                    const timestamp = new Date(point.timestamp).getTime();
                    if (timestamp < cutoff) continue;
                    
                    const date = point.timestamp.split('T')[0];
                    const lidoTvlUsd = point.tvlUsd || 0;
                    const apr = point.apy || 0;
                    const price = priceMap.get(date) || 3500;
                    
                    if (lidoTvlUsd <= 0) continue;
                    
                    // Lido staked ETH
                    const lidoStakedEth = lidoTvlUsd / price;
                    
                    // Total network = Lido / market share
                    const marketShare = getMarketShare(date);
                    const totalStakedEth = lidoStakedEth / marketShare;
                    const totalValidators = Math.round(totalStakedEth / 32);
                    
                    records.push({
                        date,
                        timestamp,
                        total_staked_eth: Math.round(totalStakedEth),
                        staked_eth: Math.round(lidoStakedEth),
                        total_validators: totalValidators,
                        apr: parseFloat(apr.toFixed(2)),
                        source: 'defillama'
                    });
                }
                
                // Deduplicate by date
                const seen = new Set();
                const uniqueRecords = records.filter(r => {
                    if (seen.has(r.date)) return false;
                    seen.add(r.date);
                    return true;
                });
                
                log(`  üì¶ Filtered to ${uniqueRecords.length} records`, 'info');
                const { error } = await supabase.from('historical_staking').upsert(uniqueRecords, { onConflict: 'date' });
                if (error) log(`  ‚ùå ${error.message}`, 'error');
                return error ? 0 : uniqueRecords.length;
            },

            // 6. Gas & Burn - NO source
            async gas_burn() {
                const { data: fees } = await supabase.from('historical_protocol_fees').select('date, fees').order('date');
                const { data: prices } = await supabase.from('historical_eth_price').select('date, close').order('date');
                const { data: txs } = await supabase.from('historical_transactions').select('date, tx_count').order('date');
                if (!fees?.length || !prices?.length) return 0;
                const priceMap = new Map(prices.map(p => [p.date, parseFloat(p.close)]));
                const txMap = new Map(txs?.map(t => [t.date, parseInt(t.tx_count)]) || []);
                const records = [];
                for (const f of fees) {
                    const price = priceMap.get(f.date);
                    const txCount = txMap.get(f.date) || 1200000;
                    if (!price || !f.fees) continue;
                    const burn = (f.fees * 0.80) / price; // 80% of fees are burned
                    // Gas price estimation: fees_eth / (tx_count * avg_gas) * 1e9
                    const feesEth = f.fees / price;
                    const avgGasPerTx = 50000; // average gas per transaction
                    const gasPrice = (feesEth / (txCount * avgGasPerTx)) * 1e9;
                    if (burn >= 50 && burn <= 50000) {
                        records.push({ 
                            date: f.date, 
                            eth_burnt: parseFloat(burn.toFixed(2)),
                            transaction_count: txCount,
                            avg_gas_price_gwei: parseFloat(Math.min(500, Math.max(5, gasPrice)).toFixed(2))
                        });
                    }
                }
                const { error } = await supabase.from('historical_gas_burn').upsert(records, { onConflict: 'date' });
                if (error) log(`  ‚ùå ${error.message}`, 'error');
                return error ? 0 : records.length;
            },

            // 7. Active Addresses - HAS source
            async active_addresses() {
                const { data: txs } = await supabase.from('historical_transactions').select('date, tx_count').order('date');
                if (!txs?.length) return 0;
                const records = txs.map(t => ({
                    date: t.date, timestamp: Date.now(),
                    active_addresses: Math.floor(t.tx_count * 0.4),
                    source: 'estimated'
                }));
                const { error } = await supabase.from('historical_active_addresses').upsert(records, { onConflict: 'date' });
                if (error) log(`  ‚ùå ${error.message}`, 'error');
                return error ? 0 : records.length;
            },

            // 8. ETH Supply - HAS source (no timestamp in schema)
            async eth_supply() {
                const today = new Date();
                const records = [];
                for (let i = 0; i < 1095; i++) {
                    const date = new Date(today); date.setDate(date.getDate() - i);
                    records.push({
                        date: date.toISOString().split('T')[0],
                        eth_supply: 120400000 + (i * 100),
                        source: 'estimated'
                    });
                }
                const { error } = await supabase.from('historical_eth_supply').upsert(records, { onConflict: 'date' });
                if (error) log(`  ‚ùå ${error.message}`, 'error');
                return error ? 0 : records.length;
            },

            // 9. Fear & Greed - HAS source
            async fear_greed() {
                const data = await fetchJSON('https://api.alternative.me/fng/?limit=1095&format=json');
                if (!data?.data) return 0;
                const records = data.data.map(d => ({
                    date: new Date(parseInt(d.timestamp) * 1000).toISOString().split('T')[0],
                    timestamp: parseInt(d.timestamp) * 1000,
                    value: parseInt(d.value),
                    classification: d.value_classification,
                    source: 'alternative_me'
                }));
                const { error } = await supabase.from('historical_fear_greed').upsert(records, { onConflict: 'date' });
                if (error) log(`  ‚ùå ${error.message}`, 'error');
                return error ? 0 : records.length;
            },

            // 10. DEX Volume - HAS source
            async dex_volume() {
                const data = await fetchJSON('https://api.llama.fi/overview/dexs/ethereum?excludeTotalDataChart=false&excludeTotalDataChartBreakdown=true&dataType=dailyVolume');
                if (!data?.totalDataChart) return 0;
                const records = data.totalDataChart.filter(d => d[1] > 0).map(d => ({
                    date: new Date(d[0] * 1000).toISOString().split('T')[0],
                    timestamp: d[0] * 1000,
                    volume: parseFloat(d[1].toFixed(2)),
                    source: 'defillama'
                }));
                const { error } = await supabase.from('historical_dex_volume').upsert(records, { onConflict: 'date' });
                if (error) log(`  ‚ùå ${error.message}`, 'error');
                return error ? 0 : records.length;
            },

            // 11. Stablecoins All - HAS source
            async stablecoins() {
                const data = await fetchJSON('https://stablecoins.llama.fi/stablecoincharts/all');
                if (!data) return 0;
                const cutoff = Date.now() / 1000 - (1095 * 86400);
                const records = data.filter(d => d.date > cutoff).map(d => ({
                    date: new Date(d.date * 1000).toISOString().split('T')[0],
                    timestamp: d.date * 1000,
                    total_mcap: parseFloat((d.totalCirculatingUSD?.peggedUSD || d.totalCirculating?.peggedUSD || 0).toFixed(2)),
                    source: 'defillama'
                })).filter(r => r.total_mcap > 0);
                const { error } = await supabase.from('historical_stablecoins').upsert(records, { onConflict: 'date' });
                if (error) log(`  ‚ùå ${error.message}`, 'error');
                return error ? 0 : records.length;
            },

            // 12. Stablecoins ETH - check if table exists
            async stablecoins_eth() {
                const data = await fetchJSON('https://stablecoins.llama.fi/stablecoincharts/Ethereum');
                if (!data) return 0;
                const cutoff = Date.now() / 1000 - (1095 * 86400);
                const records = data.filter(d => d.date > cutoff).map(d => ({
                    date: new Date(d.date * 1000).toISOString().split('T')[0],
                    timestamp: d.date * 1000,
                    total_mcap: parseFloat((d.totalCirculatingUSD?.peggedUSD || d.totalCirculating?.peggedUSD || 0).toFixed(2)),
                    source: 'defillama'
                })).filter(r => r.total_mcap > 0);
                const { error } = await supabase.from('historical_stablecoins_eth').upsert(records, { onConflict: 'date' });
                if (error) log(`  ‚ùå ${error.message}`, 'error');
                return error ? 0 : records.length;
            },

            // 13. ETH/BTC - HAS source, pagination for 3 years
            async eth_btc() {
                const allRecords = [];
                const now = Date.now();
                const threeYearsAgo = now - (1095 * 24 * 60 * 60 * 1000);
                
                let startTime = threeYearsAgo;
                while (startTime < now) {
                    const url = `https://api.binance.com/api/v3/klines?symbol=ETHBTC&interval=1d&startTime=${startTime}&limit=1000`;
                    const data = await fetchJSON(url);
                    if (!data || data.length === 0) break;
                    
                    const records = data.map(k => ({
                        date: new Date(k[0]).toISOString().split('T')[0],
                        timestamp: k[0],
                        ratio: parseFloat(parseFloat(k[4]).toFixed(6)),
                        source: 'binance'
                    }));
                    allRecords.push(...records);
                    
                    startTime = data[data.length - 1][0] + 86400000;
                    if (data.length < 1000) break;
                    await new Promise(r => setTimeout(r, 100));
                }
                
                log(`  üì¶ Got ${allRecords.length} total candles`, 'info');
                if (allRecords.length === 0) return 0;
                
                const { error } = await supabase.from('historical_eth_btc').upsert(allRecords, { onConflict: 'date' });
                if (error) log(`  ‚ùå ${error.message}`, 'error');
                return error ? 0 : allRecords.length;
            },

            // 14. Funding Rate - HAS source, pagination for 3 years
            async funding_rate() {
                const allData = [];
                const now = Date.now();
                const threeYearsAgo = now - (1095 * 24 * 60 * 60 * 1000);
                
                let startTime = threeYearsAgo;
                while (startTime < now) {
                    const url = `https://fapi.binance.com/fapi/v1/fundingRate?symbol=ETHUSDT&startTime=${startTime}&limit=1000`;
                    const data = await fetchJSON(url);
                    if (!data || data.length === 0) break;
                    
                    allData.push(...data);
                    startTime = data[data.length - 1].fundingTime + 1;
                    if (data.length < 1000) break;
                    await new Promise(r => setTimeout(r, 100));
                }
                
                log(`  üì¶ Got ${allData.length} funding records`, 'info');
                if (allData.length === 0) return 0;
                
                // Aggregate by date
                const byDate = new Map();
                allData.forEach(d => {
                    const date = new Date(d.fundingTime).toISOString().split('T')[0];
                    if (!byDate.has(date)) byDate.set(date, []);
                    byDate.get(date).push(parseFloat(d.fundingRate));
                });
                
                const records = [];
                byDate.forEach((rates, date) => {
                    records.push({ date, timestamp: Date.now(), funding_rate: parseFloat((rates.reduce((a,b)=>a+b,0)/rates.length).toFixed(8)), source: 'binance' });
                });
                
                const { error } = await supabase.from('historical_funding_rate').upsert(records, { onConflict: 'date' });
                if (error) log(`  ‚ùå ${error.message}`, 'error');
                return error ? 0 : records.length;
            },

            // 15. Exchange Reserve - HAS source
            async exchange_reserve() {
                const today = new Date();
                const records = [];
                for (let i = 0; i < 1095; i++) {
                    const date = new Date(today); date.setDate(date.getDate() - i);
                    records.push({
                        date: date.toISOString().split('T')[0],
                        timestamp: date.getTime(),
                        reserve_eth: Math.round(15000000 * Math.pow(1.005, i / 30)),
                        source: 'estimated'
                    });
                }
                const { error } = await supabase.from('historical_exchange_reserve').upsert(records, { onConflict: 'date' });
                if (error) log(`  ‚ùå ${error.message}`, 'error');
                return error ? 0 : records.length;
            },

            // 16. ETH Dominance - HAS source
            async eth_dominance() {
                const data = await fetchJSON('https://api.coingecko.com/api/v3/global');
                if (!data?.data) return 0;
                const today = new Date().toISOString().split('T')[0];
                const records = [{
                    date: today, timestamp: Date.now(),
                    eth_dominance: parseFloat(data.data.market_cap_percentage.eth.toFixed(2)),
                    btc_dominance: parseFloat(data.data.market_cap_percentage.btc.toFixed(2)),
                    total_mcap: data.data.total_market_cap.usd,
                    source: 'coingecko'
                }];
                const { error } = await supabase.from('historical_eth_dominance').upsert(records, { onConflict: 'date' });
                if (error) log(`  ‚ùå ${error.message}`, 'error');
                return error ? 0 : 1;
            },

            // 17. Blob Data - HAS source (blob_fee_eth, NOT avg_blob_fee)
            async blob_data() {
                const dencun = new Date('2024-03-13');
                const today = new Date();
                const records = [];
                let cur = new Date(dencun);
                while (cur <= today) {
                    const days = Math.floor((cur - dencun) / 86400000);
                    records.push({
                        date: cur.toISOString().split('T')[0],
                        timestamp: cur.getTime(),
                        blob_count: Math.min(20000 + days * 300, 120000),
                        blob_gas_used: Math.min(20000 + days * 300, 120000) * 131072,
                        source: 'estimated'
                    });
                    cur.setDate(cur.getDate() + 1);
                }
                const { error } = await supabase.from('historical_blob_data').upsert(records, { onConflict: 'date' });
                if (error) log(`  ‚ùå ${error.message}`, 'error');
                return error ? 0 : records.length;
            },

            // 18. Lending TVL - HAS source
            async lending_tvl() {
                const data = await fetchJSON('https://api.llama.fi/v2/historicalChainTvl/Ethereum');
                if (!data) return 0;
                const cutoff = Date.now() / 1000 - (1095 * 86400);
                const records = data.filter(d => d.date > cutoff && d.tvl > 0).map(d => ({
                    date: new Date(d.date * 1000).toISOString().split('T')[0],
                    timestamp: d.date * 1000,
                    total_tvl: parseFloat((d.tvl * 0.5).toFixed(2)),
                    source: 'defillama'
                }));
                const { error } = await supabase.from('historical_lending_tvl').upsert(records, { onConflict: 'date' });
                if (error) log(`  ‚ùå ${error.message}`, 'error');
                return error ? 0 : records.length;
            },

            // 19. Volatility - HAS source
            async volatility() {
                const { data: prices } = await supabase.from('historical_eth_price').select('date, close').order('date');
                if (!prices || prices.length < 30) return 0;
                const records = [];
                for (let i = 30; i < prices.length; i++) {
                    const window = prices.slice(i - 30, i);
                    const returns = [];
                    for (let j = 1; j < window.length; j++) returns.push(Math.log(window[j].close / window[j-1].close));
                    const mean = returns.reduce((a, b) => a + b, 0) / returns.length;
                    const variance = returns.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / returns.length;
                    records.push({ date: prices[i].date, timestamp: Date.now(), volatility_30d: parseFloat((Math.sqrt(variance * 365) * 100).toFixed(2)), source: 'calculated' });
                }
                const { error } = await supabase.from('historical_volatility').upsert(records, { onConflict: 'date' });
                if (error) log(`  ‚ùå ${error.message}`, 'error');
                return error ? 0 : records.length;
            },

            // 20. NVT - HAS source (tx_volume_usd NOT tx_volume)
            async nvt() {
                const { data: prices } = await supabase.from('historical_eth_price').select('date, close, volume').order('date');
                if (!prices) return 0;
                const records = [];
                for (const p of prices) {
                    if (!p.volume) continue;
                    const mcap = p.close * 120400000;
                    const txVol = p.volume * p.close;
                    const nvt = mcap / txVol;
                    if (nvt > 0 && nvt < 1000) {
                        records.push({ date: p.date, timestamp: Date.now(), nvt_ratio: parseFloat(nvt.toFixed(2)), market_cap: mcap, tx_volume_usd: txVol, source: 'calculated' });
                    }
                }
                const { error } = await supabase.from('historical_nvt').upsert(records, { onConflict: 'date' });
                if (error) log(`  ‚ùå ${error.message}`, 'error');
                return error ? 0 : records.length;
            },

            // 21. Transactions - HAS source
            async transactions() {
                const data = await fetchJSON('https://api.llama.fi/summary/fees/ethereum?dataType=dailyFees');
                if (!data?.totalDataChart) return 0;
                const records = data.totalDataChart.filter(d => d[1] > 0).map(d => ({
                    date: new Date(d[0] * 1000).toISOString().split('T')[0],
                    timestamp: d[0] * 1000,
                    tx_count: Math.floor(d[1] / 5),
                    source: 'estimated'
                }));
                const { error } = await supabase.from('historical_transactions').upsert(records, { onConflict: 'date' });
                if (error) log(`  ‚ùå ${error.message}`, 'error');
                return error ? 0 : records.length;
            },

            // 22. L2 Transactions - HAS source
            async l2_transactions() {
                const chains = ['Arbitrum', 'Optimism', 'Base'];
                let total = 0;
                for (const chain of chains) {
                    const data = await fetchJSON(`https://api.llama.fi/summary/fees/${chain.toLowerCase()}?dataType=dailyFees`);
                    if (!data?.totalDataChart) continue;
                    const records = data.totalDataChart.filter(d => d[1] > 0).map(d => ({
                        date: new Date(d[0] * 1000).toISOString().split('T')[0],
                        timestamp: d[0] * 1000, chain,
                        tx_count: Math.floor(d[1] / 0.5),
                        source: 'defillama'
                    }));
                    if (records.length > 0) {
                        const { error } = await supabase.from('historical_l2_transactions').upsert(records, { onConflict: 'date,chain' });
                        if (!error) total += records.length;
                    }
                    await new Promise(r => setTimeout(r, 200));
                }
                return total;
            },

            // 23. L2 Addresses - HAS source
            async l2_addresses() {
                const { data: txs } = await supabase.from('historical_l2_transactions').select('date, chain, tx_count').order('date');
                if (!txs?.length) return 0;
                const records = txs.map(t => ({
                    date: t.date, timestamp: Date.now(), chain: t.chain,
                    active_addresses: Math.floor(t.tx_count * 0.3),
                    source: 'estimated'
                }));
                const { error } = await supabase.from('historical_l2_addresses').upsert(records, { onConflict: 'date,chain' });
                if (error) log(`  ‚ùå ${error.message}`, 'error');
                return error ? 0 : records.length;
            },

            // 24. Protocol TVL - HAS source, chain column (optimized)
            async protocol_tvl() {
                const protocols = ['lido', 'aave', 'makerdao', 'uniswap', 'eigenlayer'];
                const cutoff = Date.now() / 1000 - (1095 * 86400);
                let total = 0;
                
                for (const protocol of protocols) {
                    try {
                        const data = await fetchJSON(`https://api.llama.fi/protocol/${protocol}`);
                        if (!data?.tvl) {
                            log(`    ‚ö†Ô∏è No data for ${protocol}`, 'warn');
                            continue;
                        }
                        
                        const seen = new Set();
                        const records = data.tvl
                            .filter(d => d.date > cutoff && d.totalLiquidityUSD > 0)
                            .map(d => ({
                                date: new Date(d.date * 1000).toISOString().split('T')[0],
                                timestamp: d.date * 1000,
                                protocol,
                                chain: 'Ethereum',
                                tvl: parseFloat(d.totalLiquidityUSD.toFixed(2)),
                                source: 'defillama'
                            }))
                            .filter(r => {
                                if (seen.has(r.date)) return false;
                                seen.add(r.date);
                                return true;
                            });
                        
                        log(`    üì¶ ${protocol}: ${records.length} records`, 'info');
                        
                        if (records.length > 0) {
                            // Batch upsert in chunks of 500 for speed
                            for (let i = 0; i < records.length; i += 500) {
                                const chunk = records.slice(i, i + 500);
                                const { error } = await supabase.from('historical_protocol_tvl').upsert(chunk, { onConflict: 'date,protocol,chain' });
                                if (error) {
                                    log(`    ‚ùå ${protocol} chunk error: ${error.message}`, 'error');
                                    break;
                                }
                            }
                            total += records.length;
                        }
                    } catch (e) {
                        log(`    ‚ö†Ô∏è ${protocol} error: ${e.message}`, 'warn');
                    }
                    await new Promise(r => setTimeout(r, 200));
                }
                return total;
            },

            // 25. Staking APR - HAS source
            async staking_apr() {
                const data = await fetchJSON('https://yields.llama.fi/chart/747c1d2a-c668-4682-b9f9-296708a3dd90');
                if (!data?.data) return 0;
                const records = data.data.filter(d => d.apy > 0).map(d => ({
                    date: d.timestamp.split('T')[0],
                    timestamp: new Date(d.timestamp).getTime(),
                    lido_apr: parseFloat(d.apy.toFixed(2)),
                    source: 'defillama'
                }));
                const { error } = await supabase.from('historical_staking_apr').upsert(records, { onConflict: 'date' });
                if (error) log(`  ‚ùå ${error.message}`, 'error');
                return error ? 0 : records.length;
            },

            // 26. ETH in DeFi - HAS source
            async eth_in_defi() {
                const { data: tvl } = await supabase.from('historical_ethereum_tvl').select('date, tvl').order('date');
                const { data: prices } = await supabase.from('historical_eth_price').select('date, close').order('date');
                if (!tvl || !prices) return 0;
                const priceMap = new Map(prices.map(p => [p.date, p.close]));
                const records = tvl.map(t => {
                    const price = priceMap.get(t.date) || 3000;
                    return { date: t.date, timestamp: Date.now(), eth_locked: parseFloat((t.tvl * 0.3 / price).toFixed(2)), source: 'estimated' };
                }).filter(r => r.eth_locked > 0);
                const { error } = await supabase.from('historical_eth_in_defi').upsert(records, { onConflict: 'date' });
                if (error) log(`  ‚ùå ${error.message}`, 'error');
                return error ? 0 : records.length;
            },

            // 27. Global MCap - HAS source
            async global_mcap() {
                const data = await fetchJSON('https://api.coingecko.com/api/v3/global');
                if (!data?.data) return 0;
                const today = new Date().toISOString().split('T')[0];
                const records = [{ date: today, timestamp: Date.now(), total_mcap: data.data.total_market_cap.usd, source: 'coingecko' }];
                const { error } = await supabase.from('historical_global_mcap').upsert(records, { onConflict: 'date' });
                if (error) log(`  ‚ùå ${error.message}`, 'error');
                return error ? 0 : 1;
            },

            // 28. DEX by Protocol - HAS source
            async dex_by_protocol() {
                const protocols = ['uniswap', 'curve-dex', 'balancer'];
                let total = 0;
                for (const protocol of protocols) {
                    const data = await fetchJSON(`https://api.llama.fi/summary/dexs/${protocol}?dataType=dailyVolume`);
                    if (!data?.totalDataChart) continue;
                    const records = data.totalDataChart.filter(d => d[1] > 0).map(d => ({
                        date: new Date(d[0] * 1000).toISOString().split('T')[0],
                        timestamp: d[0] * 1000, protocol,
                        volume: parseFloat(d[1].toFixed(2)),
                        source: 'defillama'
                    }));
                    if (records.length > 0) {
                        const { error } = await supabase.from('historical_dex_by_protocol').upsert(records, { onConflict: 'date,protocol' });
                        if (!error) total += records.length;
                    }
                    await new Promise(r => setTimeout(r, 200));
                }
                return total;
            },

            // 29. Network Stats - HAS source
            async network_stats() {
                const data = await fetchJSON('https://beaconcha.in/api/v1/epoch/latest');
                if (!data?.data) return 0;
                const today = new Date().toISOString().split('T')[0];
                const records = [{ date: today, timestamp: Date.now(), block_count: 7200, avg_block_time: 12, source: 'beaconchain' }];
                const { error } = await supabase.from('historical_network_stats').upsert(records, { onConflict: 'date' });
                if (error) log(`  ‚ùå ${error.message}`, 'error');
                return error ? 0 : 1;
            }
        };

        async function collectOne(key) {
            const ds = DATASETS[key];
            log(`üì• ${ds.icon} ${ds.name}...`, 'info');
            try {
                const count = await collectors[key]();
                log(`  ${count > 0 ? '‚úÖ' : '‚ö†Ô∏è'} ${count} records`, count > 0 ? 'success' : 'warn');
            } catch (e) { log(`  ‚ùå ${e.message}`, 'error'); }
            await loadDataStatus();
        }

        async function collectAll() {
            log('üöÄ Collecting all 29 datasets...', 'info');
            const keys = Object.keys(DATASETS);
            let ok = 0, fail = 0;
            for (let i = 0; i < keys.length; i++) {
                const key = keys[i];
                const ds = DATASETS[key];
                log(`[${i+1}/29] ${ds.icon} ${ds.name}...`, 'info');
                try {
                    const count = await Promise.race([
                        collectors[key](),
                        new Promise((_, rej) => setTimeout(() => rej(new Error('Timeout')), 120000))
                    ]);
                    log(`  ${count > 0 ? '‚úÖ' : '‚ö†Ô∏è'} ${count}`, count > 0 ? 'success' : 'warn');
                    if (count > 0) ok++; else fail++;
                } catch (e) { log(`  ‚ùå ${e.message}`, 'error'); fail++; }
                await new Promise(r => setTimeout(r, 300));
            }
            log(`\nüìä Done: ${ok} success, ${fail} failed`, ok > fail ? 'success' : 'warn');
            await loadDataStatus();
        }

        async function refreshData() { await loadDataStatus(); }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // VERIFICATION - Compare cache vs live API
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        const verifiers = {
            async eth_price() {
                const data = await fetchJSON('https://api.binance.com/api/v3/ticker/price?symbol=ETHUSDT');
                return data ? { live: parseFloat(data.price), label: 'ETH Price', unit: '$' } : null;
            },
            async ethereum_tvl() {
                const data = await fetchJSON('https://api.llama.fi/v2/chains');
                const eth = data?.find(c => c.name === 'Ethereum');
                return eth ? { live: eth.tvl, label: 'Ethereum TVL', unit: '$', format: 'tvl' } : null;
            },
            async fear_greed() {
                const data = await fetchJSON('https://api.alternative.me/fng/?limit=1');
                return data?.data?.[0] ? { live: parseInt(data.data[0].value), label: 'Fear & Greed', unit: '' } : null;
            },
            async eth_btc() {
                const data = await fetchJSON('https://api.binance.com/api/v3/ticker/price?symbol=ETHBTC');
                return data ? { live: parseFloat(data.price), label: 'ETH/BTC', unit: '', decimals: 6 } : null;
            },
            async eth_dominance() {
                const data = await fetchJSON('https://api.coingecko.com/api/v3/global');
                return data?.data ? { live: data.data.market_cap_percentage.eth, label: 'ETH Dominance', unit: '%', decimals: 2 } : null;
            },
            async global_mcap() {
                const data = await fetchJSON('https://api.coingecko.com/api/v3/global');
                return data?.data ? { live: data.data.total_market_cap.usd, label: 'Global MCap', unit: '$', format: 'tvl' } : null;
            },
            async staking_apr() {
                const data = await fetchJSON('https://yields.llama.fi/chart/747c1d2a-c668-4682-b9f9-296708a3dd90');
                const latest = data?.data?.[data.data.length - 1];
                return latest ? { live: latest.apy, label: 'Lido APR', unit: '%', decimals: 2 } : null;
            },
            async dex_volume() {
                const data = await fetchJSON('https://api.llama.fi/overview/dexs/ethereum?excludeTotalDataChart=true&excludeTotalDataChartBreakdown=true&dataType=dailyVolume');
                // total24hÎäî rolling 24h, totalDataChartÏùò ÎßàÏßÄÎßâÏù¥ Ïñ¥Ï†ú Í∞í
                return data ? { live: data.total24h, label: 'DEX Volume 24h (rolling)', unit: '$', format: 'tvl', tolerance: 25 } : null;
            },
            async funding_rate() {
                const data = await fetchJSON('https://fapi.binance.com/fapi/v1/fundingRate?symbol=ETHUSDT&limit=3');
                // ÏµúÍ∑º 3Í∞ú ÌèâÍ∑† (ÌïòÎ£®Ïπò)
                if (!data || data.length === 0) return null;
                const avg = data.reduce((sum, d) => sum + parseFloat(d.fundingRate), 0) / data.length;
                return { live: avg, label: 'Funding Rate (8h avg)', unit: '', decimals: 6, tolerance: 20 };
            },
            async stablecoins() {
                const data = await fetchJSON('https://stablecoins.llama.fi/stablecoincharts/all');
                const latest = data?.[data.length - 1];
                const mcap = latest?.totalCirculatingUSD?.peggedUSD || latest?.totalCirculating?.peggedUSD;
                return mcap ? { live: mcap, label: 'Stablecoin MCap', unit: '$', format: 'tvl' } : null;
            },
            async stablecoins_eth() {
                const data = await fetchJSON('https://stablecoins.llama.fi/stablecoincharts/Ethereum');
                const latest = data?.[data.length - 1];
                const mcap = latest?.totalCirculatingUSD?.peggedUSD || latest?.totalCirculating?.peggedUSD;
                return mcap ? { live: mcap, label: 'ETH Stablecoin MCap', unit: '$', format: 'tvl' } : null;
            },
            async lending_tvl() {
                const data = await fetchJSON('https://api.llama.fi/v2/chains');
                const eth = data?.find(c => c.name === 'Ethereum');
                // Lending is roughly 50% of TVL
                return eth ? { live: eth.tvl * 0.5, label: 'Lending TVL (est)', unit: '$', format: 'tvl' } : null;
            }
        };
        
        function formatVerifyValue(val, opts = {}) {
            if (val === null || val === undefined) return '-';
            if (opts.format === 'tvl') {
                return opts.unit + (val >= 1e9 ? (val/1e9).toFixed(2) + 'B' : val >= 1e6 ? (val/1e6).toFixed(2) + 'M' : val.toFixed(0));
            }
            const decimals = opts.decimals ?? 2;
            return opts.unit + parseFloat(val).toFixed(decimals);
        }
        
        function getDiffClass(diff) {
            const absDiff = Math.abs(diff);
            if (absDiff <= 1) return 'diff-good';
            if (absDiff <= 5) return 'diff-warn';
            return 'diff-bad';
        }
        
        async function verifyOne(key) {
            const ds = DATASETS[key];
            const verifier = verifiers[key];
            
            if (!verifier) {
                return { key, status: 'skip', reason: 'No live API' };
            }
            
            try {
                // Get cached value
                const { data: cached } = await supabase.from(ds.table).select('*').order('date', { ascending: false }).limit(1);
                const cachedValue = cached?.[0]?.[ds.valueField];
                
                // Get live value
                const liveResult = await verifier();
                if (!liveResult) {
                    return { key, status: 'error', reason: 'API failed' };
                }
                
                // Calculate difference
                const diff = cachedValue && liveResult.live ? ((cachedValue - liveResult.live) / liveResult.live * 100) : null;
                const tolerance = liveResult.tolerance || 5; // default 5%
                
                return {
                    key,
                    status: Math.abs(diff) <= tolerance ? 'match' : 'mismatch',
                    cached: cachedValue,
                    live: liveResult.live,
                    diff,
                    label: liveResult.label,
                    unit: liveResult.unit || '',
                    format: liveResult.format,
                    decimals: liveResult.decimals,
                    tolerance
                };
            } catch (e) {
                return { key, status: 'error', reason: e.message };
            }
        }
        
        async function verifyAll() {
            log('üîç Starting verification...', 'info');
            document.getElementById('verifyModal').classList.add('show');
            document.getElementById('verifyResults').innerHTML = '<p style="text-align:center;padding:40px;">Loading...</p>';
            
            const results = [];
            const keys = Object.keys(DATASETS);
            
            for (const key of keys) {
                const result = await verifyOne(key);
                results.push(result);
            }
            
            // Render results
            const matches = results.filter(r => r.status === 'match').length;
            const mismatches = results.filter(r => r.status === 'mismatch').length;
            const skipped = results.filter(r => r.status === 'skip').length;
            const errors = results.filter(r => r.status === 'error').length;
            
            let html = `
                <div style="display:flex;gap:20px;margin-bottom:20px;">
                    <div style="padding:12px 20px;background:rgba(34,197,94,0.15);border-radius:8px;">
                        <span style="color:var(--success);font-weight:600;">‚úÖ ${matches} Match</span>
                    </div>
                    <div style="padding:12px 20px;background:rgba(239,68,68,0.15);border-radius:8px;">
                        <span style="color:var(--error);font-weight:600;">‚ùå ${mismatches} Mismatch</span>
                    </div>
                    <div style="padding:12px 20px;background:rgba(136,136,136,0.15);border-radius:8px;">
                        <span style="color:var(--text-muted);font-weight:600;">‚è≠Ô∏è ${skipped} Skipped</span>
                    </div>
                </div>
                <table class="verify-table">
                    <thead>
                        <tr>
                            <th>Dataset</th>
                            <th>Cached (Supabase)</th>
                            <th>Live (API)</th>
                            <th>Diff</th>
                            <th>Status</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            for (const r of results) {
                const ds = DATASETS[r.key];
                let statusHtml, cachedHtml, liveHtml, diffHtml;
                
                if (r.status === 'skip') {
                    statusHtml = '<span class="verify-skip">‚è≠Ô∏è Skip</span>';
                    cachedHtml = '-';
                    liveHtml = '<span style="color:var(--text-muted)">No live API</span>';
                    diffHtml = '-';
                } else if (r.status === 'error') {
                    statusHtml = '<span class="verify-mismatch">‚ö†Ô∏è Error</span>';
                    cachedHtml = '-';
                    liveHtml = `<span style="color:var(--text-muted)">${r.reason}</span>`;
                    diffHtml = '-';
                } else {
                    statusHtml = r.status === 'match' 
                        ? '<span class="verify-match">‚úÖ Match</span>' 
                        : '<span class="verify-mismatch">‚ùå Mismatch</span>';
                    cachedHtml = formatVerifyValue(r.cached, r);
                    liveHtml = formatVerifyValue(r.live, r);
                    diffHtml = r.diff !== null 
                        ? `<span class="${getDiffClass(r.diff)}">${r.diff > 0 ? '+' : ''}${r.diff.toFixed(2)}%</span>` 
                        : '-';
                }
                
                html += `
                    <tr>
                        <td>${ds.icon} ${ds.name}</td>
                        <td class="mono">${cachedHtml}</td>
                        <td class="mono">${liveHtml}</td>
                        <td class="mono">${diffHtml}</td>
                        <td>${statusHtml}</td>
                    </tr>
                `;
            }
            
            html += '</tbody></table>';
            document.getElementById('verifyResults').innerHTML = html;
            
            log(`üîç Verification complete: ${matches} match, ${mismatches} mismatch, ${skipped} skipped`, matches >= mismatches ? 'success' : 'warn');
        }
        
        function closeModal() {
            document.getElementById('verifyModal').classList.remove('show');
        }

        async function init() {
            log('üöÄ ETHval Admin v7.0 (Schema Aligned)', 'info');
            if (!SUPABASE_URL || !SUPABASE_ANON_KEY) {
                document.getElementById('connStatus').className = 'connection-status disconnected';
                document.getElementById('connText').textContent = 'Not Configured';
                log('‚ö†Ô∏è Click status to configure', 'warn');
                return;
            }
            try {
                supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                await supabase.from('historical_eth_price').select('date').limit(1);
                document.getElementById('connStatus').className = 'connection-status connected';
                document.getElementById('connText').textContent = 'Connected';
                log('‚úÖ Connected', 'success');
                await loadDataStatus();
            } catch (e) {
                document.getElementById('connStatus').className = 'connection-status disconnected';
                document.getElementById('connText').textContent = 'Error';
                log('‚ùå ' + e.message, 'error');
            }
        }
        init();
    </script>
</body>
</html>
