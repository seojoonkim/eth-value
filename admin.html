<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ETHval Admin v7.8 - CryptoQuant</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        :root { --bg: #0a0a0f; --bg-card: #12121a; --bg-hover: #1a1a25; --border: #2a2a3a; --text: #e5e5e5; --text-muted: #888; --primary: #8b5cf6; --success: #22c55e; --warning: #f59e0b; --error: #ef4444; --surface: #1a1a2e; }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Inter', sans-serif; background: var(--bg); color: var(--text); min-height: 100vh; padding: 16px; }
        .container { max-width: 1600px; margin: 0 auto; }
        .header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; padding-bottom: 12px; border-bottom: 1px solid var(--border); flex-wrap: wrap; gap: 12px; }
        .header h1 { font-size: 20px; font-weight: 700; }
        .badge { background: var(--primary); color: white; font-size: 9px; padding: 3px 6px; border-radius: 4px; font-weight: 600; margin-left: 8px; }
        .header-actions { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
        .btn { padding: 8px 14px; border: none; border-radius: 6px; font-size: 12px; font-weight: 500; cursor: pointer; display: flex; align-items: center; gap: 6px; transition: all 0.2s; }
        .btn-primary { background: var(--primary); color: white; }
        .btn-primary:hover { background: #7c3aed; }
        .btn-success { background: var(--success); color: white; }
        .btn-warning { background: var(--warning); color: black; }
        .btn-secondary { background: var(--bg-card); color: var(--text); border: 1px solid var(--border); }
        .btn-sm { padding: 4px 8px; font-size: 10px; }
        .connection-status { display: flex; align-items: center; gap: 4px; padding: 4px 10px; border-radius: 16px; font-size: 11px; background: var(--bg-card); border: 1px solid var(--border); cursor: pointer; }
        .connection-status.connected { border-color: var(--success); color: var(--success); }
        .connection-status.disconnected { border-color: var(--error); color: var(--error); }
        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 8px; margin-bottom: 16px; }
        .stat-card { background: var(--bg-card); border: 1px solid var(--border); border-radius: 8px; padding: 10px; text-align: center; }
        .stat-card .label { font-size: 9px; color: var(--text-muted); text-transform: uppercase; margin-bottom: 2px; }
        .stat-card .value { font-size: 22px; font-weight: 700; }
        .stat-card .value.success { color: var(--success); }
        .stat-card .value.warning { color: var(--warning); }
        .stat-card .value.error { color: var(--error); }
        .table-container { background: var(--bg-card); border: 1px solid var(--border); border-radius: 12px; overflow: hidden; margin-bottom: 20px; }
        .section-title { font-size: 14px; font-weight: 600; padding: 12px 16px; border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center; }
        table { width: 100%; border-collapse: collapse; }
        th, td { padding: 6px 10px; text-align: left; border-bottom: 1px solid var(--border); }
        th { background: var(--bg); font-size: 10px; text-transform: uppercase; color: var(--text-muted); font-weight: 600; padding: 8px 10px; }
        tr:last-child td { border-bottom: none; }
        tr:hover td { background: var(--bg-hover); }
        .mono { font-family: 'JetBrains Mono', monospace; font-size: 11px; }
        .table-name { font-family: 'JetBrains Mono', monospace; font-size: 9px; color: var(--text-muted); }
        .status { display: inline-flex; align-items: center; gap: 4px; padding: 2px 6px; border-radius: 10px; font-size: 10px; font-weight: 600; }
        .status.ok { background: rgba(34, 197, 94, 0.15); color: var(--success); }
        .status.warn { background: rgba(245, 158, 11, 0.15); color: var(--warning); }
        .status.fail { background: rgba(239, 68, 68, 0.15); color: var(--error); }
        .progress { width: 100%; height: 4px; background: var(--bg); border-radius: 2px; overflow: hidden; }
        .progress-fill { height: 100%; border-radius: 2px; transition: width 0.3s; }
        .log-container { background: var(--bg-card); border: 1px solid var(--border); border-radius: 12px; padding: 12px; }
        .log { font-family: 'JetBrains Mono', monospace; font-size: 11px; height: 250px; overflow-y: auto; white-space: pre-wrap; background: var(--bg); padding: 10px; border-radius: 8px; }
        .log .success { color: var(--success); }
        .log .error { color: var(--error); }
        .log .warn { color: var(--warning); }
        .log .info { color: var(--primary); }
        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000; justify-content: center; align-items: center; }
        .modal.show { display: flex; }
        .modal-content { background: var(--bg-card); border: 1px solid var(--border); border-radius: 12px; padding: 20px; max-width: 900px; width: 90%; max-height: 80vh; overflow-y: auto; }
        .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; padding-bottom: 12px; border-bottom: 1px solid var(--border); }
        .modal-header h2 { font-size: 16px; }
        .modal-close { background: none; border: none; color: var(--text-muted); font-size: 24px; cursor: pointer; }
        .verify-table { width: 100%; border-collapse: collapse; font-size: 12px; }
        .verify-table th, .verify-table td { padding: 8px 10px; text-align: left; border-bottom: 1px solid var(--border); }
        .verify-table th { background: var(--bg); font-size: 10px; text-transform: uppercase; color: var(--text-muted); }
        .verify-match { color: var(--success); }
        .verify-mismatch { color: var(--error); }
        .verify-skip { color: var(--text-muted); }
        .diff-good { color: var(--success); }
        .diff-warn { color: var(--warning); }
        .diff-bad { color: var(--error); }
        .action-btns { display: flex; gap: 4px; align-items: center; }
        .action-btn { display: inline-flex; align-items: center; gap: 3px; padding: 3px 6px; font-size: 10px; border-radius: 4px; cursor: pointer; border: 1px solid var(--border); background: transparent; color: var(--text-muted); transition: all 0.15s; }
        .action-btn:hover { background: var(--bg-hover); color: var(--text); border-color: var(--primary); }
        .action-btn:disabled { opacity: 0.4; cursor: not-allowed; }
        .action-btn svg { width: 12px; height: 12px; }
        .stale-reason { font-size: 9px; color: var(--warning); margin-left: 4px; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>âš¡ ETHval Admin <span class="badge">v7.8</span></h1>
            <div class="header-actions">
                <div class="connection-status" id="connStatus" onclick="showConfig()">
                    <span>â—</span>
                    <span id="connText">Connecting...</span>
                </div>
                <button class="btn btn-secondary" onclick="showConfig()">âš™ï¸ Config</button>
                <button class="btn btn-warning" onclick="showDataManager()">ğŸ—‘ï¸ Data Manager</button>
                <button class="btn btn-success" onclick="collectAll()">ğŸš€ Collect All</button>
                <button class="btn btn-primary" onclick="verifyAll()">ğŸ” Verify All</button>
                <button class="btn btn-secondary" onclick="refreshData()">ğŸ”„ Refresh</button>
            </div>
        </div>
        
        <!-- Data Manager Modal -->
        <div id="dataManagerModal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:1000; justify-content:center; align-items:center;">
            <div style="background:var(--bg-card); border:1px solid var(--border); border-radius:12px; padding:24px; max-width:600px; width:90%; max-height:80vh; overflow-y:auto;">
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
                    <h2 style="font-size:18px;">ğŸ—‘ï¸ Data Manager</h2>
                    <button class="btn btn-secondary" onclick="closeDataManager()">âœ•</button>
                </div>
                
                <div style="margin-bottom:20px; padding:12px; background:rgba(239,68,68,0.1); border:1px solid var(--error); border-radius:8px;">
                    <p style="color:var(--error); font-size:12px; margin-bottom:8px;">âš ï¸ Warning: These actions permanently delete data!</p>
                </div>
                
                <div style="display:grid; gap:12px;">
                    <div style="background:var(--bg); padding:16px; border-radius:8px; border:1px solid var(--border);">
                        <h3 style="font-size:14px; margin-bottom:12px;">ğŸ¥© Staking Data (historical_staking)</h3>
                        <p style="font-size:11px; color:var(--text-muted); margin-bottom:12px;">Delete all staking data and recollect from Dune (beacon chain)</p>
                        <div style="display:flex; gap:8px;">
                            <button class="btn btn-warning" onclick="deleteTableData('historical_staking')">ğŸ—‘ï¸ Delete All</button>
                            <button class="btn btn-success" onclick="recollectStaking()">ğŸ”„ Delete & Recollect</button>
                        </div>
                    </div>
                    
                    <div style="background:var(--bg); padding:16px; border-radius:8px; border:1px solid var(--border);">
                        <h3 style="font-size:14px; margin-bottom:12px;">ğŸ’¹ Staking APR (historical_staking_apr)</h3>
                        <p style="font-size:11px; color:var(--text-muted); margin-bottom:12px;">Delete staking APR history data</p>
                        <div style="display:flex; gap:8px;">
                            <button class="btn btn-warning" onclick="deleteTableData('historical_staking_apr')">ğŸ—‘ï¸ Delete All</button>
                        </div>
                    </div>
                    
                    <div style="background:var(--bg); padding:16px; border-radius:8px; border:1px solid var(--border);">
                        <h3 style="font-size:14px; margin-bottom:12px;">ğŸ“Š Other Tables</h3>
                        <p style="font-size:11px; color:var(--text-muted); margin-bottom:12px;">Select a table to delete its data</p>
                        <select id="tableSelect" style="width:100%; padding:8px; margin-bottom:12px; background:var(--bg-card); border:1px solid var(--border); border-radius:6px; color:var(--text);">
                            <option value="">-- Select Table --</option>
                            <option value="historical_eth_price">ETH Price</option>
                            <option value="historical_tvl">TVL</option>
                            <option value="historical_fees">Fees</option>
                            <option value="historical_dex_volume">DEX Volume</option>
                            <option value="historical_stables_eth">Stablecoins</option>
                            <option value="historical_l2_tvl">L2 TVL</option>
                            <option value="historical_gas">Gas</option>
                            <option value="historical_supply">Supply</option>
                            <option value="historical_reserve">Exchange Reserve</option>
                        </select>
                        <button class="btn btn-warning" onclick="deleteSelectedTable()">ğŸ—‘ï¸ Delete Selected</button>
                    </div>
                </div>
                
                <div id="dataManagerLog" style="margin-top:16px; padding:12px; background:var(--bg); border-radius:8px; font-family:'JetBrains Mono',monospace; font-size:11px; max-height:200px; overflow-y:auto; display:none;"></div>
            </div>
        </div>
        
        <div class="stats-grid">
            <div class="stat-card"><div class="label">Total</div><div class="value" id="stats-total">--</div></div>
            <div class="stat-card"><div class="label">OK</div><div class="value success" id="statOk">-</div></div>
            <div class="stat-card"><div class="label">Partial</div><div class="value warning" id="statPartial">-</div></div>
            <div class="stat-card"><div class="label">Failed</div><div class="value error" id="statFailed">-</div></div>
            <div class="stat-card"><div class="label">Stale (>3d)</div><div class="value error" id="statStale">-</div></div>
            <div class="stat-card"><div class="label">Records</div><div class="value" id="statRecords">-</div></div>
        </div>
        
        <!-- Scheduler Logs Section -->
        <div class="table-container" style="margin-bottom: 24px;">
            <div class="section-title">
                <span>ğŸ¤– Scheduler Logs (Last 10 Runs)</span>
                <button class="btn btn-secondary" style="padding: 4px 12px; font-size: 12px;" onclick="refreshSchedulerLogs()">ğŸ”„ Refresh</button>
            </div>
            <div id="scheduler-logs-container">
                <div style="display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 16px;" id="scheduler-summary">
                    <div class="stat-card" style="flex: 1; min-width: 120px;"><div class="label">Total Runs</div><div class="value" id="sched-total">-</div></div>
                    <div class="stat-card" style="flex: 1; min-width: 120px;"><div class="label">Successful</div><div class="value success" id="sched-success">-</div></div>
                    <div class="stat-card" style="flex: 1; min-width: 120px;"><div class="label">Partial</div><div class="value warning" id="sched-partial">-</div></div>
                    <div class="stat-card" style="flex: 1; min-width: 120px;"><div class="label">Failed</div><div class="value error" id="sched-failed">-</div></div>
                    <div class="stat-card" style="flex: 1; min-width: 120px;"><div class="label">Last Run</div><div class="value" id="sched-last" style="font-size: 12px;">-</div></div>
                </div>
                <table>
                    <thead>
                        <tr>
                            <th>Date & Time</th>
                            <th>Trigger</th>
                            <th>Status</th>
                            <th>Duration</th>
                            <th>Success</th>
                            <th>Failed</th>
                            <th>Failed Datasets</th>
                        </tr>
                    </thead>
                    <tbody id="scheduler-logs-table">
                        <tr><td colspan="7" style="text-align: center; padding: 20px; color: var(--text-muted);">Loading scheduler logs...</td></tr>
                    </tbody>
                </table>
            </div>
        </div>
        
        <!-- AI Commentary Section -->
        <div class="table-container" style="margin-bottom: 24px;">
            <div class="section-title">
                <span>ğŸ¤– AI Commentary (Claude Haiku)</span>
                <div style="display: flex; gap: 8px; align-items: center;">
                    <span class="mono" id="commentary-status" style="font-size: 11px; color: var(--text-muted);">Ready</span>
                </div>
            </div>
            <div style="padding: 20px;">
                <div style="display: flex; gap: 12px; flex-wrap: wrap; margin-bottom: 16px;">
                    <button class="btn btn-primary" onclick="regenerateAllCommentary()" id="btn-regen-all">
                        ğŸ”„ Regenerate All (7 Sections)
                    </button>
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <select id="section-select" style="padding: 8px 12px; border-radius: 6px; border: 1px solid var(--border); background: var(--bg); color: var(--text);">
                            <option value="">-- Select Section --</option>
                            <option value="investor_sentiment">01. Investor Sentiment</option>
                            <option value="market_position">02. Market Position</option>
                            <option value="supply_dynamics">03. Supply Dynamics</option>
                            <option value="network_demand">04. Network Demand</option>
                            <option value="user_activity">05. User Activity</option>
                            <option value="locked_capital">06. Locked Capital</option>
                            <option value="settlement_volume">07. Settlement Volume</option>
                        </select>
                        <button class="btn btn-secondary" onclick="regenerateSingleCommentary()" id="btn-regen-single">
                            ğŸ¯ Regenerate Selected
                        </button>
                    </div>
                    <button class="btn btn-secondary" onclick="loadTodayCommentary()" id="btn-view-today">
                        ğŸ“‹ View Today's Commentary
                    </button>
                    <button class="btn" onclick="previewAllSectionsData()" id="btn-data-preview" style="background: #2d4a3e; border-color: #3d6a4e;">
                        ğŸ” Data Preview (All Sections)
                    </button>
                </div>
                
                <!-- Data Preview Panel -->
                <div id="data-preview-panel" style="display: none; margin-top: 16px; background: #0d1117; border: 1px solid var(--border); border-radius: 8px; padding: 16px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                        <div style="font-weight: 600; font-size: 14px;">ğŸ” AI Commentary Data Preview</div>
                        <button class="btn btn-sm" onclick="document.getElementById('data-preview-panel').style.display='none'" style="background: transparent; border: none; font-size: 16px;">âœ•</button>
                    </div>
                    <div id="data-preview-content" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap: 16px; max-height: 600px; overflow-y: auto;">
                    </div>
                </div>
                
                <!-- Today's Commentary Viewer -->
                <div id="commentary-viewer" style="display: none; margin-top: 16px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                        <div style="font-weight: 600; color: var(--text);">ğŸ“‹ Today's Commentary (<span id="commentary-date">-</span>)</div>
                        <div style="display: flex; gap: 4px;">
                            <button class="btn btn-sm" onclick="switchCommentaryLang('en')" id="lang-btn-en" style="background: var(--primary); color: white;">EN</button>
                            <button class="btn btn-sm" onclick="switchCommentaryLang('ko')" id="lang-btn-ko">KO</button>
                            <button class="btn btn-sm" onclick="switchCommentaryLang('zh')" id="lang-btn-zh">ZH</button>
                            <button class="btn btn-sm" onclick="switchCommentaryLang('ja')" id="lang-btn-ja">JA</button>
                        </div>
                    </div>
                    <div id="commentary-cards" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: 12px;">
                    </div>
                </div>
                
                <!-- Progress Log -->
                <div id="commentary-log" style="margin-top: 16px; background: #1a1a2e; border-radius: 8px; padding: 12px; max-height: 200px; overflow-y: auto; font-family: monospace; font-size: 11px; display: none;">
                </div>
            </div>
        </div>
        
        <div class="table-container">
            <div class="section-title">
                <span>ğŸ“Š Datasets</span>
                <div style="display:flex;gap:6px;align-items:center;">
                    <span class="mono" style="font-size:10px;color:var(--text-muted);">Last: <span id="lastUpdate">-</span></span>
                    <button class="btn btn-sm" onclick="loadDataStatus()">ğŸ”„</button>
                </div>
            </div>
            <table>
                <thead>
                    <tr>
                        <th style="width:24px;">#</th>
                        <th>Dataset</th>
                        <th>Source</th>
                        <th>Table</th>
                        <th style="text-align:right;">Rows</th>
                        <th>Date Range</th>
                        <th>Value</th>
                        <th style="width:80px;">Cover</th>
                        <th style="text-align:center;">Status</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody id="dataTable"></tbody>
            </table>
        </div>
        <!-- CSV Upload Section (Collapsible) -->
        <div class="table-container" style="margin-bottom: 24px;">
            <div class="section-title" style="cursor: pointer;" onclick="toggleCSVSection()">
                <span>ğŸ“ Manual CSV Import <span style="font-size: 11px; color: var(--text-muted);">(Most data now from APIs - only ETH Supply needs CSV)</span></span>
                <span id="csvToggle" style="font-size: 18px;">â–¼</span>
            </div>
            <div id="csvSection" style="padding: 20px; display: none;">
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 16px; margin-bottom: 16px;">
                    <!-- Total Supply (Primary - still needed) -->
                    <div class="csv-upload-box" id="dropSupply" ondrop="handleDrop(event, 'supply')" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)" style="border: 2px solid var(--primary);">
                        <div class="csv-icon">ğŸ’</div>
                        <div class="csv-title">ETH Supply <span style="font-size: 10px; color: var(--primary);">â˜… Required</span></div>
                        <a href="https://etherscan.io/chart/ethersupply" target="_blank" class="csv-link">ğŸ“¥ Download CSV</a>
                        <input type="file" id="fileSupply" accept=".csv" onchange="handleFile(event, 'supply')" style="display:none">
                        <button class="btn btn-sm btn-primary" onclick="document.getElementById('fileSupply').click()">Select CSV</button>
                        <div class="csv-status" id="statusSupply">No file</div>
                    </div>
                    <!-- Daily Issuance (Optional) -->
                    <div class="csv-upload-box" id="dropDailyIssuance" ondrop="handleDrop(event, 'dailyIssuance')" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)">
                        <div class="csv-icon">ğŸª™</div>
                        <div class="csv-title">Daily Issuance <span style="font-size: 10px; color: var(--text-muted);">Optional</span></div>
                        <a href="#" onclick="alert('Auto-calculated from staking data'); return false;" class="csv-link">ğŸ“Š Auto-calculated</a>
                        <input type="file" id="fileDailyIssuance" accept=".csv" onchange="handleFile(event, 'dailyIssuance')" style="display:none">
                        <button class="btn btn-sm btn-secondary" onclick="document.getElementById('fileDailyIssuance').click()">Select CSV</button>
                        <div class="csv-status" id="statusDailyIssuance">No file</div>
                    </div>
                </div>
                <div style="display: flex; gap: 12px; align-items: center; flex-wrap: wrap;">
                    <button class="btn btn-success" id="importBtn" onclick="importAllCSV()" disabled>ğŸ“¥ Import to Supabase</button>
                    <span id="importProgress" style="color: var(--text-muted); font-size: 13px;"></span>
                </div>
                <div style="margin-top: 12px; padding: 12px; background: var(--bg); border-radius: 8px; font-size: 12px; color: var(--text-muted);">
                    ğŸ’¡ <b>Note:</b> Most data (Gas, Burn, Transactions, Blob, etc.) now fetched via APIs. Only ETH Supply still requires CSV from Etherscan.
                </div>
            </div>
        </div>
        </div>
        
        <style>
            .csv-upload-box { 
                border: 2px dashed var(--border); 
                border-radius: 12px; 
                padding: 20px; 
                text-align: center; 
                transition: all 0.2s;
                cursor: pointer;
            }
            .csv-upload-box:hover, .csv-upload-box.dragover { 
                border-color: var(--primary); 
                background: rgba(139, 92, 246, 0.1); 
            }
            .csv-upload-box.loaded { 
                border-color: var(--success); 
                background: rgba(34, 197, 94, 0.1); 
            }
            .csv-icon { font-size: 32px; margin-bottom: 8px; }
            .csv-title { font-weight: 600; margin-bottom: 4px; }
            .csv-desc { font-size: 11px; color: var(--text-muted); margin-bottom: 12px; }
            .csv-link { display: block; font-size: 11px; color: var(--primary); text-decoration: none; margin-bottom: 10px; }
            .csv-link:hover { text-decoration: underline; }
            .csv-status { margin-top: 10px; font-size: 11px; color: var(--text-muted); }
            .csv-status.success { color: var(--success); }
            .csv-status.error { color: var(--error); }
        </style>

        <div class="log-container">
            <div class="section-title">ğŸ“ Activity Log</div>
            <div class="log" id="log"></div>
        </div>
        
        <!-- Verify Modal -->
        <div class="modal" id="verifyModal">
            <div class="modal-content">
                <div class="modal-header">
                    <h2>ğŸ” Data Verification Results</h2>
                    <button class="modal-close" onclick="closeModal()">&times;</button>
                </div>
                <div id="verifyResults"></div>
            </div>
        </div>
        
        <!-- Config Modal -->
        <div class="modal" id="configModal">
            <div class="modal-content" style="max-width: 500px;">
                <div class="modal-header">
                    <h2>âš™ï¸ Configuration</h2>
                    <button class="modal-close" onclick="closeConfigModal()">&times;</button>
                </div>
                <div style="padding: 20px;">
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: 600;">Supabase URL</label>
                        <input type="text" id="configSupabaseUrl" style="width: 100%; padding: 10px; border-radius: 8px; border: 1px solid var(--border); background: var(--surface); color: var(--text);" placeholder="https://xxxxx.supabase.co">
                    </div>
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: 600;">Supabase Anon Key</label>
                        <input type="text" id="configSupabaseKey" style="width: 100%; padding: 10px; border-radius: 8px; border: 1px solid var(--border); background: var(--surface); color: var(--text);" placeholder="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...">
                    </div>
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: 600;">Etherscan API Key <span style="font-weight: normal; opacity: 0.7;">(free at etherscan.io/apis)</span></label>
                        <input type="text" id="configEtherscanKey" style="width: 100%; padding: 10px; border-radius: 8px; border: 1px solid var(--border); background: var(--surface); color: var(--text);" placeholder="Optional - for transactions & gas data">
                    </div>
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: 600;">Dune API Key <span style="font-weight: normal; opacity: 0.7;">(for blob data - dune.com/settings/api)</span></label>
                        <input type="text" id="configDuneKey" style="width: 100%; padding: 10px; border-radius: 8px; border: 1px solid var(--border); background: var(--surface); color: var(--text);" placeholder="Optional - for accurate blob count data">
                    </div>
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: 600;">Anthropic API Key <span style="font-weight: normal; opacity: 0.7;">(for AI Commentary - console.anthropic.com)</span></label>
                        <input type="text" id="configAnthropicKey" style="width: 100%; padding: 10px; border-radius: 8px; border: 1px solid var(--border); background: var(--surface); color: var(--text);" placeholder="sk-ant-api03-...">
                    </div>
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: 600;">CryptoQuant API Key <span style="font-weight: normal; opacity: 0.7;">(for Funding Rate - cryptoquant.com)</span></label>
                        <input type="text" id="configCryptoQuantKey" style="width: 100%; padding: 10px; border-radius: 8px; border: 1px solid var(--border); background: var(--surface); color: var(--text);" placeholder="Premium/Institutional plan required">
                    </div>
                    
                    <!-- Cloud Sync Section -->
                    <div style="border-top: 1px solid var(--border); padding-top: 15px; margin-top: 15px;">
                        <label style="display: block; margin-bottom: 8px; font-weight: 600;">â˜ï¸ Cloud Sync <span style="font-weight: normal; opacity: 0.7;">(ì•”í˜¸í™” ì €ì¥)</span></label>
                        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
                            <input type="text" id="cloudPassword" style="flex: 1; padding: 10px; border-radius: 8px; border: 1px solid var(--border); background: var(--surface); color: var(--text);" placeholder="íŒ¨ìŠ¤ì›Œë“œ ì…ë ¥...">
                        </div>
                        <div style="display: flex; gap: 8px;">
                            <button class="btn" style="flex: 1; background: #3b82f6;" onclick="loadFromCloud()">ğŸ“¥ ë¶ˆëŸ¬ì˜¤ê¸°</button>
                            <button class="btn" style="flex: 1; background: #8b5cf6;" onclick="saveToCloud()">ğŸ“¤ ì €ì¥í•˜ê¸°</button>
                        </div>
                        <p style="font-size: 11px; opacity: 0.6; margin-top: 8px; margin-bottom: 0;">íŒ¨ìŠ¤ì›Œë“œë¡œ ì•”í˜¸í™”í•˜ì—¬ Supabaseì— ì €ì¥. ë‹¤ë¥¸ ê¸°ê¸°ì—ì„œ íŒ¨ìŠ¤ì›Œë“œë¡œ ë³µì› ê°€ëŠ¥.</p>
                    </div>
                    
                    <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px; border-top: 1px solid var(--border); padding-top: 15px;">
                        <button class="btn btn-secondary" onclick="closeConfigModal()">Cancel</button>
                        <button class="btn btn-success" onclick="saveConfig()">ğŸ’¾ Save & Reload</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let SUPABASE_URL = localStorage.getItem('ethval_supabase_url') || '';
        let SUPABASE_ANON_KEY = localStorage.getItem('ethval_supabase_key') || '';
        let ETHERSCAN_API_KEY = localStorage.getItem('ethval_etherscan_key') || '';
        let DUNE_API_KEY = localStorage.getItem('ethval_dune_key') || '';
        let ANTHROPIC_API_KEY = localStorage.getItem('ethval_anthropic_key') || '';
        let CRYPTOQUANT_API_KEY = localStorage.getItem('cryptoquant_api_key') || '';
        
        // Dune Query IDs
        const DUNE_ETH_PRICE_QUERY_ID = 6390291;      // ETHval - ETH Daily Price
        const DUNE_ETH_BTC_QUERY_ID = 6390302;        // ETHval - ETH BTC Ratio
        const DUNE_BLOB_QUERY_ID = 6350774;
        // REMOVED: const DUNE_TX_VOLUME_QUERY_ID = 6350858;  // Now using L1 Total Volume (6386589)
        const DUNE_ACTIVE_ADDR_QUERY_ID = 6352303;
        const DUNE_L2_ACTIVE_ADDR_QUERY_ID = 6352308;
        // REMOVED: const DUNE_L2_TX_VOLUME_QUERY_ID = 6352386;  // Now using L2 Total Volume (6386591)
        const DUNE_BRIDGE_VOLUME_QUERY_ID = 6352417;
        const DUNE_WHALE_TX_QUERY_ID = 6352498;
        const DUNE_NEW_ADDR_QUERY_ID = 6352513;
        const DUNE_MVRV_QUERY_ID = 6354057;
        const DUNE_STABLECOIN_VOL_QUERY_ID = 6353868;
        const DUNE_GAS_PRICE_QUERY_ID = 6354506;
        const DUNE_L1_TOTAL_VOLUME_QUERY_ID = 6386589;
        const DUNE_L2_TOTAL_VOLUME_QUERY_ID = 6386591;
        let sb;
        
        // CSV Data Storage
        const csvData = { burn: null, tx: null, gas: null, supply: null, dailyIssuance: null, blob: null, gasUtil: null };

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CSV UPLOAD & PARSING
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function handleDragOver(e) {
            e.preventDefault();
            e.currentTarget.classList.add('dragover');
        }
        
        function handleDragLeave(e) {
            e.currentTarget.classList.remove('dragover');
        }
        
        function handleDrop(e, type) {
            e.preventDefault();
            e.currentTarget.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file) processCSV(file, type);
        }
        
        function handleFile(e, type) {
            const file = e.target.files[0];
            if (file) processCSV(file, type);
        }
        
        function processCSV(file, type) {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const text = e.target.result;
                    const lines = text.trim().split('\n');
                    const records = [];
                    
                    // Get header to understand column structure
                    const headerLine = lines[0];
                    
                    // Parse header
                    const headers = parseCSVLine(headerLine);
                    
                    // Skip header, parse data
                    for (let i = 1; i < lines.length; i++) {
                        const line = lines[i].trim();
                        if (!line) continue;
                        
                        const parts = parseCSVLine(line);
                        if (parts.length < 2) continue;
                        
                        const dateStr = parts[0];
                        let timestamp, value;
                        
                        // Handle different CSV formats
                        if (type === 'supply') {
                            // Supply Growth CSV: Date, UnixTimeStamp, TotalSupply
                            // We need to calculate daily change (issuance - burn = net change)
                            // Store raw total supply, we'll calculate daily issuance after parsing all records
                            timestamp = parseInt(parts[1].replace(/,/g, ''));
                            value = parseFloat(parts[2].replace(/,/g, ''));
                            
                        } else if (type === 'dailyIssuance') {
                            // Daily Issuance CSV: date, daily_issuance, eth2_staking_cumulative
                            // ìš°ë¦¬ê°€ ìƒì„±í•œ CSV í˜•ì‹
                            value = parseFloat(parts[1].replace(/,/g, ''));
                            const cumulative = parts[2] ? parseFloat(parts[2].replace(/,/g, '')) : null;
                            
                            let dateObj;
                            if (dateStr.includes('/')) {
                                const [m, d, y] = dateStr.split('/');
                                dateObj = new Date(`${y}-${m.padStart(2,'0')}-${d.padStart(2,'0')}`);
                            } else {
                                dateObj = new Date(dateStr);
                            }
                            timestamp = Math.floor(dateObj.getTime() / 1000);
                            
                            // Store cumulative in record for later use
                            if (cumulative) {
                                records.push({ date: dateStr.includes('/') ? `${dateStr.split('/')[2]}-${dateStr.split('/')[0].padStart(2,'0')}-${dateStr.split('/')[1].padStart(2,'0')}` : dateStr, timestamp, value, cumulative });
                                continue;
                            }
                            
                        } else if (type === 'blob') {
                            // Dune Blob CSV: date, blob_count, blob_gas_used
                            // Date format: "2024-03-13 00:00:00.000 UTC"
                            const blobCount = parseInt(parts[1].replace(/,/g, ''));
                            const blobGasUsed = parseInt(parts[2].replace(/,/g, ''));
                            
                            // Parse Dune date format
                            let dateObj;
                            if (dateStr.includes(' ')) {
                                // "2024-03-13 00:00:00.000 UTC" -> "2024-03-13"
                                dateObj = new Date(dateStr.split(' ')[0]);
                            } else {
                                dateObj = new Date(dateStr);
                            }
                            timestamp = Math.floor(dateObj.getTime() / 1000);
                            const isoDate = dateObj.toISOString().split('T')[0];
                            
                            records.push({ 
                                date: isoDate, 
                                timestamp: timestamp * 1000, // milliseconds
                                blob_count: blobCount,
                                blob_gas_used: blobGasUsed,
                                blob_fee_eth: 0, // Not available in Dune query
                                source: 'dune'
                            });
                            continue;
                            
                        } else if (type === 'gasUtil') {
                            // Etherscan Network Utilization CSV: Date, UnixTimeStamp, Value (decimal 0.xx)
                            timestamp = parseInt(parts[1].replace(/,/g, ''));
                            value = parseFloat(parts[2].replace(/,/g, '')) * 100; // Convert 0.xx to percentage
                            
                            // Convert date format to ISO
                            let isoDate;
                            if (dateStr.includes('/')) {
                                const [m, d, y] = dateStr.split('/');
                                isoDate = `${y}-${m.padStart(2,'0')}-${d.padStart(2,'0')}`;
                            } else {
                                isoDate = dateStr;
                            }
                            
                            records.push({ 
                                date: isoDate, 
                                timestamp, 
                                gas_utilization: parseFloat(value.toFixed(2))
                            });
                            continue;
                            
                        } else if (parts.length === 2) {
                            // 2-column format: Date, Value (no timestamp)
                            const valueStr = parts[1].replace(/,/g, '');
                            value = parseFloat(valueStr);
                            
                            let dateObj;
                            if (dateStr.includes('/')) {
                                const [m, d, y] = dateStr.split('/');
                                dateObj = new Date(`${y}-${m.padStart(2,'0')}-${d.padStart(2,'0')}`);
                            } else {
                                dateObj = new Date(dateStr);
                            }
                            timestamp = Math.floor(dateObj.getTime() / 1000);
                        } else {
                            // 3-column format: Date, Timestamp, Value
                            timestamp = parseInt(parts[1].replace(/,/g, ''));
                            const valueStr = parts[2].replace(/,/g, '');
                            value = parseFloat(valueStr);
                        }
                        
                        if (isNaN(value)) {
                            continue;
                        }
                        
                        // Convert date format to ISO
                        let isoDate;
                        if (dateStr.includes('/')) {
                            const [m, d, y] = dateStr.split('/');
                            isoDate = `${y}-${m.padStart(2,'0')}-${d.padStart(2,'0')}`;
                        } else {
                            isoDate = dateStr;
                        }
                        
                        records.push({ date: isoDate, timestamp, value });
                    }
                    
                    csvData[type] = records;
                    
                    const typeMap = { burn: 'Burn', tx: 'Tx', gas: 'Gas', supply: 'Supply', dailyIssuance: 'DailyIssuance', blob: 'Blob', gasUtil: 'GasUtil' };
                    const statusEl = document.getElementById(`status${typeMap[type]}`);
                    const boxEl = document.getElementById(`drop${typeMap[type]}`);
                    
                    statusEl.textContent = `âœ“ ${records.length} records loaded`;
                    statusEl.className = 'csv-status success';
                    boxEl.classList.add('loaded');
                    
                    updateImportButton();
                    log(`ğŸ“ ${type.toUpperCase()}: Parsed ${records.length} records from CSV`, 'success');
                    
                } catch (err) {
                    console.error(`[${type}] Parse error:`, err);
                    const typeMap = { burn: 'Burn', tx: 'Tx', gas: 'Gas', supply: 'Supply', dailyIssuance: 'DailyIssuance', blob: 'Blob', gasUtil: 'GasUtil' };
                    const statusEl = document.getElementById(`status${typeMap[type]}`);
                    statusEl.textContent = `âœ— Parse error: ${err.message}`;
                    statusEl.className = 'csv-status error';
                    log(`âŒ ${type.toUpperCase()}: CSV parse error - ${err.message}`, 'error');
                }
            };
            reader.readAsText(file);
        }
        
        // Helper function to parse CSV line with proper quote handling
        function parseCSVLine(line) {
            const parts = [];
            let current = '';
            let inQuotes = false;
            
            for (let c of line) {
                if (c === '"') {
                    inQuotes = !inQuotes;
                } else if (c === ',' && !inQuotes) {
                    parts.push(current.trim());
                    current = '';
                } else {
                    current += c;
                }
            }
            parts.push(current.trim());
            return parts;
        }
        
        function updateImportButton() {
            const btn = document.getElementById('importBtn');
            const loaded = Object.values(csvData).filter(v => v !== null).length;
            btn.disabled = loaded === 0;
            btn.textContent = `ğŸ“¥ Import ${loaded}/6 Files to Supabase`;
        }
        
        async function importAllCSV() {
            if (!sb) {
                alert('Please configure Supabase first!');
                return;
            }
            
            const progressEl = document.getElementById('importProgress');
            let totalImported = 0;
            
            try {
                // Import Gas & Burn data (combined table)
                if (csvData.burn || csvData.gas) {
                    progressEl.textContent = 'Importing Gas & Burn data...';
                    
                    // Merge burn and gas data by date
                    const mergedData = new Map();
                    
                    if (csvData.burn) {
                        csvData.burn.forEach(r => {
                            mergedData.set(r.date, { 
                                date: r.date, 
                                eth_burnt: r.value,
                                avg_gas_price_gwei: 0,
                                transaction_count: 0
                            });
                        });
                    }
                    
                    if (csvData.gas) {
                        csvData.gas.forEach(r => {
                            // Convert Wei to Gwei (Etherscan exports in Wei)
                            const gasPriceGwei = r.value > 1e6 ? r.value / 1e9 : r.value;
                            
                            if (mergedData.has(r.date)) {
                                mergedData.get(r.date).avg_gas_price_gwei = gasPriceGwei;
                            } else {
                                mergedData.set(r.date, {
                                    date: r.date,
                                    eth_burnt: 0,
                                    avg_gas_price_gwei: gasPriceGwei,
                                    transaction_count: 0
                                });
                            }
                        });
                    }
                    
                    const gasRecords = Array.from(mergedData.values());
                    
                    const { error: gasError } = await batchUpsert('historical_gas_burn', gasRecords);
                    if (gasError) throw new Error(`Gas/Burn: ${gasError.message}`);
                    
                    totalImported += gasRecords.length;
                }
                
                // Import Transactions
                if (csvData.tx) {
                    progressEl.textContent = 'Importing Transactions...';
                    
                    const txRecords = csvData.tx.map(r => ({
                        date: r.date,
                        timestamp: r.timestamp * 1000,
                        tx_count: Math.round(r.value)
                    }));
                    
                    const { error: txError } = await batchUpsert('historical_transactions', txRecords);
                    if (txError) throw new Error(`Transactions: ${txError.message}`);
                    
                    totalImported += txRecords.length;
                    
                    // Also update gas_burn table with tx counts
                    if (csvData.burn || csvData.gas) {
                        const txMap = new Map(csvData.tx.map(r => [r.date, Math.round(r.value)]));
                        const { data: gasData } = await sb.from('historical_gas_burn')
                            .select('date, eth_burnt, avg_gas_price_gwei')
                            .order('date', { ascending: false })
                            .limit(2000);
                        
                        if (gasData) {
                            const updates = gasData
                                .filter(g => txMap.has(g.date))
                                .map(g => ({
                                    date: g.date,
                                    eth_burnt: g.eth_burnt,
                                    avg_gas_price_gwei: g.avg_gas_price_gwei,
                                    transaction_count: txMap.get(g.date)
                                }));
                            
                            if (updates.length > 0) {
                                await batchUpsert('historical_gas_burn', updates);
                            }
                        }
                    }
                }
                
                // Import Supply data (Total Supply from CSV)
                if (csvData.supply) {
                    progressEl.textContent = 'Importing Supply data...';
                    
                    const sorted = [...csvData.supply].sort((a, b) => new Date(a.date) - new Date(b.date));
                    const supplyRecords = sorted.map(r => ({
                        date: r.date,
                        eth_supply: r.value
                    }));
                    
                    const { error: supplyError } = await batchUpsert('historical_eth_supply', supplyRecords);
                    if (supplyError) log(`  âŒ Supply: ${supplyError.message}`, 'error');
                    
                    totalImported += supplyRecords.length;
                }
                
                // Import Daily Issuance data (from generated CSV)
                if (csvData.dailyIssuance) {
                    progressEl.textContent = 'Importing Daily Issuance data...';
                    
                    const sorted = [...csvData.dailyIssuance].sort((a, b) => new Date(a.date) - new Date(b.date));
                    const issuanceRecords = sorted.map(r => ({
                        date: r.date,
                        daily_issuance: r.value,
                        eth2_staking_cumulative: r.cumulative || null,
                        source: 'csv'
                    }));
                    
                    const { error: issuanceError } = await batchUpsert('historical_daily_issuance', issuanceRecords);
                    if (issuanceError) log(`  âŒ Daily Issuance: ${issuanceError.message}`, 'error');
                    
                    totalImported += issuanceRecords.length;
                }
                
                // Import Blob data (from Dune CSV)
                if (csvData.blob) {
                    progressEl.textContent = 'Importing Blob data...';
                    const blobRecords = csvData.blob;
                    
                    const { error: blobError } = await batchUpsert('historical_blob_data', blobRecords);
                    if (blobError) log(`  âŒ Blob Data: ${blobError.message}`, 'error');
                    
                    totalImported += blobRecords.length;
                }
                
                // Import Gas Utilization data (from Etherscan CSV)
                if (csvData.gasUtil) {
                    progressEl.textContent = 'Importing Gas Utilization data...';
                    const gasUtilRecords = csvData.gasUtil;
                    
                    let updated = 0;
                    for (const record of gasUtilRecords) {
                        const { error } = await sb.from('historical_gas_burn')
                            .update({ gas_utilization: record.gas_utilization, source: 'etherscan_csv' })
                            .eq('date', record.date);
                        if (!error) updated++;
                    }
                    
                    const { data: existingDates } = await sb.from('historical_gas_burn').select('date');
                    const existingSet = new Set(existingDates?.map(d => d.date) || []);
                    
                    const newRecords = gasUtilRecords
                        .filter(r => !existingSet.has(r.date))
                        .map(r => ({
                            date: r.date,
                            gas_utilization: r.gas_utilization,
                            eth_burnt: 0,
                            source: 'etherscan_csv'
                        }));
                    
                    if (newRecords.length > 0) {
                        const { error: insertError } = await batchUpsert('historical_gas_burn', newRecords);
                        if (insertError) log(`  âŒ Gas Util insert: ${insertError.message}`, 'error');
                    }
                    
                    totalImported += gasUtilRecords.length;
                }
                
                progressEl.textContent = `âœ“ Done! Imported ${totalImported} total records`;
                progressEl.style.color = 'var(--success)';
                
                // Refresh data display
                await refreshData();
                
            } catch (err) {
                progressEl.textContent = `âœ— Error: ${err.message}`;
                progressEl.style.color = 'var(--error)';
                log(`âŒ Import failed: ${err.message}`, 'error');
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // AUTO-FILL NEW DATA (Block-based calculation)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        async function autoFillNewData() {
            if (!sb || !ETHERSCAN_API_KEY) {
                alert('Please configure Supabase and Etherscan API key first!');
                return;
            }
            
            log('ğŸ”„ Auto-fill: Starting...', 'info');
            
            try {
                const { data: latestGas } = await sb.from('historical_gas_burn')
                    .select('date')
                    .order('date', { ascending: false })
                    .limit(1);
                
                const { data: latestTx } = await sb.from('historical_transactions')
                    .select('date')
                    .order('date', { ascending: false })
                    .limit(1);
                
                const lastGasDate = latestGas?.[0]?.date ? new Date(latestGas[0].date) : null;
                const lastTxDate = latestTx?.[0]?.date ? new Date(latestTx[0].date) : null;
                
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                
                const missingDates = [];
                if (lastGasDate) {
                    let d = new Date(lastGasDate);
                    d.setDate(d.getDate() + 1);
                    while (d < today) {
                        missingDates.push(new Date(d));
                        d.setDate(d.getDate() + 1);
                    }
                }
                
                if (missingDates.length === 0) {
                    log('âœ… Auto-fill: Data is up to date', 'success');
                    return;
                }
                
                log(`  Filling ${missingDates.length} missing days...`, 'info');
                
                const gasRecords = [];
                const txRecords = [];
                
                for (let i = 0; i < missingDates.length; i++) {
                    const date = missingDates[i];
                    const dateStr = date.toISOString().split('T')[0];
                    
                    const startTime = Math.floor(date.getTime() / 1000);
                    const endTime = startTime + 86400 - 1;
                    
                    const startBlockUrl = `https://api.etherscan.io/api?module=block&action=getblocknobytime&timestamp=${startTime}&closest=after&apikey=${ETHERSCAN_API_KEY}`;
                    const startBlockRes = await fetch(startBlockUrl);
                    const startBlockData = await startBlockRes.json();
                    
                    const endBlockUrl = `https://api.etherscan.io/api?module=block&action=getblocknobytime&timestamp=${endTime}&closest=before&apikey=${ETHERSCAN_API_KEY}`;
                    const endBlockRes = await fetch(endBlockUrl);
                    const endBlockData = await endBlockRes.json();
                    
                    if (startBlockData.status !== '1' || endBlockData.status !== '1') {
                        continue;
                    }
                    
                    const startBlock = parseInt(startBlockData.result);
                    const endBlock = parseInt(endBlockData.result);
                    const blockCount = endBlock - startBlock + 1;
                    
                    const sampleBlocks = [];
                    const sampleSize = Math.min(20, blockCount);
                    const step = Math.floor(blockCount / sampleSize);
                    
                    for (let j = 0; j < sampleSize; j++) {
                        sampleBlocks.push(startBlock + j * step);
                    }
                    
                    let totalBaseFee = 0;
                    let totalGasUsed = 0;
                    let totalTxCount = 0;
                    let validSamples = 0;
                    
                    for (const blockNum of sampleBlocks) {
                        try {
                            const blockUrl = `https://api.etherscan.io/api?module=proxy&action=eth_getBlockByNumber&tag=0x${blockNum.toString(16)}&boolean=false&apikey=${ETHERSCAN_API_KEY}`;
                            const blockRes = await fetch(blockUrl);
                            const blockData = await blockRes.json();
                            
                            if (blockData.result) {
                                const baseFee = parseInt(blockData.result.baseFeePerGas || '0', 16);
                                const gasUsed = parseInt(blockData.result.gasUsed || '0', 16);
                                const txCount = (blockData.result.transactions || []).length;
                                
                                totalBaseFee += baseFee;
                                totalGasUsed += gasUsed;
                                totalTxCount += txCount;
                                validSamples++;
                            }
                        } catch (e) {
                            // Skip failed samples
                        }
                        
                        // Rate limiting
                        await new Promise(r => setTimeout(r, 220));
                    }
                    
                    if (validSamples > 0) {
                        const avgBaseFeeWei = totalBaseFee / validSamples;
                        const avgGasUsed = totalGasUsed / validSamples;
                        const avgTxPerBlock = totalTxCount / validSamples;
                        
                        const dailyGasUsed = avgGasUsed * blockCount;
                        const dailyBurn = (avgBaseFeeWei * dailyGasUsed) / 1e18;
                        const dailyTx = Math.round(avgTxPerBlock * blockCount);
                        const avgGasGwei = avgBaseFeeWei / 1e9;
                        
                        gasRecords.push({
                            date: dateStr,
                            eth_burnt: parseFloat(dailyBurn.toFixed(2)),
                            avg_gas_price_gwei: parseFloat(avgGasGwei.toFixed(2)),
                            transaction_count: dailyTx
                        });
                        
                        txRecords.push({
                            date: dateStr,
                            timestamp: date.getTime(),
                            tx_count: dailyTx
                        });
                    }
                }
                
                if (gasRecords.length > 0) {
                    const { error: gasError } = await batchUpsert('historical_gas_burn', gasRecords);
                    if (gasError) log(`  âŒ Gas save: ${gasError.message}`, 'error');
                }
                
                if (txRecords.length > 0) {
                    const { error: txError } = await batchUpsert('historical_transactions', txRecords);
                    if (txError) log(`  âŒ Tx save: ${txError.message}`, 'error');
                }
                
                await autoFillIssuance(missingDates);
                
                log(`âœ… Auto-fill complete: ${gasRecords.length} days`, 'success');
                await refreshData();
                
            } catch (err) {
                log(`âŒ Auto-fill error: ${err.message}`, 'error');
            }
        }
        
        // Auto-fill missing supply data
        async function autoFillIssuance(dates) {
            if (!dates || dates.length === 0) return;
            
            try {
                const dateStrs = dates.map(d => d.toISOString().split('T')[0]);
                const { data: existingData } = await sb.from('historical_eth_supply')
                    .select('date, eth_supply')
                    .in('date', dateStrs);
                
                const existingDates = new Set(existingData?.map(d => d.date) || []);
                const missingDates = dates.filter(d => !existingDates.has(d.toISOString().split('T')[0]));
                
                if (missingDates.length === 0) return;
                
                const { data: latestSupply } = await sb.from('historical_eth_supply')
                    .select('eth_supply')
                    .order('date', { ascending: false })
                    .limit(1);
                
                // Approximate current supply (slowly increasing/decreasing)
                const baseSupply = latestSupply?.[0]?.eth_supply || 120500000;
                
                const supplyUpdates = missingDates.map((date) => ({
                    date: date.toISOString().split('T')[0],
                    eth_supply: baseSupply  // Use latest known supply as approximation
                }));
                
                if (supplyUpdates.length > 0) {
                    const { error } = await batchUpsert('historical_eth_supply', supplyUpdates);
                    if (error) log(`  âŒ Supply: ${error.message}`, 'error');
                }
                
            } catch (err) {
                log(`  âŒ Supply auto-fill: ${err.message}`, 'error');
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // Data Manager Functions
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function showDataManager() {
            document.getElementById('dataManagerModal').style.display = 'flex';
            document.getElementById('dataManagerLog').style.display = 'none';
            document.getElementById('dataManagerLog').innerHTML = '';
        }
        
        function closeDataManager() {
            document.getElementById('dataManagerModal').style.display = 'none';
        }
        
        function dmLog(msg, type = 'info') {
            const logEl = document.getElementById('dataManagerLog');
            logEl.style.display = 'block';
            const color = type === 'error' ? 'var(--error)' : type === 'success' ? 'var(--success)' : 'var(--text-muted)';
            logEl.innerHTML += `<div style="color:${color}">${new Date().toLocaleTimeString()} - ${msg}</div>`;
            logEl.scrollTop = logEl.scrollHeight;
        }
        
        async function deleteTableData(tableName) {
            if (!confirm(`âš ï¸ Are you sure you want to delete ALL data from ${tableName}?\n\nThis action cannot be undone!`)) {
                return;
            }
            
            dmLog(`Deleting all data from ${tableName}...`);
            
            try {
                const { error, count } = await sb.from(tableName).delete().neq('date', '1900-01-01');
                
                if (error) {
                    dmLog(`âŒ Error: ${error.message}`, 'error');
                    return;
                }
                
                dmLog(`âœ… Deleted all records from ${tableName}`, 'success');
                await refreshData();
            } catch (e) {
                dmLog(`âŒ Error: ${e.message}`, 'error');
            }
        }
        
        async function recollectStaking() {
            if (!confirm('âš ï¸ This will:\n1. Delete ALL staking data\n2. Recollect from Dune (beacon chain)\n\nContinue?')) {
                return;
            }
            
            dmLog('Starting staking data recollection...');
            
            // Step 1: Delete existing data
            dmLog('Step 1/2: Deleting existing staking data...');
            try {
                const { error } = await sb.from('historical_staking').delete().neq('date', '1900-01-01');
                if (error) throw error;
                dmLog('âœ… Deleted existing staking data', 'success');
            } catch (e) {
                dmLog(`âŒ Delete failed: ${e.message}`, 'error');
                return;
            }
            
            // Step 2: Collect from Dune
            dmLog('Step 2/2: Collecting from Dune (query 6400443)...');
            try {
                const DUNE_STAKING_QUERY = 6400443;
                const url = `https://api.dune.com/api/v1/query/${DUNE_STAKING_QUERY}/results?limit=1500`;
                const response = await fetch(url, {
                    headers: { 'X-Dune-API-Key': DUNE_API_KEY }
                });
                
                if (!response.ok) {
                    throw new Error(`Dune API error: ${response.status}`);
                }
                
                const data = await response.json();
                const rows = data?.result?.rows || [];
                
                if (rows.length === 0) {
                    dmLog('âš ï¸ No data returned from Dune', 'error');
                    return;
                }
                
                dmLog(`ğŸ“Š Retrieved ${rows.length} records from Dune`);
                
                // Get APR data from DefiLlama
                const yieldResponse = await fetch('https://yields.llama.fi/chart/747c1d2a-c668-4682-b9f9-296708a3dd90');
                const yieldData = await yieldResponse.json();
                const aprMap = new Map();
                if (yieldData?.data) {
                    for (const point of yieldData.data) {
                        const date = point.timestamp.split('T')[0];
                        aprMap.set(date, point.apy || 3.2);
                    }
                }
                
                // Transform and insert
                const records = rows.map(row => {
                    const date = row.date?.split(' ')[0] || row.date;
                    const totalStakedEth = parseFloat(row.total_staked_eth || row.cumulative_staked_eth || 0);
                    const apr = aprMap.get(date) || 3.2;
                    
                    return {
                        date,
                        total_staked_eth: Math.round(totalStakedEth),
                        total_validators: Math.round(totalStakedEth / 32),
                        avg_apr: parseFloat(apr.toFixed(2)),
                        source: 'dune'
                    };
                }).filter(r => r.total_staked_eth > 0);
                
                // Dedupe
                const seen = new Set();
                const uniqueRecords = records.filter(r => {
                    if (seen.has(r.date)) return false;
                    seen.add(r.date);
                    return true;
                });
                
                dmLog(`ğŸ“¦ Inserting ${uniqueRecords.length} unique records...`);
                
                // Batch insert
                const batchSize = 500;
                for (let i = 0; i < uniqueRecords.length; i += batchSize) {
                    const batch = uniqueRecords.slice(i, i + batchSize);
                    const { error } = await sb.from('historical_staking').upsert(batch, { onConflict: 'date' });
                    if (error) throw error;
                    dmLog(`  Inserted ${Math.min(i + batchSize, uniqueRecords.length)}/${uniqueRecords.length}`);
                }
                
                const latest = uniqueRecords.find(r => r.total_staked_eth > 0);
                dmLog(`âœ… Complete! Latest: ${(latest?.total_staked_eth/1e6).toFixed(2)}M ETH (${latest?.date})`, 'success');
                
                await refreshData();
            } catch (e) {
                dmLog(`âŒ Collection failed: ${e.message}`, 'error');
            }
        }
        
        async function deleteSelectedTable() {
            const tableName = document.getElementById('tableSelect').value;
            if (!tableName) {
                alert('Please select a table first');
                return;
            }
            await deleteTableData(tableName);
        }

        function showConfig() {
            document.getElementById('configSupabaseUrl').value = SUPABASE_URL;
            document.getElementById('configSupabaseKey').value = SUPABASE_ANON_KEY;
            document.getElementById('configEtherscanKey').value = ETHERSCAN_API_KEY;
            document.getElementById('configDuneKey').value = DUNE_API_KEY;
            document.getElementById('configAnthropicKey').value = ANTHROPIC_API_KEY;
            document.getElementById('configCryptoQuantKey').value = CRYPTOQUANT_API_KEY;
            document.getElementById('configModal').classList.add('show');
        }
        
        function closeConfigModal() {
            document.getElementById('configModal').classList.remove('show');
        }
        
        function saveConfig() {
            const url = document.getElementById('configSupabaseUrl').value.trim();
            const key = document.getElementById('configSupabaseKey').value.trim();
            const etherscanKey = document.getElementById('configEtherscanKey').value.trim();
            const duneKey = document.getElementById('configDuneKey').value.trim();
            const anthropicKey = document.getElementById('configAnthropicKey').value.trim();
            const cryptoquantKey = document.getElementById('configCryptoQuantKey').value.trim();
            
            if (!url || !key) {
                alert('Supabase URL and Key are required!');
                return;
            }
            
            localStorage.setItem('ethval_supabase_url', url);
            localStorage.setItem('ethval_supabase_key', key);
            if (etherscanKey) localStorage.setItem('ethval_etherscan_key', etherscanKey);
            if (duneKey) localStorage.setItem('ethval_dune_key', duneKey);
            if (anthropicKey) localStorage.setItem('ethval_anthropic_key', anthropicKey);
            if (cryptoquantKey) localStorage.setItem('cryptoquant_api_key', cryptoquantKey);
            
            location.reload();
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // Cloud Sync - ì•”í˜¸í™”í•˜ì—¬ Supabaseì— ì €ì¥/ë¶ˆëŸ¬ì˜¤ê¸°
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        // AES-GCM ì•”í˜¸í™”ë¥¼ ìœ„í•œ í‚¤ ìƒì„±
        async function deriveKey(password, salt) {
            const encoder = new TextEncoder();
            const keyMaterial = await crypto.subtle.importKey(
                'raw',
                encoder.encode(password),
                'PBKDF2',
                false,
                ['deriveKey']
            );
            return crypto.subtle.deriveKey(
                {
                    name: 'PBKDF2',
                    salt: salt,
                    iterations: 100000,
                    hash: 'SHA-256'
                },
                keyMaterial,
                { name: 'AES-GCM', length: 256 },
                false,
                ['encrypt', 'decrypt']
            );
        }
        
        // ì•”í˜¸í™”
        async function encryptConfig(config, password) {
            const encoder = new TextEncoder();
            const salt = crypto.getRandomValues(new Uint8Array(16));
            const iv = crypto.getRandomValues(new Uint8Array(12));
            const key = await deriveKey(password, salt);
            
            const encrypted = await crypto.subtle.encrypt(
                { name: 'AES-GCM', iv: iv },
                key,
                encoder.encode(JSON.stringify(config))
            );
            
            return {
                encrypted: btoa(String.fromCharCode(...new Uint8Array(encrypted))),
                salt: btoa(String.fromCharCode(...salt)),
                iv: btoa(String.fromCharCode(...iv))
            };
        }
        
        // ë³µí˜¸í™”
        async function decryptConfig(encryptedData, password) {
            const decoder = new TextDecoder();
            const salt = new Uint8Array(atob(encryptedData.salt).split('').map(c => c.charCodeAt(0)));
            const iv = new Uint8Array(atob(encryptedData.iv).split('').map(c => c.charCodeAt(0)));
            const encrypted = new Uint8Array(atob(encryptedData.encrypted).split('').map(c => c.charCodeAt(0)));
            
            const key = await deriveKey(password, salt);
            
            const decrypted = await crypto.subtle.decrypt(
                { name: 'AES-GCM', iv: iv },
                key,
                encrypted
            );
            
            return JSON.parse(decoder.decode(decrypted));
        }
        
        // í´ë¼ìš°ë“œì— ì €ì¥
        async function saveToCloud() {
            const password = document.getElementById('cloudPassword').value;
            if (!password || password.length < 4) {
                alert('íŒ¨ìŠ¤ì›Œë“œë¥¼ 4ì ì´ìƒ ì…ë ¥í•´ì£¼ì„¸ìš”.');
                return;
            }
            
            const url = document.getElementById('configSupabaseUrl').value.trim();
            const key = document.getElementById('configSupabaseKey').value.trim();
            
            if (!url || !key) {
                alert('Supabase URLê³¼ Keyë¥¼ ë¨¼ì € ì…ë ¥í•´ì£¼ì„¸ìš”.');
                return;
            }
            
            const config = {
                supabase_url: url,
                supabase_key: key,
                etherscan_key: document.getElementById('configEtherscanKey').value.trim(),
                dune_key: document.getElementById('configDuneKey').value.trim(),
                anthropic_key: document.getElementById('configAnthropicKey').value.trim(),
                cryptoquant_key: document.getElementById('configCryptoQuantKey').value.trim()
            };
            
            try {
                const { encrypted, salt, iv } = await encryptConfig(config, password);
                
                const response = await fetch(`${url}/rest/v1/admin_config?id=eq.default`, {
                    method: 'GET',
                    headers: {
                        'apikey': key,
                        'Authorization': `Bearer ${key}`
                    }
                });
                
                const existing = await response.json();
                
                const method = existing && existing.length > 0 ? 'PATCH' : 'POST';
                const endpoint = existing && existing.length > 0 
                    ? `${url}/rest/v1/admin_config?id=eq.default`
                    : `${url}/rest/v1/admin_config`;
                
                const saveResponse = await fetch(endpoint, {
                    method: method,
                    headers: {
                        'apikey': key,
                        'Authorization': `Bearer ${key}`,
                        'Content-Type': 'application/json',
                        'Prefer': 'return=minimal'
                    },
                    body: JSON.stringify({
                        id: 'default',
                        encrypted_config: encrypted,
                        salt: salt,
                        iv: iv,
                        updated_at: new Date().toISOString()
                    })
                });
                
                if (saveResponse.ok || saveResponse.status === 201 || saveResponse.status === 204) {
                    alert('âœ… í´ë¼ìš°ë“œì— ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤!\n\në‹¤ë¥¸ ê¸°ê¸°ì—ì„œ ê°™ì€ íŒ¨ìŠ¤ì›Œë“œë¡œ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
                } else {
                    throw new Error(`HTTP ${saveResponse.status}`);
                }
            } catch (e) {
                console.error('Cloud save error:', e);
                alert('âŒ ì €ì¥ ì‹¤íŒ¨: ' + e.message + '\n\nadmin_config í…Œì´ë¸”ì´ ìƒì„±ë˜ì—ˆëŠ”ì§€ í™•ì¸í•´ì£¼ì„¸ìš”.');
            }
        }
        
        // í´ë¼ìš°ë“œì—ì„œ ë¶ˆëŸ¬ì˜¤ê¸°
        async function loadFromCloud() {
            const password = document.getElementById('cloudPassword').value;
            if (!password) {
                alert('íŒ¨ìŠ¤ì›Œë“œë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.');
                return;
            }
            
            // ë¨¼ì € Supabase URL/Keyê°€ ìˆëŠ”ì§€ í™•ì¸ (localStorage ë˜ëŠ” input)
            let url = document.getElementById('configSupabaseUrl').value.trim() || localStorage.getItem('ethval_supabase_url');
            let key = document.getElementById('configSupabaseKey').value.trim() || localStorage.getItem('ethval_supabase_key');
            
            if (!url || !key) {
                alert('Supabase URLê³¼ Keyë¥¼ ë¨¼ì € ì…ë ¥í•´ì£¼ì„¸ìš”.\n\n(ìµœì†Œí•œ ì´ ë‘ ê°’ì€ í•„ìš”í•©ë‹ˆë‹¤)');
                return;
            }
            
            try {
                const response = await fetch(`${url}/rest/v1/admin_config?id=eq.default`, {
                    method: 'GET',
                    headers: {
                        'apikey': key,
                        'Authorization': `Bearer ${key}`
                    }
                });
                
                const data = await response.json();
                
                if (!data || data.length === 0) {
                    alert('âŒ ì €ì¥ëœ ì„¤ì •ì´ ì—†ìŠµë‹ˆë‹¤.');
                    return;
                }
                
                const encryptedData = {
                    encrypted: data[0].encrypted_config,
                    salt: data[0].salt,
                    iv: data[0].iv
                };
                
                const config = await decryptConfig(encryptedData, password);
                
                // í¼ì— ê°’ ì±„ìš°ê¸°
                document.getElementById('configSupabaseUrl').value = config.supabase_url || '';
                document.getElementById('configSupabaseKey').value = config.supabase_key || '';
                document.getElementById('configEtherscanKey').value = config.etherscan_key || '';
                document.getElementById('configDuneKey').value = config.dune_key || '';
                document.getElementById('configAnthropicKey').value = config.anthropic_key || '';
                document.getElementById('configCryptoQuantKey').value = config.cryptoquant_key || '';
                
                alert('âœ… ì„¤ì •ì„ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤!\n\n"Save & Reload"ë¥¼ ëˆŒëŸ¬ ì ìš©í•˜ì„¸ìš”.');
            } catch (e) {
                console.error('Cloud load error:', e);
                if (e.message.includes('decrypt')) {
                    alert('âŒ íŒ¨ìŠ¤ì›Œë“œê°€ í‹€ë ¸ìŠµë‹ˆë‹¤.');
                } else {
                    alert('âŒ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨: ' + e.message);
                }
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // DATASETS - Phaseë³„ë¡œ ì •ë ¬ (1 â†’ 2 â†’ 3 â†’ 4)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const DATASETS = {
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // ğŸ”µ PHASE 1: External APIs (Independent - No Dependencies)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            // --- ğŸ”¶ Dune Analytics (Price Data) ---
            eth_price: { name: 'ETH Price', icon: 'ğŸ’°', table: 'historical_eth_price', valueField: 'close', format: 'price', expectedDays: 1095, phase: 1, source: 'ğŸ”¶ Dune' },
            eth_btc: { name: 'ETH/BTC Ratio', icon: 'â‚¿', table: 'historical_eth_btc', valueField: 'ratio', format: 'ratio', expectedDays: 1095, phase: 1, source: 'ğŸ”¶ Dune' },
            
            // --- ğŸŸ¡ Binance ---
            funding_rate: { name: 'Funding Rate', icon: 'ğŸ“Š', table: 'historical_funding_rate', valueField: 'funding_rate', format: 'percent8', expectedDays: 1095, phase: 1, source: 'ğŸŸ  CryptoQuant' },
            
            // --- ğŸ¦™ DefiLlama ---
            ethereum_tvl: { name: 'Ethereum TVL', icon: 'ğŸ¦', table: 'historical_ethereum_tvl', valueField: 'tvl', format: 'tvl', expectedDays: 1095, phase: 1, source: 'ğŸ¦™ DefiLlama' },
            staking_data: { name: 'Staking Data', icon: 'ğŸ¥©', table: 'historical_staking', valueField: 'total_staked_eth', format: 'eth', expectedDays: 1095, phase: 1, source: 'ğŸ”® Dune' },
            l2_tvl: { name: 'L2 TVL', icon: 'ğŸ”—', table: 'historical_l2_tvl', valueField: 'tvl', format: 'tvl', aggregate: true, expectedDays: 6000, phase: 1, source: 'ğŸ¦™ DefiLlama' },
            protocol_fees: { name: 'Protocol Fees', icon: 'ğŸ“ˆ', table: 'historical_protocol_fees', valueField: 'fees', format: 'fees', expectedDays: 1095, phase: 1, source: 'ğŸ¦™ DefiLlama' },
            dex_volume: { name: 'L1 DEX Volume', icon: 'ğŸ’±', table: 'historical_dex_volume', valueField: 'volume', format: 'tvl', expectedDays: 1095, phase: 1, source: 'ğŸ¦™ DefiLlama' },
            stablecoins: { name: 'Stablecoins (All)', icon: 'ğŸ’µ', table: 'historical_stablecoins', valueField: 'total_mcap', format: 'tvl', expectedDays: 1095, phase: 1, source: 'ğŸ¦™ DefiLlama' },
            stablecoins_eth: { name: 'Stablecoins (ETH)', icon: 'ğŸ”·', table: 'historical_stablecoins_eth', valueField: 'total_mcap', format: 'tvl', expectedDays: 1095, phase: 1, source: 'ğŸ¦™ DefiLlama' },
            lending_tvl: { name: 'Lending TVL', icon: 'ğŸ¦', table: 'historical_lending_tvl', valueField: 'total_tvl', format: 'tvl', expectedDays: 1095, phase: 1, source: 'ğŸ¦™ DefiLlama' },
            staking_apr: { name: 'Staking APR', icon: 'ğŸ’¹', table: 'historical_staking_apr', valueField: 'lido_apr', format: 'percent', expectedDays: 1095, phase: 1, source: 'ğŸ¦™ DefiLlama' },
            
            // --- ğŸ¦ CoinGecko ---
            eth_dominance: { name: 'ETH Dominance', icon: 'ğŸ‘‘', table: 'historical_eth_dominance', valueField: 'eth_dominance', format: 'percent', expectedDays: 365, phase: 1, source: 'ğŸ¦ CoinGecko' },
            
            // --- ğŸ”¶ Dune Analytics ---
            blob_data: { name: 'Blob Data', icon: 'ğŸ«§', table: 'historical_blob_data', valueField: 'blob_count', format: 'number', expectedDays: 636, phase: 1, source: 'ğŸ”¶ Dune' },
            l2_native_transfer: { name: 'L2 ETH Transfer', icon: 'ğŸ’¸', table: 'historical_l2_total_volume', valueField: 'native_volume_usd', format: 'usd', aggregate: true, expectedDays: 3000, phase: 1, source: 'ğŸ”¶ Dune', description: 'ETH transfers on L2s (excludes Mantle MNT). For Settlement Layer.' },
            l1_total_volume: { name: 'L1 Total Volume', icon: 'ğŸ“Š', table: 'historical_l1_total_volume', valueField: 'total_volume_usd', format: 'usd', expectedDays: 1095, phase: 1, source: 'ğŸ”¶ Dune', description: 'Total on-chain volume (ETH + all ERC-20 tokens)' },
            l1_eth_transfer: { name: 'L1 ETH Transfer', icon: 'ğŸ’¸', table: 'historical_l1_total_volume', valueField: 'eth_volume_usd', format: 'usd', expectedDays: 1095, phase: 1, source: 'ğŸ”¶ Dune', description: 'Native ETH transfers only. Now from L1 Total Volume table.' },
            l2_total_volume: { name: 'L2 Total Volume', icon: 'ğŸ“ˆ', table: 'historical_l2_total_volume', valueField: 'total_volume_usd', format: 'usd', aggregate: true, expectedDays: 3000, phase: 1, source: 'ğŸ”¶ Dune', description: 'Total on-chain volume (Native + all tokens) across 8 L2s' },
            bridge_volume: { name: 'Bridge ETH Volume', icon: 'ğŸŒ‰', table: 'historical_bridge_volume', valueField: 'bridge_volume_eth', format: 'eth', aggregate: true, expectedDays: 3000, phase: 1, source: 'ğŸ”¶ Dune' },
            l2_dex_volume: { name: 'L2 DEX Volume', icon: 'ğŸ”„', table: 'historical_l2_dex_volume', valueField: 'dex_volume_usd', format: 'usd', aggregate: true, expectedDays: 3000, phase: 1, source: 'ğŸ”¶ Dune', description: 'Daily DEX trading volume on L2s' },
            bridge_total_volume: { name: 'Bridge Total Volume', icon: 'ğŸŒ', table: 'historical_bridge_total_volume', valueField: 'bridge_volume_usd', format: 'usd', aggregate: false, expectedDays: 1460, phase: 1, source: 'ğŸ”¶ Dune', description: 'All assets bridged to L2s (ETH + ERC-20)' },
            whale_tx: { name: 'Whale TX', icon: 'ğŸ‹', table: 'historical_whale_tx', valueField: 'whale_tx_count', format: 'number', expectedDays: 1095, phase: 1, source: 'ğŸ”¶ Dune' },
            mvrv_ratio: { name: 'MVRV Ratio', icon: 'ğŸ“Š', table: 'historical_mvrv', valueField: 'mvrv_ratio', format: 'ratio', expectedDays: 2878, phase: 1, source: 'ğŸ”¶ Dune' },
            stablecoin_volume: { name: 'Stablecoin Vol', icon: 'ğŸ’µ', table: 'historical_stablecoin_volume', valueField: 'daily_volume', format: 'tvl', expectedDays: 1095, phase: 1, source: 'ğŸ”¶ Dune' },
            new_addresses: { name: 'New Addresses', icon: 'ğŸ†•', table: 'historical_new_addresses', valueField: 'new_addresses', format: 'number', expectedDays: 1095, phase: 1, source: 'ğŸ”¶ Dune' },
            gas_price: { name: 'Gas Price', icon: 'â›½', table: 'historical_gas_burn', valueField: 'avg_gas_price_gwei', format: 'gwei', expectedDays: 1095, phase: 1, source: 'ğŸ”¶ Dune' },
            
            // --- ğŸ¥§ growthepie ---
            l2_transactions: { name: 'L2 Transactions', icon: 'ğŸ”—', table: 'historical_l2_transactions', valueField: 'tx_count', format: 'number', aggregate: true, expectedDays: 3000, phase: 1, source: 'ğŸ¥§ growthepie' },
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // ğŸŸ¡ PHASE 2: First-order Calculations (Depends on Phase 1)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            volatility: { name: 'Volatility', icon: 'ğŸ“‰', table: 'historical_volatility', valueField: 'volatility_30d', format: 'percent', expectedDays: 1065, phase: 2, source: 'ğŸ“Š Calculated', depends: ['eth_price'] },
            transactions: { name: 'L1 Transactions', icon: 'ğŸ“', table: 'historical_transactions', valueField: 'tx_count', format: 'number', expectedDays: 1095, phase: 2, source: 'ğŸ¥§ growthepie' },
            l2_addresses: { name: 'L2 Addresses', icon: 'ğŸ‘¤', table: 'historical_l2_addresses', valueField: 'active_addresses', format: 'number', aggregate: true, expectedDays: 3000, phase: 2, source: 'ğŸ”¶ Dune' },
            exchange_reserve: { name: 'Exchange Reserve', icon: 'ğŸ›ï¸', table: 'historical_exchange_reserve', valueField: 'reserve_eth', format: 'eth', expectedDays: 1095, phase: 2, source: 'ğŸŸ  CryptoQuant' },
            open_interest: { name: 'Open Interest', icon: 'ğŸ“ˆ', table: 'historical_open_interest', valueField: 'open_interest', format: 'tvl', expectedDays: 1095, phase: 2, source: 'ğŸŸ  CryptoQuant' },
            eth_supply: { name: 'ETH Supply', icon: 'ğŸ’', table: 'historical_eth_supply', valueField: 'eth_supply', format: 'eth', expectedDays: 1095, phase: 2, source: 'ğŸ“„ CSV Required' },
            daily_issuance: { name: 'Daily Issuance', icon: 'ğŸª™', table: 'historical_daily_issuance', valueField: 'daily_issuance', format: 'eth', expectedDays: 30, phase: 2, source: 'ğŸ“Š Calculated' },
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // ğŸŸ  PHASE 3: Second-order Calculations (Depends on Phase 2)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            nvt: { name: 'NVT Ratio', icon: 'ğŸ“', table: 'historical_nvt', valueField: 'nvt_ratio', format: 'number', expectedDays: 1095, phase: 3, source: 'ğŸ”¶ Dune', depends: ['eth_price', 'transactions'] },
            active_addresses: { name: 'Active Addresses', icon: 'ğŸ‘¥', table: 'historical_active_addresses', valueField: 'active_addresses', format: 'number', expectedDays: 1095, phase: 3, source: 'ğŸ”¶ Dune' },
            gas_burn: { name: 'Gas & Burn', icon: 'ğŸ”¥', table: 'historical_gas_burn', valueField: 'eth_burnt', format: 'eth', expectedDays: 1095, phase: 3, source: 'ğŸ”¶ Dune' },
            fear_greed: { name: 'Fear & Greed', icon: 'ğŸ˜±', table: 'historical_fear_greed', valueField: 'value', format: 'index', expectedDays: 1095, phase: 3, source: 'ğŸ“Š alternative.me' },
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // âšª PHASE 4: Final Aggregations (Depends on Phase 3)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            global_mcap: { name: 'Global Mcap', icon: 'ğŸŒ', table: 'historical_global_mcap', valueField: 'total_mcap', format: 'tvl', expectedDays: 365, phase: 4, source: 'ğŸ¦ CoinGecko' },
            eth_in_defi: { name: 'ETH in DeFi', icon: 'ğŸ”’', table: 'historical_eth_in_defi', valueField: 'eth_locked', format: 'eth', expectedDays: 1095, phase: 4, source: 'ğŸ“Š Calculated', depends: ['ethereum_tvl', 'eth_price'] },
            protocol_tvl: { name: 'Protocol TVL', icon: 'ğŸ“Š', table: 'historical_protocol_tvl', valueField: 'tvl', format: 'tvl', aggregate: true, expectedDays: 5000, phase: 4, source: 'ğŸ¦™ DefiLlama' },
            dex_by_protocol: { name: 'DEX by Protocol', icon: 'ğŸ’±', table: 'historical_dex_by_protocol', valueField: 'volume', format: 'tvl', aggregate: true, expectedDays: 3000, phase: 4, source: 'ğŸ¦™ DefiLlama' },
            network_stats: { name: 'Network Stats', icon: 'â›“ï¸', table: 'historical_network_stats', valueField: 'block_count', format: 'number', expectedDays: 1, phase: 4, source: 'ğŸ”— Etherscan' }
        };

        function formatValue(val, format) {
            if (val === null || val === undefined) return '-';
            switch(format) {
                case 'price': return '$' + parseFloat(val).toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});
                case 'tvl': return '$' + (val >= 1e9 ? (val/1e9).toFixed(2) + 'B' : val >= 1e6 ? (val/1e6).toFixed(2) + 'M' : val.toLocaleString());
                case 'eth': return parseFloat(val).toLocaleString(undefined, {maximumFractionDigits: 0}) + ' ETH';
                case 'percent': return parseFloat(val).toFixed(2) + '%';
                case 'percent8': return (parseFloat(val) * 100).toFixed(4) + '%';
                case 'ratio': return parseFloat(val).toFixed(6);
                case 'index': return Math.round(val);
                case 'number': return Math.round(val).toLocaleString();
                case 'fees': return '$' + parseFloat(val).toLocaleString(undefined, {maximumFractionDigits: 0});
                case 'gwei': return parseFloat(val).toFixed(2) + ' Gwei';
                default: return val;
            }
        }

        const DEBUG = false; // trueë¡œ ë³€ê²½í•˜ë©´ ìƒì„¸ ë¡œê·¸ í‘œì‹œ
        let logBuffer = []; // ì„±ê³µ ë¡œê·¸ ë²„í¼
        
        function log(msg, type = '', debug = false) {
            if (debug && !DEBUG) return;
            const el = document.getElementById('log');
            
            // ì—ëŸ¬/ê²½ê³ ëŠ” ì¦‰ì‹œ í‘œì‹œ, ì„±ê³µ/infoëŠ” ë²„í¼ë§
            if (type === 'error' || type === 'warn') {
                el.innerHTML += `<span class="${type}">[${new Date().toLocaleTimeString()}] ${msg}</span>\n`;
            } else if (type === 'success') {
                // ì„±ê³µì€ ê°„ë‹¨íˆ í•œ ì¤„ë¡œ
                el.innerHTML += `<span class="success">${msg}</span>\n`;
            } else {
                el.innerHTML += `<span class="${type}">${msg}</span>\n`;
            }
            el.scrollTop = el.scrollHeight;
        }
        
        // ìš”ì•½ ë¡œê·¸ (ìˆ˜ì§‘ ì™„ë£Œ í›„)
        function logSummary(results) {
            const el = document.getElementById('log');
            const success = results.filter(r => r.count > 0).length;
            const failed = results.filter(r => r.count === 0 || r.error).length;
            el.innerHTML += `\n<span class="info">â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</span>\n`;
            el.innerHTML += `<span class="${failed > 0 ? 'warn' : 'success'}">ğŸ“Š ì™„ë£Œ: ${success} ì„±ê³µ, ${failed} ì‹¤íŒ¨</span>\n`;
            el.scrollTop = el.scrollHeight;
        }
        
        // CSV ì„¹ì…˜ í† ê¸€
        function toggleCSVSection() {
            const section = document.getElementById('csvSection');
            const toggle = document.getElementById('csvToggle');
            if (section.style.display === 'none') {
                section.style.display = 'block';
                toggle.textContent = 'â–²';
            } else {
                section.style.display = 'none';
                toggle.textContent = 'â–¼';
            }
        }

        async function fetchJSON(url, retries = 2) {
            for (let i = 0; i <= retries; i++) {
                try {
                    const controller = new AbortController();
                    const timeout = setTimeout(() => controller.abort(), 30000);
                    
                    const res = await fetch(url, { signal: controller.signal });
                    clearTimeout(timeout);
                    
                    if (!res.ok) { 
                        if (i === retries) log(`  âŒ HTTP ${res.status}: ${url.split('?')[0]}`, 'error');
                        continue;
                    }
                    return await res.json();
                } catch (e) { 
                    if (i < retries) {
                        await new Promise(r => setTimeout(r, 1000));
                        continue;
                    }
                    log(`  âŒ ${e.message}`, 'error'); 
                    return null; 
                }
            }
            return null;
        }

        // Dune API ê³µí†µ í—¬í¼: stale ì²´í¬ ë° ìë™ ì¬ì‹¤í–‰
        async function fetchDuneWithRefresh(queryId, dateField = 'date', maxStaleDays = 2) {
            if (!DUNE_API_KEY) {
                log('  âŒ No Dune API key', 'error');
                return [];
            }
            
            try {
                // 1. ìºì‹œëœ ê²°ê³¼ í™•ì¸
                const cachedResponse = await fetch(`https://api.dune.com/api/v1/query/${queryId}/results?limit=10`, {
                    headers: { 'X-Dune-API-Key': DUNE_API_KEY }
                });
                
                let needsRefresh = false;
                if (cachedResponse.ok) {
                    const cachedData = await cachedResponse.json();
                    const rows = cachedData.result?.rows || [];
                    if (rows.length > 0) {
                        const dateVal = rows[0][dateField] || rows[0].block_date || rows[0].day || '';
                        const latestDateStr = String(dateVal).split('T')[0].split(' ')[0];
                        const daysDiff = Math.floor((Date.now() - new Date(latestDateStr).getTime()) / (24*60*60*1000));
                        
                        if (daysDiff > maxStaleDays) {
                            needsRefresh = true;
                            log(`  âš ï¸ Data stale: ${latestDateStr} (${daysDiff}d ago), refreshing...`, 'warn');
                        } else {
                            log(`  ğŸ“… Latest: ${latestDateStr} (${daysDiff}d ago) âœ“`);
                        }
                    } else {
                        needsRefresh = true;
                    }
                } else {
                    needsRefresh = true;
                }
                
                // 2. í•„ìš”ì‹œ ì¿¼ë¦¬ ìƒˆë¡œ ì‹¤í–‰
                if (needsRefresh) {
                    log('  ğŸ”„ Executing fresh query...', 'info');
                    const execResponse = await fetch(`https://api.dune.com/api/v1/query/${queryId}/execute`, {
                        method: 'POST',
                        headers: { 
                            'X-Dune-API-Key': DUNE_API_KEY,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ performance: 'medium' })
                    });
                    
                    if (execResponse.ok) {
                        const execData = await execResponse.json();
                        const executionId = execData.execution_id;
                        log(`  â³ Execution: ${executionId}`, 'info');
                        
                        // Poll (max 2 min)
                        for (let i = 0; i < 24; i++) {
                            await new Promise(r => setTimeout(r, 5000));
                            const statusResponse = await fetch(`https://api.dune.com/api/v1/execution/${executionId}/status`, {
                                headers: { 'X-Dune-API-Key': DUNE_API_KEY }
                            });
                            if (!statusResponse.ok) continue;
                            
                            const statusData = await statusResponse.json();
                            if (statusData.state === 'QUERY_STATE_COMPLETED') {
                                log(`  âœ… Query completed`, 'success');
                                break;
                            } else if (statusData.state === 'QUERY_STATE_FAILED') {
                                log(`  âŒ Query failed`, 'error');
                                return [];
                            }
                        }
                    }
                }
                
                // 3. ì „ì²´ ê²°ê³¼ ê°€ì ¸ì˜¤ê¸°
                let allRows = [];
                let offset = 0;
                const pageSize = 1000;
                
                while (offset < 10000) {
                    const response = await fetch(`https://api.dune.com/api/v1/query/${queryId}/results?limit=${pageSize}&offset=${offset}`, {
                        headers: { 'X-Dune-API-Key': DUNE_API_KEY }
                    });
                    if (!response.ok) break;
                    
                    const data = await response.json();
                    const rows = data.result?.rows || [];
                    if (rows.length === 0) break;
                    
                    allRows = allRows.concat(rows);
                    if (rows.length < pageSize) break;
                    offset += pageSize;
                    await new Promise(r => setTimeout(r, 200));
                }
                
                return allRows;
                
            } catch (e) {
                log(`  âŒ Dune error: ${e.message}`, 'error');
                return [];
            }
        }

        let dataStatus = {};
        let lastCollectResult = {}; // ë§ˆì§€ë§‰ ìˆ˜ì§‘ ê²°ê³¼ ì¶”ì 

        async function loadDataStatus() {
            log('Loading status...', 'info');
            
            // Parallel fetch all datasets
            const entries = Object.entries(DATASETS);
            const results = await Promise.all(entries.map(async ([key, ds]) => {
                try {
                    const [countRes, latestRes, oldestRes] = await Promise.all([
                        sb.from(ds.table).select('*', { count: 'exact', head: true }),
                        sb.from(ds.table).select('*').order('date', { ascending: false }).limit(1),
                        sb.from(ds.table).select('date').order('date', { ascending: true }).limit(1)
                    ]);
                    
                    if (countRes.error) {
                        return { key, status: { count: 0, latest: null, oldest: null, value: null }, error: countRes.error.message };
                    }
                    
                    let value = latestRes.data?.[0]?.[ds.valueField];
                    
                    // For aggregate tables, sum all records from the latest date
                    if (ds.aggregate && latestRes.data?.[0]?.date) {
                        const latestDate = latestRes.data[0].date;
                        const { data: sumData } = await sb
                            .from(ds.table)
                            .select(ds.valueField)
                            .eq('date', latestDate);
                        
                        if (sumData && sumData.length > 0) {
                            value = sumData.reduce((sum, row) => sum + (parseFloat(row[ds.valueField]) || 0), 0);
                        }
                    }
                    
                    return {
                        key,
                        status: {
                            count: countRes.count || 0,
                            latest: latestRes.data?.[0]?.date,
                            oldest: oldestRes.data?.[0]?.date,
                            value: value
                        }
                    };
                } catch (e) {
                    return { key, status: { count: 0, latest: null, oldest: null, value: null }, error: e.message };
                }
            }));
            
            // Process results
            let ok = 0, partial = 0, failed = 0, stale = 0, totalRecords = 0;
            
            // 3ì¼ ì „ ë‚ ì§œ ê³„ì‚° (ë¡œì»¬ ì‹œê°„ ê¸°ì¤€) - 2ì¼ ì§€ì—°ê¹Œì§€ëŠ” OK
            const threeDaysAgo = new Date();
            threeDaysAgo.setDate(threeDaysAgo.getDate() - 3);
            const threeDaysAgoStr = threeDaysAgo.getFullYear() + '-' + 
                String(threeDaysAgo.getMonth() + 1).padStart(2, '0') + '-' + 
                String(threeDaysAgo.getDate()).padStart(2, '0');
            
            for (const result of results) {
                const ds = DATASETS[result.key];
                if (result.error) {
                    log(`  âš ï¸ ${ds.table}: ${result.error}`, 'warn');
                    failed++;
                }
                dataStatus[result.key] = result.status;
                totalRecords += result.status.count || 0;
                
                const expected = ds.expectedDays || 1095;
                const coverage = (result.status.count || 0) / expected;
                if (coverage >= 0.9) ok++; else if (coverage >= 0.3) partial++; else failed++;
                
                // Stale ì²´í¬ (ë§ˆì§€ë§‰ ë°ì´í„°ê°€ 3ì¼ ì „ ì´í•˜ = 2ì¼ ë„˜ê²Œ ì§€ì—°)
                if (result.status.latest && result.status.latest <= threeDaysAgoStr) {
                    stale++;
                }
            }
            
            document.getElementById('stats-total').textContent = Object.keys(DATASETS).length;
            document.getElementById('statOk').textContent = ok;
            document.getElementById('statPartial').textContent = partial;
            document.getElementById('statFailed').textContent = failed;
            document.getElementById('statStale').textContent = stale;
            document.getElementById('statRecords').textContent = totalRecords.toLocaleString();
            document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
            renderTable();
            log(`Loaded: ${ok} OK, ${partial} Partial, ${failed} Failed, ${stale} Stale`, 'success');
        }

        function renderTable() {
            const tbody = document.getElementById('dataTable');
            tbody.innerHTML = '';
            let idx = 1;
            let currentPhase = 0;
            
            const phaseNames = {
                1: 'ğŸ”µ Phase 1: External APIs (Independent)',
                2: 'ğŸŸ¡ Phase 2: First-order Calculations',
                3: 'ğŸŸ  Phase 3: Second-order Calculations',
                4: 'âšª Phase 4: Final Aggregations'
            };
            
            const phaseDescriptions = {
                1: 'Binance, DefiLlama, CoinGecko, Dune, growthepie',
                2: 'Depends on Phase 1 data',
                3: 'Depends on Phase 2 data',
                4: 'Final computations'
            };
            
            // ì˜¤ëŠ˜ ë‚ ì§œ ê³„ì‚° (ë¡œì»¬ ì‹œê°„ ê¸°ì¤€)
            const today = new Date();
            const todayStr = today.getFullYear() + '-' + 
                String(today.getMonth() + 1).padStart(2, '0') + '-' + 
                String(today.getDate()).padStart(2, '0');
            
            const twoDaysAgo = new Date(today);
            twoDaysAgo.setDate(twoDaysAgo.getDate() - 2);
            const twoDaysAgoStr = twoDaysAgo.getFullYear() + '-' + 
                String(twoDaysAgo.getMonth() + 1).padStart(2, '0') + '-' + 
                String(twoDaysAgo.getDate()).padStart(2, '0');
            
            const threeDaysAgo = new Date(today);
            threeDaysAgo.setDate(threeDaysAgo.getDate() - 3);
            const threeDaysAgoStr = threeDaysAgo.getFullYear() + '-' + 
                String(threeDaysAgo.getMonth() + 1).padStart(2, '0') + '-' + 
                String(threeDaysAgo.getDate()).padStart(2, '0');
            
            // Phaseë³„ ë°ì´í„°ì…‹ ì¹´ìš´íŠ¸
            const phaseCounts = {};
            for (const [key, ds] of Object.entries(DATASETS)) {
                phaseCounts[ds.phase] = (phaseCounts[ds.phase] || 0) + 1;
            }
            
            for (const [key, ds] of Object.entries(DATASETS)) {
                // Phase í—¤ë” ì¶”ê°€
                if (ds.phase && ds.phase !== currentPhase) {
                    currentPhase = ds.phase;
                    const headerRow = document.createElement('tr');
                    headerRow.className = 'phase-header';
                    headerRow.innerHTML = `
                        <td colspan="11" style="background:linear-gradient(90deg, var(--surface) 0%, transparent 100%);padding:8px 10px;border-top:2px solid var(--primary);border-bottom:1px solid var(--border);">
                            <div style="display:flex;justify-content:space-between;align-items:center;">
                                <div>
                                    <span style="font-weight:600;font-size:12px;">${phaseNames[currentPhase] || 'Other'}</span>
                                    <span style="font-size:10px;color:var(--text-muted);margin-left:8px;">${phaseDescriptions[currentPhase] || ''}</span>
                                    <span style="font-size:10px;color:var(--text-muted);margin-left:6px;">(${phaseCounts[currentPhase]})</span>
                                </div>
                                <button class="btn btn-sm" style="font-size:10px;padding:3px 8px;" onclick="collectPhase(${currentPhase})">ğŸ“¥ Phase ${currentPhase}</button>
                            </div>
                        </td>`;
                    tbody.appendChild(headerRow);
                }
                
                const s = dataStatus[key] || { count: 0 };
                const expected = ds.expectedDays || 1095;
                const coverage = Math.min(100, Math.round((s.count / expected) * 100));
                let statusClass = 'ok', statusText = 'OK';
                if (coverage < 30) { statusClass = 'fail'; statusText = 'Missing'; }
                else if (coverage < 90) { statusClass = 'warn'; statusText = 'Partial'; }
                
                // ë§ˆì§€ë§‰ ë°ì´í„°ê°€ ì˜¤ë˜ëëŠ”ì§€ í™•ì¸ (3ì¼ ì „ ì´í•˜ë©´ stale = 2ì¼ ë„˜ê²Œ ì§€ì—°)
                const isStale = s.latest && s.latest <= threeDaysAgoStr;
                const isFresh = s.latest && (s.latest >= twoDaysAgoStr);
                const dateStyle = isStale ? 'color:var(--error);font-weight:600' : isFresh ? 'color:var(--success)' : '';
                const staleIcon = isStale ? ' âš ï¸' : isFresh ? '' : '';
                
                // Stale ì´ìœ  ì¶”ì •
                let staleReason = '';
                if (isStale) {
                    if (ds.source?.includes('Dune')) {
                        staleReason = '<span class="stale-reason" title="Dune query cache expired - run Collect to refresh">(Dune cache)</span>';
                    } else if (ds.source?.includes('CSV')) {
                        staleReason = '<span class="stale-reason" title="CSV upload required">(CSV needed)</span>';
                    } else if (ds.source?.includes('Calculated')) {
                        staleReason = '<span class="stale-reason" title="Depends on other data">(depends)</span>';
                    } else if (ds.source?.includes('CoinGecko')) {
                        staleReason = '<span class="stale-reason" title="CoinGecko API rate limit">(rate limit)</span>';
                    } else {
                        staleReason = '<span class="stale-reason" title="API delay or incomplete data">(API delay)</span>';
                    }
                }
                
                // Format date range
                const dateRange = s.oldest && s.latest 
                    ? `${s.oldest.slice(5)} â†’ <span style="${dateStyle}">${s.latest.slice(5)}${staleIcon}</span>${staleReason}` 
                    : (s.latest ? `<span style="${dateStyle}">${s.latest.slice(5)}${staleIcon}</span>${staleReason}` : '-');
                
                // Depends í‘œì‹œ
                const dependsText = ds.depends?.length > 0 
                    ? `<span style="color:var(--warning);font-size:9px;margin-left:3px" title="Depends on: ${ds.depends.join(', ')}">âš¡</span>` 
                    : '';
                
                // ë§ˆì§€ë§‰ ìˆ˜ì§‘ ê²°ê³¼ í‘œì‹œ
                const lastResult = lastCollectResult[key];
                let collectStatus = '';
                if (lastResult) {
                    if (lastResult.error) {
                        collectStatus = `<span style="color:var(--error);font-size:9px" title="${lastResult.error}">âŒ</span>`;
                    } else if (lastResult.count === 0) {
                        collectStatus = `<span style="color:var(--error);font-size:9px">âŒ</span>`;
                    } else if (lastResult.ratio < 0.1) {
                        collectStatus = `<span style="color:var(--warning);font-size:9px" title="Only ${(lastResult.ratio*100).toFixed(1)}%">âš ï¸</span>`;
                    } else {
                        collectStatus = `<span style="color:var(--success);font-size:9px">âœ“</span>`;
                    }
                }
                
                const row = document.createElement('tr');
                if (isStale) row.style.background = 'rgba(239, 68, 68, 0.06)';
                
                // ì†ŒìŠ¤ë³„ ìƒ‰ìƒ ìŠ¤íƒ€ì¼
                let sourceStyle = 'font-size:10px;';
                if (ds.source?.includes('Dune')) sourceStyle += 'color:#f97316;';
                else if (ds.source?.includes('Binance')) sourceStyle += 'color:#f0b90b;';
                else if (ds.source?.includes('DefiLlama')) sourceStyle += 'color:#8b5cf6;';
                else if (ds.source?.includes('CoinGecko')) sourceStyle += 'color:#22c55e;';
                else if (ds.source?.includes('growthepie')) sourceStyle += 'color:#ec4899;';
                else if (ds.source?.includes('Calculated')) sourceStyle += 'color:var(--text-muted);';
                else if (ds.source?.includes('Estimated')) sourceStyle += 'color:var(--warning);';
                else if (ds.source?.includes('CSV')) sourceStyle += 'color:#06b6d4;';
                
                const collectBtn = ds.noCollect 
                    ? ``
                    : `<button class="action-btn" onclick="collectOne('${key}')" title="Collect ${ds.name}">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M7 10l5 5 5-5M12 15V3"/></svg>
                        collect
                       </button>`;
                
                const previewBtn = `<button class="action-btn" onclick="previewData('${key}')" title="Preview recent 10 records">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>
                    view
                </button>`;
                
                row.innerHTML = `
                    <td class="mono" style="width:24px;text-align:center;color:var(--text-muted);font-size:10px;">${idx}</td>
                    <td style="white-space:nowrap;font-size:12px;">${ds.icon} ${ds.name}${dependsText}</td>
                    <td style="${sourceStyle}">${ds.source?.replace(/^[ğŸŸ¡ğŸ¦™ğŸ¦ğŸ”¶ğŸ¥§ğŸ“Šâš ï¸ğŸ“„ğŸ”—]\s*/, '') || '-'}</td>
                    <td><span class="table-name">${ds.table}</span></td>
                    <td class="mono" style="text-align:right;font-size:11px;">${s.count?.toLocaleString() || 0}</td>
                    <td class="mono" style="font-size:9px;">${dateRange}</td>
                    <td class="mono" style="font-size:10px;">${formatValue(s.value, ds.format)}</td>
                    <td style="width:80px;">
                        <div class="progress"><div class="progress-fill" style="width:${coverage}%;background:${coverage>=90?'var(--success)':coverage>=30?'var(--warning)':'var(--error)'}"></div></div>
                        <span class="mono" style="font-size:8px;color:var(--text-muted);">${coverage}%</span>
                    </td>
                    <td style="text-align:center;"><span class="status ${statusClass}">${statusText}</span>${collectStatus ? ' '+collectStatus : ''}</td>
                    <td><div class="action-btns">${previewBtn}${collectBtn}</div></td>`;
                tbody.appendChild(row);
                idx++;
            }
        }
        
        // ë°ì´í„° ë¯¸ë¦¬ë³´ê¸° ëª¨ë‹¬
        async function previewData(key) {
            const ds = DATASETS[key];
            if (!ds) return;
            
            // ëª¨ë‹¬ ìƒì„± ë˜ëŠ” ì—…ë°ì´íŠ¸
            let modal = document.getElementById('preview-modal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'preview-modal';
                modal.className = 'modal';
                modal.innerHTML = `
                    <div class="modal-content" style="max-width:95vw;width:auto;max-height:85vh;overflow:auto;">
                        <div class="modal-header">
                            <span id="preview-title">Data Preview</span>
                            <button class="btn btn-sm" onclick="document.getElementById('preview-modal').style.display='none'" style="background:transparent;border:none;font-size:18px;">âœ•</button>
                        </div>
                        <div id="preview-body" style="padding:16px;overflow-x:auto;">Loading...</div>
                    </div>`;
                document.body.appendChild(modal);
            }
            
            document.getElementById('preview-title').textContent = `${ds.icon} ${ds.name} - Recent 20 Records`;
            document.getElementById('preview-body').innerHTML = '<div style="text-align:center;padding:20px;color:var(--text-muted);">â³ Loading...</div>';
            modal.style.display = 'flex';
            
            try {
                const { data, error } = await sb
                    .from(ds.table)
                    .select('*')
                    .order('date', { ascending: false })
                    .limit(20);
                
                if (error) throw error;
                
                if (!data || data.length === 0) {
                    document.getElementById('preview-body').innerHTML = '<div style="text-align:center;padding:20px;color:var(--text-muted);">No data found</div>';
                    return;
                }
                
                // í…Œì´ë¸” ìƒì„±
                const columns = Object.keys(data[0]).filter(k => !k.startsWith('_'));
                let html = `<div style="font-size:11px;color:var(--text-muted);margin-bottom:12px;">Table: <code>${ds.table}</code> | Records: ${data.length} | Value Field: <code>${ds.valueField}</code></div>`;
                html += '<table style="width:max-content;font-size:11px;border-collapse:collapse;"><thead><tr>';
                for (const col of columns) {
                    const isValueField = col === ds.valueField;
                    html += `<th style="text-align:left;padding:6px 10px;border-bottom:1px solid var(--border);white-space:nowrap;${isValueField ? 'background:rgba(124,58,237,0.1);' : ''}">${col.toUpperCase()}</th>`;
                }
                html += '</tr></thead><tbody>';
                
                for (const row of data) {
                    html += '<tr>';
                    for (const col of columns) {
                        const isValueField = col === ds.valueField;
                        let val = row[col];
                        // ìˆ«ì í¬ë§·íŒ…
                        if (typeof val === 'number') {
                            if (Math.abs(val) >= 1e9) val = (val / 1e9).toFixed(2) + 'B';
                            else if (Math.abs(val) >= 1e6) val = (val / 1e6).toFixed(2) + 'M';
                            else if (Math.abs(val) >= 1e3) val = (val / 1e3).toFixed(2) + 'K';
                            else if (Math.abs(val) < 0.01 && val !== 0) val = val.toFixed(6);
                            else val = val.toLocaleString(undefined, { maximumFractionDigits: 4 });
                        }
                        html += `<td style="padding:6px 10px;border-bottom:1px solid var(--border);white-space:nowrap;${isValueField ? 'background:rgba(124,58,237,0.1);font-weight:600;' : ''}">${val ?? '-'}</td>`;
                    }
                    html += '</tr>';
                }
                html += '</tbody></table>';
                
                document.getElementById('preview-body').innerHTML = html;
                
            } catch (e) {
                document.getElementById('preview-body').innerHTML = `<div style="color:var(--error);padding:20px;">Error: ${e.message}</div>`;
            }
        }
        
        async function collectPhase(phase) {
            const phaseDatasets = Object.entries(DATASETS).filter(([k, ds]) => ds.phase === phase && !ds.noCollect);
            log(`ğŸš€ Phase ${phase} (${phaseDatasets.length} datasets)...`, 'info');
            
            let success = 0, failed = 0;
            for (const [key, ds] of phaseDatasets) {
                if (!collectors[key]) continue;
                try {
                    const count = await collectors[key]();
                    if (count > 0) {
                        log(`  âœ… ${ds.name}: ${count}`, 'success');
                    }
                    success++;
                } catch (e) {
                    log(`  âŒ ${ds.name}: ${e.message}`, 'error');
                    failed++;
                }
                await new Promise(r => setTimeout(r, 300));
            }
            
            log(`ğŸ“Š Phase ${phase}: ${success} success, ${failed} failed`, success > 0 ? 'success' : 'error');
            await loadDataStatus();
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BATCH UPSERT HELPER - 100ê°œì”© ë‚˜ëˆ ì„œ ì €ì¥ + ì¬ì‹œë„
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        async function batchUpsert(table, records, conflictKey = 'date', batchSize = 1500) {
            if (!records || records.length === 0) return { error: null, count: 0 };
            
            const actualBatchSize = conflictKey.includes(',') ? Math.min(batchSize, 500) : batchSize;
            let totalInserted = 0;
            const batches = Math.ceil(records.length / actualBatchSize);
            
            for (let i = 0; i < batches; i++) {
                const start = i * actualBatchSize;
                const end = Math.min(start + actualBatchSize, records.length);
                const batch = records.slice(start, end);
                
                let lastError = null;
                for (let retry = 0; retry < 3; retry++) {
                    try {
                        const { error } = await sb.from(table).upsert(batch, { onConflict: conflictKey });
                        if (!error) {
                            totalInserted += batch.length;
                            lastError = null;
                            break;
                        }
                        lastError = error;
                    } catch (e) {
                        lastError = e;
                    }
                    if (retry < 2) await new Promise(r => setTimeout(r, 1000 * (retry + 1)));
                }
                
                if (lastError) {
                    log(`  âŒ ${table}: batch ${i+1}/${batches} failed`, 'error');
                    return { error: lastError, count: totalInserted };
                }
                
                if (i < batches - 1) await new Promise(r => setTimeout(r, 200));
            }
            
            return { error: null, count: totalInserted };
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // COLLECTORS - Schema Aligned
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const collectors = {
            // 1. ETH Price (Dune API)
            async eth_price() {
                if (!DUNE_API_KEY) {
                    log('  âš ï¸ Dune API key required for ETH Price', 'warn');
                    return 0;
                }
                
                log('  ğŸ“¡ Fetching ETH price from Dune...', 'info');
                
                try {
                    const response = await fetch(
                        `https://api.dune.com/api/v1/query/${DUNE_ETH_PRICE_QUERY_ID}/results?limit=1500`,
                        { headers: { 'X-Dune-API-Key': DUNE_API_KEY } }
                    );
                    
                    if (!response.ok) {
                        throw new Error(`Dune API error: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    
                    if (!data?.result?.rows || data.result.rows.length === 0) {
                        throw new Error('No data from Dune');
                    }
                    
                    log(`  âœ“ Dune returned ${data.result.rows.length} days`, 'info');
                    
                    const records = data.result.rows.map(row => ({
                        date: row.date,
                        open: parseFloat(row.open) || parseFloat(row.avg_price),
                        high: parseFloat(row.high) || parseFloat(row.avg_price),
                        low: parseFloat(row.low) || parseFloat(row.avg_price),
                        close: parseFloat(row.close) || parseFloat(row.avg_price),
                        volume: 0
                    }));
                    
                    const { error, count } = await batchUpsert('historical_eth_price', records);
                    if (error) log(`  âŒ ${error.message}`, 'error');
                    return error ? 0 : count;
                } catch (e) {
                    log(`  âŒ Dune error: ${e.message}`, 'error');
                    return 0;
                }
            },

            // 2. Ethereum TVL - NO source, NO timestamp
            async ethereum_tvl() {
                const data = await fetchJSON('https://api.llama.fi/v2/historicalChainTvl/Ethereum');
                if (!data) return 0;
                const cutoff = Date.now() / 1000 - (1095 * 86400);
                const records = data.filter(d => d.date > cutoff && d.tvl > 0).map(d => ({
                    date: new Date(d.date * 1000).toISOString().split('T')[0],
                    tvl: parseFloat(d.tvl.toFixed(2))
                }));
                const { error, count } = await batchUpsert('historical_ethereum_tvl', records);
                if (error) log(`  âŒ ${error.message}`, 'error');
                return error ? 0 : count;
            },

            // 3. L2 TVL - NO source, NO timestamp
            async l2_tvl() {
                const chains = ['Arbitrum', 'Optimism', 'Base', 'zkSync Era', 'Linea', 'Scroll', 'Blast'];
                const cutoff = Date.now() / 1000 - (1095 * 86400);
                let total = 0, failed = [];
                for (const chain of chains) {
                    const data = await fetchJSON(`https://api.llama.fi/v2/historicalChainTvl/${encodeURIComponent(chain)}`);
                    if (!data) {
                        failed.push(chain);
                        continue;
                    }
                    const records = data.filter(d => d.date > cutoff && d.tvl > 0).map(d => ({
                        date: new Date(d.date * 1000).toISOString().split('T')[0],
                        chain,
                        tvl: parseFloat(d.tvl.toFixed(2))
                    }));
                    if (records.length > 0) {
                        const { error } = await batchUpsert('historical_l2_tvl', records, 'date,chain');
                        if (!error) total += records.length;
                    }
                    await new Promise(r => setTimeout(r, 200));
                }
                if (failed.length > 0) log(`  âš ï¸ Failed chains: ${failed.join(', ')}`, 'warn');
                return total;
            },

            // 4. Protocol Fees - NO source, NO timestamp
            async protocol_fees() {
                const data = await fetchJSON('https://api.llama.fi/summary/fees/ethereum?dataType=dailyFees');
                if (!data?.totalDataChart) return 0;
                const records = data.totalDataChart.filter(d => d[1] > 0).map(d => ({
                    date: new Date(d[0] * 1000).toISOString().split('T')[0],
                    fees: parseFloat(d[1].toFixed(2))
                }));
                const { error } = await batchUpsert('historical_protocol_fees', records);
                if (error) log(`  âŒ ${error.message}`, 'error');
                return error ? 0 : records.length;
            },

            // 5. Staking - DefiLlama yields API (Lido stETH pool)
            async staking_data() {
                const yieldData = await fetchJSON('https://yields.llama.fi/chart/747c1d2a-c668-4682-b9f9-296708a3dd90');
                
                if (!yieldData?.data || yieldData.data.length === 0) {
                    // Fallback: Use Lido protocol TVL from DefiLlama
                    const lidoData = await fetchJSON('https://api.llama.fi/protocol/lido');
                    if (!lidoData?.tvl || lidoData.tvl.length === 0) {
                        log('  âŒ DefiLlama & Lido APIs failed', 'error');
                        return 0;
                    }
                    
                    const { data: prices } = await sb.from('historical_eth_price').select('date, close').order('date', { ascending: false }).limit(1100);
                    const priceMap = new Map(prices?.map(p => [p.date, parseFloat(p.close)]) || []);
                    
                    const cutoff = Date.now() / 1000 - (1095 * 86400);
                    const records = [];
                    
                    for (const point of lidoData.tvl) {
                        if (point.date < cutoff) continue;
                        
                        const date = new Date(point.date * 1000).toISOString().split('T')[0];
                        const lidoTvlUsd = point.totalLiquidityUSD || 0;
                        const price = priceMap.get(date) || 3500;
                        
                        if (lidoTvlUsd <= 0) continue;
                        
                        const lidoStakedEth = lidoTvlUsd / price;
                        const totalStakedEth = lidoStakedEth / 0.28;
                        const totalValidators = Math.round(totalStakedEth / 32);
                        
                        records.push({
                            date,
                            timestamp: point.date * 1000,
                            total_staked_eth: Math.round(totalStakedEth),
                            staked_eth: Math.round(lidoStakedEth),
                            total_validators: totalValidators,
                            avg_apr: 3.5,
                            source: 'defillama-lido'
                        });
                    }
                    
                    const seen = new Set();
                    const uniqueRecords = records.filter(r => {
                        if (seen.has(r.date)) return false;
                        seen.add(r.date);
                        return true;
                    });
                    
                    const { error } = await batchUpsert('historical_staking', uniqueRecords);
                    if (error) log(`  âŒ ${error.message}`, 'error');
                    return error ? 0 : uniqueRecords.length;
                }
                
                // Get ETH prices for TVL calculation
                const { data: prices } = await sb.from('historical_eth_price').select('date, close').order('date', { ascending: false }).limit(1100);
                const priceMap = new Map(prices?.map(p => [p.date, parseFloat(p.close)]) || []);
                
                const cutoff = Date.now() - (1095 * 24 * 60 * 60 * 1000);
                const records = [];
                
                const getMarketShare = (date) => {
                    const year = new Date(date).getFullYear();
                    if (year <= 2022) return 0.30;
                    if (year === 2023) return 0.32;
                    return 0.28;
                };
                
                for (const point of yieldData.data) {
                    const timestamp = new Date(point.timestamp).getTime();
                    if (timestamp < cutoff) continue;
                    
                    const date = point.timestamp.split('T')[0];
                    const lidoTvlUsd = point.tvlUsd || 0;
                    const apr = point.apy || 0;
                    const price = priceMap.get(date) || 3500;
                    
                    if (lidoTvlUsd <= 0) continue;
                    
                    const lidoStakedEth = lidoTvlUsd / price;
                    const marketShare = getMarketShare(date);
                    const totalStakedEth = lidoStakedEth / marketShare;
                    const totalValidators = Math.round(totalStakedEth / 32);
                    
                    records.push({
                        date,
                        timestamp,
                        total_staked_eth: Math.round(totalStakedEth),
                        staked_eth: Math.round(lidoStakedEth),
                        total_validators: totalValidators,
                        avg_apr: parseFloat(apr.toFixed(2)),
                        source: 'defillama'
                    });
                }
                
                const seen = new Set();
                const uniqueRecords = records.filter(r => {
                    if (seen.has(r.date)) return false;
                    seen.add(r.date);
                    return true;
                });
                
                const { error } = await batchUpsert('historical_staking', uniqueRecords);
                if (error) log(`  âŒ ${error.message}`, 'error');
                return error ? 0 : uniqueRecords.length;
            },

            // 6. Gas & Burn - Etherscan V2 with fallback
            async gas_burn() {
                // Gas & Burn data is collected via gas_price collector (same Dune query)
                log('  ğŸ”„ Redirecting to gas_price collector...', 'info');
                return await collectors.gas_price();
            },

            // 7. Active Addresses - Dune API (ì •í™•í•œ ì˜¨ì²´ì¸ ë°ì´í„°)
            async active_addresses() {
                log('  ğŸ” Fetching Active Addresses...', 'info');
                
                if (!DUNE_API_KEY) {
                    log('  âš ï¸ No Dune API key - falling back to tx-based estimation', 'warn');
                    const { data: txs } = await sb.from('historical_transactions').select('date, tx_count').order('date', { ascending: false }).limit(1100);
                    if (!txs?.length) return 0;
                    const records = txs.map(t => ({
                        date: t.date, timestamp: Date.now(),
                        active_addresses: Math.floor(t.tx_count * 0.4),
                        source: 'estimated'
                    }));
                    const { error } = await batchUpsert('historical_active_addresses', records);
                    if (error) log(`  âŒ ${error.message}`, 'error');
                    return error ? 0 : records.length;
                }
                
                try {
                    log('  ğŸ“¡ Fetching from Dune API...', 'info');
                    
                    // Paginate through all results
                    let allRows = [];
                    let offset = 0;
                    const pageSize = 1000;
                    
                    while (true) {
                        const response = await fetch(`https://api.dune.com/api/v1/query/${DUNE_ACTIVE_ADDR_QUERY_ID}/results?limit=${pageSize}&offset=${offset}`, {
                            headers: { 'X-Dune-API-Key': DUNE_API_KEY }
                        });
                        
                        if (!response.ok) break;
                        
                        const data = await response.json();
                        const rows = data.result?.rows || [];
                        
                        if (rows.length === 0) break;
                        
                        allRows = allRows.concat(rows);
                        log(`  ğŸ“Š Fetched ${rows.length} rows (total: ${allRows.length})`, 'info');
                        
                        if (rows.length < pageSize) break;
                        offset += pageSize;
                    }
                    
                    if (allRows.length > 0) {
                        log(`  ğŸ“Š Got ${allRows.length} Active Addresses records from Dune`, 'info');
                        
                        const records = allRows.map(row => {
                            let dateStr = row.date;
                            if (typeof dateStr === 'string' && dateStr.includes(' ')) {
                                dateStr = dateStr.split(' ')[0];
                            }
                            
                            return {
                                date: dateStr,
                                timestamp: new Date(dateStr).getTime(),
                                active_addresses: parseInt(row.active_addresses) || 0,
                                source: 'dune'
                            };
                        }).filter(r => r.active_addresses > 0);
                        
                        // Show samples
                        const samples = records.slice(-3);
                        samples.forEach(r => {
                            log(`  ğŸ“Š ${r.date}: ${r.active_addresses.toLocaleString()} addresses`, 'info');
                        });
                        
                        const { error } = await batchUpsert('historical_active_addresses', records);
                        if (error) {
                            log(`  âŒ Save error: ${error.message}`, 'error');
                            return 0;
                        }
                        
                        log(`  âœ… Active Addresses: ${records.length} records saved from Dune`, 'success');
                        return records.length;
                    }
                    
                    log('  âš ï¸ No data from Dune', 'warn');
                    return 0;
                } catch (e) {
                    log(`  âŒ Dune API error: ${e.message}`, 'error');
                    return 0;
                }
            },

            // 8. ETH Supply - HAS source (no timestamp in schema)
            async eth_supply() {
                // ë¨¼ì € ê¸°ì¡´ ë°ì´í„° í™•ì¸ (CSV ë°ì´í„° ë³´í˜¸)
                const { data: existingData } = await sb.from('historical_eth_supply')
                    .select('date, eth_supply')
                    .order('date', { ascending: false })
                    .limit(1200);
                
                const existingDates = new Set(existingData?.filter(d => d.eth_supply > 0).map(d => d.date) || []);
                log(`  ğŸ“‹ Existing eth_supply records: ${existingDates.size}`, 'info');
                
                // CSV ë°ì´í„°ê°€ ë§ì´ ìˆìœ¼ë©´ (1000ê°œ ì´ìƒ) ê±´ë„ˆë›°ê¸°
                if (existingDates.size > 1000) {
                    log(`  ğŸ“‹ Skipping - sufficient CSV data exists (${existingDates.size} records)`, 'success');
                    return -1;
                }
                
                const today = new Date();
                const records = [];
                for (let i = 0; i < 1095; i++) {
                    const date = new Date(today); date.setDate(date.getDate() - i);
                    const dateStr = date.toISOString().split('T')[0];
                    
                    // ê¸°ì¡´ ë°ì´í„°ê°€ ìˆëŠ” ë‚ ì§œëŠ” ê±´ë„ˆë›°ê¸°
                    if (existingDates.has(dateStr)) continue;
                    
                    records.push({
                        date: dateStr,
                        eth_supply: 120400000 + (i * 100),
                        source: 'estimated'
                    });
                }
                
                if (records.length === 0) {
                    log(`  âœ… All dates already have data`, 'success');
                    return 0;
                }
                
                log(`  ğŸ“¦ Generated ${records.length} records for missing dates`, 'info');
                const { error } = await batchUpsert('historical_eth_supply', records);
                if (error) log(`  âŒ ${error.message}`, 'error');
                return error ? 0 : records.length;
            },

            // 9. Fear & Greed - HAS source
            async fear_greed() {
                log('  ğŸ” Fetching Fear & Greed from alternative.me...', 'info');
                const data = await fetchJSON('https://api.alternative.me/fng/?limit=1095&format=json');
                
                if (!data?.data || data.data.length === 0) {
                    log('  âš ï¸ API failed, using price-based estimates', 'warn');
                    
                    // Fallback: ETH price ë³€ë™ ê¸°ë°˜ ì¶”ì •
                    const { data: prices } = await sb.from('historical_eth_price')
                        .select('date, close')
                        .order('date', { ascending: true })
                        .limit(1100);
                    
                    if (!prices || prices.length < 30) {
                        log('  âŒ Not enough price data for fallback', 'error');
                        return 0;
                    }
                    
                    const records = [];
                    for (let i = 30; i < prices.length; i++) {
                        const current = prices[i].close;
                        const prev30 = prices[i - 30].close;
                        const change30d = ((current - prev30) / prev30) * 100;
                        
                        // 30ì¼ ë³€ë™ë¥  ê¸°ë°˜ Fear & Greed ì¶”ì •
                        // -30% ì´í•˜: Extreme Fear (10-20)
                        // -15% ~ -30%: Fear (20-40)
                        // -5% ~ -15%: Neutral-Fear (40-50)
                        // -5% ~ +5%: Neutral (45-55)
                        // +5% ~ +15%: Neutral-Greed (50-60)
                        // +15% ~ +30%: Greed (60-80)
                        // +30% ì´ìƒ: Extreme Greed (80-95)
                        
                        let value;
                        if (change30d < -30) value = 10 + Math.random() * 10;
                        else if (change30d < -15) value = 20 + (change30d + 30) / 15 * 20;
                        else if (change30d < -5) value = 40 + (change30d + 15) / 10 * 10;
                        else if (change30d < 5) value = 45 + (change30d + 5) / 10 * 10;
                        else if (change30d < 15) value = 55 + (change30d - 5) / 10 * 10;
                        else if (change30d < 30) value = 65 + (change30d - 15) / 15 * 15;
                        else value = 80 + Math.min(15, (change30d - 30) / 20 * 15);
                        
                        value = Math.max(5, Math.min(95, Math.round(value)));
                        
                        let classification;
                        if (value < 25) classification = 'Extreme Fear';
                        else if (value < 40) classification = 'Fear';
                        else if (value < 60) classification = 'Neutral';
                        else if (value < 75) classification = 'Greed';
                        else classification = 'Extreme Greed';
                        
                        records.push({
                            date: prices[i].date,
                            timestamp: new Date(prices[i].date).getTime(),
                            value,
                            classification,
                            source: 'estimated'
                        });
                    }
                    
                    log(`  ğŸ“¦ Generated ${records.length} estimated records`, 'info');
                    const { error } = await batchUpsert('historical_fear_greed', records);
                    if (error) log(`  âŒ ${error.message}`, 'error');
                    return 0; // API ì‹¤íŒ¨ì´ë¯€ë¡œ 0 ë°˜í™˜
                }
                
                log(`  ğŸ“¦ Got ${data.data.length} records from API`, 'info');
                const records = data.data.map(d => ({
                    date: new Date(parseInt(d.timestamp) * 1000).toISOString().split('T')[0],
                    timestamp: parseInt(d.timestamp) * 1000,
                    value: parseInt(d.value),
                    classification: d.value_classification,
                    source: 'alternative_me'
                }));
                
                // ë°ì´í„° ê²€ì¦ ë¡œê·¸
                const values = records.map(r => r.value);
                const min = Math.min(...values);
                const max = Math.max(...values);
                const avg = values.reduce((a, b) => a + b, 0) / values.length;
                log(`  ğŸ“Š Value range: ${min}-${max}, avg: ${avg.toFixed(1)}`, 'info');
                
                const { error } = await batchUpsert('historical_fear_greed', records);
                if (error) log(`  âŒ ${error.message}`, 'error');
                return error ? 0 : records.length;
            },

            // 10. DEX Volume - HAS source
            async dex_volume() {
                const data = await fetchJSON('https://api.llama.fi/overview/dexs/ethereum?excludeTotalDataChart=false&excludeTotalDataChartBreakdown=true&dataType=dailyVolume');
                if (!data?.totalDataChart) return 0;
                const records = data.totalDataChart.filter(d => d[1] > 0).map(d => ({
                    date: new Date(d[0] * 1000).toISOString().split('T')[0],
                    timestamp: d[0] * 1000,
                    volume: parseFloat(d[1].toFixed(2)),
                    source: 'defillama'
                }));
                const { error } = await batchUpsert('historical_dex_volume', records);
                if (error) log(`  âŒ ${error.message}`, 'error');
                return error ? 0 : records.length;
            },

            // 11. Stablecoins All - HAS source
            async stablecoins() {
                const data = await fetchJSON('https://stablecoins.llama.fi/stablecoincharts/all');
                if (!data) return 0;
                const cutoff = Date.now() / 1000 - (1095 * 86400);
                const records = data.filter(d => d.date > cutoff).map(d => ({
                    date: new Date(d.date * 1000).toISOString().split('T')[0],
                    timestamp: d.date * 1000,
                    total_mcap: parseFloat((d.totalCirculatingUSD?.peggedUSD || d.totalCirculating?.peggedUSD || 0).toFixed(2)),
                    source: 'defillama'
                })).filter(r => r.total_mcap > 0);
                const { error } = await batchUpsert('historical_stablecoins', records);
                if (error) log(`  âŒ ${error.message}`, 'error');
                return error ? 0 : records.length;
            },

            // 12. Stablecoins ETH - check if table exists
            async stablecoins_eth() {
                const data = await fetchJSON('https://stablecoins.llama.fi/stablecoincharts/Ethereum');
                if (!data) return 0;
                const cutoff = Date.now() / 1000 - (1095 * 86400);
                const records = data.filter(d => d.date > cutoff).map(d => ({
                    date: new Date(d.date * 1000).toISOString().split('T')[0],
                    timestamp: d.date * 1000,
                    total_mcap: parseFloat((d.totalCirculatingUSD?.peggedUSD || d.totalCirculating?.peggedUSD || 0).toFixed(2)),
                    source: 'defillama'
                })).filter(r => r.total_mcap > 0);
                const { error } = await batchUpsert('historical_stablecoins_eth', records);
                if (error) log(`  âŒ ${error.message}`, 'error');
                return error ? 0 : records.length;
            },

            // 13. ETH/BTC Ratio (Dune API)
            async eth_btc() {
                if (!DUNE_API_KEY) {
                    log('  âš ï¸ Dune API key required for ETH/BTC', 'warn');
                    return 0;
                }
                
                log('  ğŸ“¡ Fetching ETH/BTC ratio from Dune...', 'info');
                
                try {
                    const response = await fetch(
                        `https://api.dune.com/api/v1/query/${DUNE_ETH_BTC_QUERY_ID}/results?limit=1500`,
                        { headers: { 'X-Dune-API-Key': DUNE_API_KEY } }
                    );
                    
                    if (!response.ok) {
                        throw new Error(`Dune API error: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    
                    if (!data?.result?.rows || data.result.rows.length === 0) {
                        throw new Error('No data from Dune');
                    }
                    
                    log(`  âœ“ Dune returned ${data.result.rows.length} days`, 'info');
                    
                    const records = data.result.rows.map(row => ({
                        date: row.date,
                        ratio: parseFloat(row.ratio),
                        source: 'dune'
                    }));
                    
                    const { error } = await batchUpsert('historical_eth_btc', records);
                    if (error) log(`  âŒ ${error.message}`, 'error');
                    return error ? 0 : records.length;
                } catch (e) {
                    log(`  âŒ Dune error: ${e.message}`, 'error');
                    return 0;
                }
            },

            // 14. Funding Rate - CryptoQuant API via Cloudflare Proxy
            async funding_rate() {
                const PROXY_URL = 'https://cryptoquant-proxy.seojoon-kim.workers.dev';
                
                try {
                    const response = await fetch(
                        `${PROXY_URL}/?endpoint=/v1/eth/market-data/funding-rates&window=day&exchange=all_exchange&limit=1095`
                    );
                    
                    if (!response.ok) {
                        throw new Error(`Proxy error: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    
                    if (data.status?.code !== 200) {
                        throw new Error(data.status?.message || 'API error');
                    }
                    
                    const rows = data?.result?.data || [];
                    
                    if (rows.length === 0) {
                        throw new Error('No data from CryptoQuant');
                    }
                    
                    log(`  ğŸ“¦ Got ${rows.length} funding rate records from CryptoQuant`, 'info');
                    
                    const records = rows.map(row => ({
                        date: row.date,
                        funding_rate: parseFloat(row.funding_rates || 0),
                        source: 'cryptoquant'
                    })).filter(r => r.date && !isNaN(r.funding_rate));
                    
                    if (records.length === 0) return 0;
                    
                    const { error } = await batchUpsert('historical_funding_rate', records);
                    if (error) log(`  âŒ ${error.message}`, 'error');
                    return error ? 0 : records.length;
                } catch (e) {
                    log(`  âŒ CryptoQuant error: ${e.message}`, 'error');
                    return 0;
                }
            },

            // 15. Exchange Reserve - CryptoQuant API via Cloudflare Proxy
            async exchange_reserve() {
                const PROXY_URL = 'https://cryptoquant-proxy.seojoon-kim.workers.dev';
                
                try {
                    const response = await fetch(
                        `${PROXY_URL}/?endpoint=/v1/eth/exchange-flows/reserve&window=day&exchange=all_exchange&limit=1095`
                    );
                    
                    if (!response.ok) {
                        throw new Error(`Proxy error: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    
                    if (data.status?.code !== 200) {
                        throw new Error(data.status?.message || 'API error');
                    }
                    
                    const rows = data?.result?.data || [];
                    
                    if (rows.length === 0) {
                        throw new Error('No data from CryptoQuant');
                    }
                    
                    log(`  ğŸ“¦ Got ${rows.length} exchange reserve records from CryptoQuant`, 'info');
                    
                    const records = rows.map(row => ({
                        date: row.date,
                        reserve_eth: parseFloat(row.reserve || 0),
                        source: 'cryptoquant'
                    })).filter(r => r.date && !isNaN(r.reserve_eth) && r.reserve_eth > 0);
                    
                    if (records.length === 0) return 0;
                    
                    const { error } = await batchUpsert('historical_exchange_reserve', records);
                    if (error) log(`  âŒ ${error.message}`, 'error');
                    return error ? 0 : records.length;
                } catch (e) {
                    log(`  âŒ CryptoQuant error: ${e.message}`, 'error');
                    return 0;
                }
            },

            // 15-2. Open Interest - CryptoQuant API via Cloudflare Proxy
            async open_interest() {
                const PROXY_URL = 'https://cryptoquant-proxy.seojoon-kim.workers.dev';
                
                try {
                    const response = await fetch(
                        `${PROXY_URL}/?endpoint=/v1/eth/market-data/open-interest&window=day&exchange=all_exchange&symbol=all_symbol&limit=1095`
                    );
                    
                    if (!response.ok) {
                        throw new Error(`Proxy error: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    
                    if (data.status?.code !== 200) {
                        throw new Error(data.status?.message || 'API error');
                    }
                    
                    const rows = data?.result?.data || [];
                    
                    if (rows.length === 0) {
                        throw new Error('No data from CryptoQuant');
                    }
                    
                    log(`  ğŸ“¦ Got ${rows.length} open interest records from CryptoQuant`, 'info');
                    
                    const records = rows.map(row => ({
                        date: row.date,
                        open_interest: parseFloat(row.open_interest || 0),
                        source: 'cryptoquant'
                    })).filter(r => r.date && !isNaN(r.open_interest) && r.open_interest > 0);
                    
                    if (records.length === 0) return 0;
                    
                    const { error } = await batchUpsert('historical_open_interest', records);
                    if (error) log(`  âŒ ${error.message}`, 'error');
                    return error ? 0 : records.length;
                } catch (e) {
                    log(`  âŒ CryptoQuant error: ${e.message}`, 'error');
                    return 0;
                }
            },

            // 16. ETH Dominance - HAS source
            async eth_dominance() {
                // CoinGecko days=365 (ë¬´ë£Œ ìµœëŒ€)
                log(`  ğŸ” Fetching ETH dominance from CoinGecko...`, 'info');
                
                const [ethData, btcData, globalData] = await Promise.all([
                    fetchJSON('https://api.coingecko.com/api/v3/coins/ethereum/market_chart?vs_currency=usd&days=365&interval=daily'),
                    fetchJSON('https://api.coingecko.com/api/v3/coins/bitcoin/market_chart?vs_currency=usd&days=365&interval=daily'),
                    fetchJSON('https://api.coingecko.com/api/v3/global')
                ]);
                
                if (!ethData?.market_caps || !btcData?.market_caps || !globalData?.data) {
                    log('  âŒ Failed to get CoinGecko data', 'error');
                    return 0;
                }
                
                const currentBtcDom = globalData.data.market_cap_percentage.btc;
                
                // BTC mcapì„ ë‚ ì§œë³„ ë§µìœ¼ë¡œ
                const btcMcapMap = new Map();
                for (const [ts, mcap] of btcData.market_caps) {
                    const date = new Date(ts).toISOString().split('T')[0];
                    btcMcapMap.set(date, mcap);
                }
                
                const records = [];
                const seenDates = new Set();
                
                for (const [timestamp, ethMcap] of ethData.market_caps) {
                    const date = new Date(timestamp).toISOString().split('T')[0];
                    if (seenDates.has(date)) continue;
                    seenDates.add(date);
                    
                    const btcMcap = btcMcapMap.get(date);
                    if (!btcMcap) continue;
                    
                    // Total market cap = BTC mcap / BTC dominance
                    const totalMcap = btcMcap / (currentBtcDom / 100);
                    const ethDominance = (ethMcap / totalMcap) * 100;
                    const btcDominance = (btcMcap / totalMcap) * 100;
                    
                    records.push({
                        date,
                        timestamp,
                        eth_dominance: parseFloat(Math.min(25, Math.max(8, ethDominance)).toFixed(2)),
                        btc_dominance: parseFloat(Math.min(70, Math.max(35, btcDominance)).toFixed(2)),
                        total_mcap: totalMcap,
                        source: 'coingecko'
                    });
                }
                
                if (records.length === 0) {
                    log('  âŒ No records generated', 'error');
                    return 0;
                }
                
                log(`  ğŸ“¦ Got ${records.length} days from CoinGecko`, 'info');
                const { error } = await batchUpsert('historical_eth_dominance', records);
                if (error) log(`  âŒ ${error.message}`, 'error');
                return error ? 0 : records.length;
            },

            // 17. Blob Data - Dune API (ì •í™•í•œ ì˜¨ì²´ì¸ ë°ì´í„°)
            async blob_data() {
                log('  ğŸ” Fetching blob data...', 'info');
                
                // Dune API ì‚¬ìš© ê°€ëŠ¥í•œì§€ í™•ì¸
                if (!DUNE_API_KEY) {
                    log('  âš ï¸ No Dune API key configured. Add it in Config to collect blob data.', 'warn');
                    return 0;
                }
                
                try {
                    // 1. ë¨¼ì € ìµœì‹  ìºì‹œëœ ê²°ê³¼ ì‹œë„
                    log('  ğŸ“¡ Fetching from Dune API (query #' + DUNE_BLOB_QUERY_ID + ')...', 'info');
                    
                    let duneData = null;
                    
                    // Try getting latest results first (faster, uses cached data)
                    const latestResponse = await fetch(`https://api.dune.com/api/v1/query/${DUNE_BLOB_QUERY_ID}/results?limit=1000`, {
                        headers: { 'X-Dune-API-Key': DUNE_API_KEY }
                    });
                    
                    if (latestResponse.ok) {
                        const latestData = await latestResponse.json();
                        if (latestData.result && latestData.result.rows && latestData.result.rows.length > 0) {
                            duneData = latestData.result.rows;
                            log(`  ğŸ“Š Got ${duneData.length} rows from cached results`, 'info');
                        }
                    }
                    
                    // Check if data is stale (latest date > 2 days old)
                    let dataIsStale = false;
                    if (duneData && duneData.length > 0) {
                        const latestDate = duneData.reduce((max, row) => {
                            const d = row.block_date || row.date || '';
                            return d > max ? d : max;
                        }, '');
                        
                        if (latestDate) {
                            const twoDaysAgo = new Date();
                            twoDaysAgo.setDate(twoDaysAgo.getDate() - 2);
                            const twoDaysAgoStr = twoDaysAgo.toISOString().split('T')[0];
                            
                            if (latestDate < twoDaysAgoStr) {
                                dataIsStale = true;
                                log(`  âš ï¸ Cached data is stale (latest: ${latestDate}, need >= ${twoDaysAgoStr})`, 'warn');
                            }
                        }
                    }
                    
                    // If no cached data, too old, or stale data, execute fresh query
                    if (!duneData || duneData.length < 600 || dataIsStale) {
                        log('  ğŸ”„ Executing fresh Dune query...', 'info');
                        
                        // Execute query
                        const execResponse = await fetch(`https://api.dune.com/api/v1/query/${DUNE_BLOB_QUERY_ID}/execute`, {
                            method: 'POST',
                            headers: { 
                                'X-Dune-API-Key': DUNE_API_KEY,
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({ performance: 'medium' })
                        });
                        
                        if (!execResponse.ok) {
                            const errText = await execResponse.text();
                            log(`  âŒ Dune execute failed: ${errText}`, 'error');
                            return 0;
                        }
                        
                        const execData = await execResponse.json();
                        const executionId = execData.execution_id;
                        log(`  â³ Execution started: ${executionId}`, 'info');
                        
                        // Poll for results (max 2 minutes)
                        let attempts = 0;
                        const maxAttempts = 24; // 24 * 5s = 120s
                        
                        while (attempts < maxAttempts) {
                            await new Promise(r => setTimeout(r, 5000)); // Wait 5s
                            attempts++;
                            
                            const statusResponse = await fetch(`https://api.dune.com/api/v1/execution/${executionId}/status`, {
                                headers: { 'X-Dune-API-Key': DUNE_API_KEY }
                            });
                            
                            if (!statusResponse.ok) continue;
                            
                            const statusData = await statusResponse.json();
                            log(`  â³ Status: ${statusData.state} (${attempts}/${maxAttempts})`, 'info');
                            
                            if (statusData.state === 'QUERY_STATE_COMPLETED') {
                                // Get results
                                const resultsResponse = await fetch(`https://api.dune.com/api/v1/execution/${executionId}/results?limit=1000`, {
                                    headers: { 'X-Dune-API-Key': DUNE_API_KEY }
                                });
                                
                                if (resultsResponse.ok) {
                                    const resultsData = await resultsResponse.json();
                                    duneData = resultsData.result?.rows || [];
                                    log(`  âœ… Query completed: ${duneData.length} rows`, 'success');
                                }
                                break;
                            } else if (statusData.state === 'QUERY_STATE_FAILED') {
                                log(`  âŒ Query failed: ${statusData.error}`, 'error');
                                return 0;
                            }
                        }
                    }
                    
                    if (!duneData || duneData.length === 0) {
                        log('  âŒ No data from Dune', 'error');
                        return 0;
                    }
                    
                    // 2. ê¸°ì¡´ ë°ì´í„° ì¡°íšŒ (fee ì •ë³´ ìœ ì§€ë¥¼ ìœ„í•´)
                    const { data: existingData } = await sb.from('historical_blob_data')
                        .select('date, blob_fee_eth')
                        .order('date', { ascending: true });
                    
                    const existingFees = {};
                    (existingData || []).forEach(d => {
                        if (d.blob_fee_eth && d.blob_fee_eth > 0.01) {
                            existingFees[d.date] = d.blob_fee_eth;
                        }
                    });
                    
                    // 3. ë ˆì½”ë“œ ë³€í™˜
                    const records = duneData.map(row => {
                        // Handle different date formats
                        let dateStr = row.date;
                        if (typeof dateStr === 'string' && dateStr.includes(' ')) {
                            dateStr = dateStr.split(' ')[0]; // "2024-03-13 00:00:00" -> "2024-03-13"
                        }
                        
                        const blobCount = parseInt(row.blob_count) || 0;
                        const blobGasUsed = parseInt(row.blob_gas_used) || 0;
                        
                        // Fee: Dune ê²°ê³¼ì—ì„œ ì§ì ‘ ê°€ì ¸ì˜¤ê¸° (blob_fee_eth ì»¬ëŸ¼)
                        let blobFeeEth = parseFloat(row.blob_fee_eth) || 0;
                        
                        // Duneì—ì„œ feeê°€ ì—†ìœ¼ë©´ ê¸°ì¡´ ê°’ ë˜ëŠ” ì¶”ì •
                        if (!blobFeeEth || blobFeeEth < 0.01) {
                            blobFeeEth = existingFees[dateStr] || (blobCount * 0.0002);
                        }
                        
                        return {
                            date: dateStr,
                            timestamp: new Date(dateStr).getTime(),
                            blob_count: blobCount,
                            blob_gas_used: blobGasUsed,
                            blob_fee_eth: parseFloat(blobFeeEth.toFixed(6)),
                            source: 'dune'
                        };
                    }).filter(r => r.blob_count > 0);
                    
                    // ì˜¤ëŠ˜ ë¶ˆì™„ì „ ë°ì´í„°ë§Œ ì œì™¸ (ì–´ì œê¹Œì§€ëŠ” í¬í•¨)
                    const today = new Date().toISOString().split('T')[0];
                    const validRecords = records.filter(r => r.date < today);
                    
                    log(`  ğŸ“Š Valid records: ${validRecords.length} (excluded ${records.length - validRecords.length} recent incomplete)`, 'info');
                    
                    if (validRecords.length === 0) {
                        log('  âš ï¸ No valid records to save', 'warn');
                        return 0;
                    }
                    
                    // 4. Supabaseì— ì €ì¥
                    const { error } = await batchUpsert('historical_blob_data', validRecords);
                    if (error) {
                        log(`  âŒ Save error: ${error.message}`, 'error');
                        return 0;
                    }
                    
                    // ìƒ˜í”Œ ì¶œë ¥
                    const lastRecords = validRecords.slice(-3);
                    lastRecords.forEach(r => {
                        log(`  ğŸ“Š ${r.date}: ${r.blob_count.toLocaleString()} blobs, ${r.blob_fee_eth.toFixed(2)} ETH`, 'info');
                    });
                    
                    log(`  âœ… Blob data: ${validRecords.length} records saved from Dune`, 'success');
                    return validRecords.length;
                    
                } catch (e) {
                    log(`  âŒ Dune API error: ${e.message}`, 'error');
                    return 0;
                }
            },

            // 18. Lending TVL - HAS source
            async lending_tvl() {
                const data = await fetchJSON('https://api.llama.fi/v2/historicalChainTvl/Ethereum');
                if (!data) return 0;
                const cutoff = Date.now() / 1000 - (1095 * 86400);
                const records = data.filter(d => d.date > cutoff && d.tvl > 0).map(d => ({
                    date: new Date(d.date * 1000).toISOString().split('T')[0],
                    timestamp: d.date * 1000,
                    total_tvl: parseFloat((d.tvl * 0.5).toFixed(2)),
                    source: 'defillama'
                }));
                const { error } = await batchUpsert('historical_lending_tvl', records);
                if (error) log(`  âŒ ${error.message}`, 'error');
                return error ? 0 : records.length;
            },

            // 19. Daily Issuance - Calculate from staking data
            async daily_issuance() {
                log('  ğŸ” Fetching Daily Issuance data...', 'info');
                
                // ê¸°ì¡´ ë°ì´í„° í™•ì¸
                const { data: existingData } = await sb.from('historical_daily_issuance')
                    .select('date, daily_issuance')
                    .order('date', { ascending: false })
                    .limit(1200);
                
                const existingDates = new Set(existingData?.filter(d => d.daily_issuance > 0).map(d => d.date) || []);
                log(`  ğŸ“‹ Existing daily_issuance records: ${existingDates.size}`, 'info');
                
                // staking í…Œì´ë¸”ì—ì„œ ìµœì‹  ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
                const { data: stakingData } = await sb.from('historical_staking')
                    .select('date, total_staked_eth, avg_apr')
                    .order('date', { ascending: false })
                    .limit(30);
                
                if (!stakingData || stakingData.length === 0) {
                    log('  âŒ No staking data available', 'error');
                    return 0;
                }
                
                let newRecords = 0;
                
                for (const staking of stakingData) {
                    // ì´ë¯¸ ìˆëŠ” ë‚ ì§œëŠ” ê±´ë„ˆë›°ê¸°
                    if (existingDates.has(staking.date)) continue;
                    
                    const stakedEth = staking.total_staked_eth || 0;
                    const apr = staking.avg_apr || 3.5;
                    
                    if (stakedEth < 1000000) continue; // ìµœì†Œ 1M ETH
                    
                    // Daily Issuance = Total Staked ETH Ã— APR / 365
                    const dailyIssuance = (stakedEth * (apr / 100)) / 365;
                    
                    log(`  ğŸ“Š ${staking.date}: ${(stakedEth/1e6).toFixed(1)}M ETH Ã— ${apr.toFixed(2)}% APR / 365 = ${dailyIssuance.toFixed(0)} ETH/day`, 'info');
                    
                    if (dailyIssuance >= 500 && dailyIssuance <= 5000) {
                        const { error } = await batchUpsert('historical_daily_issuance', [{
                            date: staking.date,
                            daily_issuance: parseFloat(dailyIssuance.toFixed(2)),
                            source: 'calculated_from_staking'
                        }]);
                        
                        if (!error) {
                            newRecords++;
                        }
                    }
                }
                
                if (newRecords > 0) {
                    log(`  âœ… Added ${newRecords} new daily_issuance records`, 'success');
                    return newRecords;
                }
                
                log(`  ğŸ“‹ All dates already have data`, 'success');
                return existingDates.size > 1000 ? -1 : 0;
            },

            // 20. Volatility - HAS source
            async volatility() {
                // ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì „ì²´ ë°ì´í„° ê°€ì ¸ì™€ì„œ ê³„ì‚°
                const { data: prices } = await sb.from('historical_eth_price').select('date, close').order('date', { ascending: true });
                if (!prices || prices.length < 30) return 0;
                
                log(`  ğŸ“Š Got ${prices.length} price records`, 'info');
                
                const records = [];
                // i = 29ë¶€í„° ì‹œì‘ (30ì¼ ìœˆë„ìš° í•„ìš”)
                for (let i = 29; i < prices.length; i++) {
                    const window = prices.slice(i - 29, i + 1); // 30ì¼ ìœˆë„ìš°
                    const returns = [];
                    for (let j = 1; j < window.length; j++) {
                        if (window[j-1].close > 0) {
                            returns.push(Math.log(window[j].close / window[j-1].close));
                        }
                    }
                    if (returns.length < 20) continue; // ìµœì†Œ 20ì¼ ë°ì´í„° í•„ìš”
                    
                    const mean = returns.reduce((a, b) => a + b, 0) / returns.length;
                    const variance = returns.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / returns.length;
                    const volatility = Math.sqrt(variance * 365) * 100;
                    
                    if (volatility > 0 && volatility < 500) { // í•©ë¦¬ì ì¸ ë²”ìœ„ ì²´í¬
                        records.push({ 
                            date: prices[i].date, 
                            timestamp: Date.now(), 
                            volatility_30d: parseFloat(volatility.toFixed(2)), 
                            source: 'calculated' 
                        });
                    }
                }
                
                log(`  ğŸ“Š Calculated ${records.length} volatility records`, 'info');
                if (records.length > 0) {
                    log(`  ğŸ“… Latest: ${records[records.length-1].date} = ${records[records.length-1].volatility_30d}%`, 'info');
                }
                
                const { error } = await batchUpsert('historical_volatility', records);
                if (error) log(`  âŒ ${error.message}`, 'error');
                return error ? 0 : records.length;
            },

            // 21. NVT - Market Cap / On-chain Transaction Volume (Dune API)
            // NVT = Market Cap / Daily On-chain TX Volume (USD)
            // Uses L1 Total Volume query (6386589) for eth_volume_usd
            async nvt() {
                log('  ğŸ” Fetching NVT data...', 'info');
                log(`  ğŸ“¡ Using L1 Total Volume Query ID: ${DUNE_L1_TOTAL_VOLUME_QUERY_ID}`, 'info');
                
                // Get ETH prices first
                const { data: prices } = await sb.from('historical_eth_price')
                    .select('date, close')
                    .order('date', { ascending: false })
                    .limit(1100);
                
                if (!prices || prices.length === 0) {
                    log('  âŒ No price data available', 'error');
                    return 0;
                }
                
                const priceMap = new Map(prices.map(p => [p.date, parseFloat(p.close)]));
                const baseSupply = 120000000;
                
                // Try Dune API for accurate tx volume (using L1 Total Volume)
                if (DUNE_API_KEY) {
                    try {
                        log('  ğŸ“¡ Fetching TX volume from Dune API (L1 Total Volume)...', 'info');
                        
                        // Paginate through all results
                        let allRows = [];
                        let offset = 0;
                        const pageSize = 1000;
                        
                        while (true) {
                            const response = await fetch(`https://api.dune.com/api/v1/query/${DUNE_L1_TOTAL_VOLUME_QUERY_ID}/results?limit=${pageSize}&offset=${offset}`, {
                                headers: { 'X-Dune-API-Key': DUNE_API_KEY }
                            });
                            
                            if (!response.ok) break;
                            
                            const data = await response.json();
                            const rows = data.result?.rows || [];
                            
                            if (rows.length === 0) break;
                            
                            allRows = allRows.concat(rows);
                            log(`  ğŸ“Š Fetched ${rows.length} rows (total: ${allRows.length})`, 'info');
                            
                            if (rows.length < pageSize) break; // Last page
                            offset += pageSize;
                        }
                        
                        if (allRows.length > 0) {
                            log(`  ğŸ“Š Got ${allRows.length} TX volume records from Dune`, 'info');
                            
                            const records = [];
                            for (const row of allRows) {
                                let dateStr = row.date;
                                if (typeof dateStr === 'string' && dateStr.includes(' ')) {
                                    dateStr = dateStr.split(' ')[0];
                                }
                                
                                const price = priceMap.get(dateStr);
                                if (!price) continue;
                                
                                // Use eth_volume_usd from L1 Total Volume query
                                const txVolumeUsd = parseFloat(row.eth_volume_usd) || 0;
                                if (txVolumeUsd <= 0) continue;
                                
                                const txVolumeEth = txVolumeUsd / price;
                                const mcap = price * baseSupply;
                                const nvt = mcap / txVolumeUsd;
                                
                                records.push({
                                    date: dateStr,
                                    timestamp: new Date(dateStr).getTime(),
                                    nvt_ratio: parseFloat(nvt.toFixed(2)),
                                    market_cap: parseFloat(mcap.toFixed(2)),
                                    tx_volume_usd: parseFloat(txVolumeUsd.toFixed(2)),
                                    tx_volume_eth: parseFloat(txVolumeEth.toFixed(2)),
                                    source: 'dune'
                                });
                            }
                            
                            if (records.length > 0) {
                                // Sort by date descending
                                records.sort((a, b) => b.date.localeCompare(a.date));
                                
                                // Filter incomplete data: if latest day's volume < 30% of 7-day avg, exclude it
                                if (records.length >= 8) {
                                    const latestVol = records[0].tx_volume_usd;
                                    const prev7Avg = records.slice(1, 8).reduce((sum, r) => sum + r.tx_volume_usd, 0) / 7;
                                    if (prev7Avg > 0 && latestVol < prev7Avg * 0.3) {
                                        log(`  âš ï¸ Excluding incomplete data: ${records[0].date} (${(latestVol/1e9).toFixed(2)}B < 30% of avg ${(prev7Avg/1e9).toFixed(2)}B)`, 'warn');
                                        records.shift(); // Remove latest incomplete record
                                    }
                                }
                                
                                // Show sample calculations
                                const samples = records.slice(0, 3); // Show latest 3 after filtering
                                samples.forEach(r => {
                                    log(`  ğŸ“Š ${r.date}: NVT=${r.nvt_ratio.toFixed(1)}, Vol=${(r.tx_volume_usd/1e9).toFixed(2)}B`, 'info');
                                });
                                
                                const { error } = await batchUpsert('historical_nvt', records);
                                if (error) {
                                    log(`  âŒ Save error: ${error.message}`, 'error');
                                    return 0;
                                }
                                    
                                log(`  âœ… NVT: ${records.length} records saved from Dune`, 'success');
                                return records.length;
                            }
                        }
                        
                        log('  âš ï¸ Dune API returned no data, falling back...', 'warn');
                    } catch (e) {
                        log(`  âš ï¸ Dune API error: ${e.message}, falling back...`, 'warn');
                    }
                } else {
                    log('  âš ï¸ No Dune API key, using fee-based estimation...', 'warn');
                }
                
                // Fallback: fee-based estimation (less accurate)
                const { data: fees } = await sb.from('historical_protocol_fees')
                    .select('date, fees')
                    .order('date', { ascending: false })
                    .limit(1100);
                
                if (!fees) return 0;
                
                const feeMap = new Map(fees.map(f => [f.date, parseFloat(f.fees || 0)]));
                const records = [];
                
                for (const p of prices) {
                    const dailyFees = feeMap.get(p.date);
                    if (!dailyFees || dailyFees <= 0) continue;
                    
                    const mcap = p.close * baseSupply;
                    // Improved scale factor based on Dune data analysis
                    // Actual tx volume â‰ˆ fees Ã— 15000 (was 3000)
                    const txVolumeProxy = dailyFees * 15000;
                    let nvt = mcap / txVolumeProxy;
                    
                    records.push({ 
                        date: p.date, 
                        timestamp: Date.now(), 
                        nvt_ratio: parseFloat(nvt.toFixed(2)), 
                        market_cap: mcap, 
                        tx_volume_usd: txVolumeProxy, 
                        source: 'estimated' 
                    });
                }
                
                const { error } = await batchUpsert('historical_nvt', records);
                if (error) log(`  âŒ ${error.message}`, 'error');
                log(`  âœ… NVT: ${records.length} records (fee-based estimation)`, 'success');
                return error ? 0 : records.length;
            },

            // 22. Transactions - Etherscan V2 with fallback
            async transactions() {
                // growthepie API - ì‹¤ì œ íŠ¸ëœì­ì…˜ ìˆ˜
                log('  ğŸ” Fetching ETH transactions from growthepie...', 'info');
                const data = await fetchJSON('https://api.growthepie.xyz/v1/export/txcount.json');
                
                if (!data || !Array.isArray(data)) {
                    log('  âŒ growthepie API failed', 'error');
                    return 0;
                }
                
                // Ethereum mainnet ë°ì´í„°ë§Œ í•„í„°
                const ethRecords = data
                    .filter(d => d.origin_key === 'ethereum' && d.metric_key === 'txcount' && d.value > 0)
                    .map(d => ({
                        date: d.date,
                        tx_count: Math.floor(d.value),
                        source: 'growthepie'
                    }));
                
                log(`  ğŸ“¦ Got ${ethRecords.length} ETH mainnet tx records`, 'info');
                
                if (ethRecords.length === 0) return 0;
                
                const { error } = await batchUpsert('historical_transactions', ethRecords);
                if (error) log(`  âŒ ${error.message}`, 'error');
                return error ? 0 : ethRecords.length;
            },

            // 23. L2 Transactions - growthepie API (ì‹¤ì œ ë°ì´í„°)
            async l2_transactions() {
                log('  ğŸ” Fetching L2 transactions from growthepie...', 'info');
                const data = await fetchJSON('https://api.growthepie.xyz/v1/export/txcount.json');
                
                if (!data || !Array.isArray(data)) {
                    log('  âŒ growthepie API failed', 'error');
                    return 0;
                }
                
                // ëª¨ë“  L2 ì²´ì¸ ìˆ˜ì§‘ (ethereum L1ë§Œ ì œì™¸)
                const excludeChains = ['ethereum'];
                
                const l2Records = data
                    .filter(d => !excludeChains.includes(d.origin_key) && d.metric_key === 'txcount' && d.value > 0)
                    .map(d => ({
                        date: d.date,
                        chain: d.origin_key.toLowerCase(),  // ì†Œë¬¸ìë¡œ í†µì¼
                        tx_count: Math.floor(d.value),
                        source: 'growthepie'
                    }));
                
                // ì²´ì¸ë³„ ì¹´ìš´íŠ¸ ë¡œê·¸
                const chainCounts = {};
                l2Records.forEach(r => {
                    chainCounts[r.chain] = (chainCounts[r.chain] || 0) + 1;
                });
                
                log(`  ğŸ“¦ Got ${l2Records.length} L2 tx records:`, 'info');
                Object.entries(chainCounts).forEach(([chain, count]) => {
                    log(`    â€¢ ${chain}: ${count} days`, 'info');
                });
                
                if (l2Records.length === 0) return 0;
                
                const { error } = await batchUpsert('historical_l2_transactions', l2Records, 'date,chain');
                if (error) log(`  âŒ ${error.message}`, 'error');
                return error ? 0 : l2Records.length;
            },

            // 24. L2 Addresses - HAS source
            // 24. L2 Active Addresses - Dune API (ì •í™•í•œ ì˜¨ì²´ì¸ ë°ì´í„°)
            async l2_addresses() {
                log('  ğŸ” Fetching L2 Active Addresses...', 'info');
                
                if (!DUNE_API_KEY) {
                    log('  âš ï¸ No Dune API key - falling back to tx-based estimation', 'warn');
                    const { data: txs } = await sb.from('historical_l2_transactions')
                        .select('date, chain, tx_count').order('date', { ascending: false }).limit(8000);
                    if (!txs?.length) return 0;
                    const records = txs.map(t => ({
                        date: t.date, timestamp: Date.now(), chain: t.chain,
                        active_addresses: Math.floor(t.tx_count * 0.3),
                        source: 'estimated'
                    }));
                    const { error } = await batchUpsert('historical_l2_addresses', records, 'date,chain');
                    return error ? 0 : records.length;
                }
                
                try {
                    log('  ğŸ“¡ Fetching from Dune API...', 'info');
                    
                    // Paginate through all results
                    let allRows = [];
                    let offset = 0;
                    const pageSize = 1000;
                    
                    while (true) {
                        const response = await fetch(`https://api.dune.com/api/v1/query/${DUNE_L2_ACTIVE_ADDR_QUERY_ID}/results?limit=${pageSize}&offset=${offset}`, {
                            headers: { 'X-Dune-API-Key': DUNE_API_KEY }
                        });
                        
                        if (!response.ok) break;
                        
                        const data = await response.json();
                        const rows = data.result?.rows || [];
                        
                        if (rows.length === 0) break;
                        
                        allRows = allRows.concat(rows);
                        log(`  ğŸ“Š Fetched ${rows.length} rows (total: ${allRows.length})`, 'info');
                        
                        if (rows.length < pageSize) break;
                        offset += pageSize;
                    }
                    
                    if (allRows.length > 0) {
                        log(`  ğŸ“Š Got ${allRows.length} L2 Active Addresses records from Dune`, 'info');
                        
                        const records = allRows.map(row => {
                            let dateStr = row.date;
                            if (typeof dateStr === 'string' && dateStr.includes(' ')) {
                                dateStr = dateStr.split(' ')[0];
                            }
                            
                            return {
                                date: dateStr,
                                timestamp: new Date(dateStr).getTime(),
                                chain: row.chain,
                                active_addresses: parseInt(row.active_addresses) || 0,
                                source: 'dune'
                            };
                        }).filter(r => r.active_addresses > 0);
                        
                        // Show samples by chain
                        const chains = [...new Set(records.map(r => r.chain))];
                        log(`  ğŸ“Š Chains: ${chains.join(', ')}`, 'info');
                        
                        const { error } = await batchUpsert('historical_l2_addresses', records, 'date,chain');
                        if (error) {
                            log(`  âŒ Save error: ${error.message}`, 'error');
                            return 0;
                        }
                        
                        log(`  âœ… L2 Active Addresses: ${records.length} records saved from Dune`, 'success');
                        return records.length;
                    }
                    
                    log('  âš ï¸ No data from Dune', 'warn');
                    return 0;
                } catch (e) {
                    log(`  âŒ Dune API error: ${e.message}`, 'error');
                    return 0;
                }
            },

            // 25. Protocol TVL - HAS source, chain column (optimized)
            async protocol_tvl() {
                const protocols = ['lido', 'aave', 'makerdao', 'uniswap-v2', 'uniswap-v3', 'uniswap-v4', 'eigenlayer'];
                const cutoff = Date.now() / 1000 - (1095 * 86400);
                let total = 0;
                
                for (const protocol of protocols) {
                    try {
                        const data = await fetchJSON(`https://api.llama.fi/protocol/${protocol}`);
                        if (!data?.tvl) {
                            log(`    âš ï¸ No data for ${protocol}`, 'warn');
                            continue;
                        }
                        
                        const seen = new Set();
                        const records = data.tvl
                            .filter(d => d.date > cutoff && d.totalLiquidityUSD > 0)
                            .map(d => ({
                                date: new Date(d.date * 1000).toISOString().split('T')[0],
                                timestamp: d.date * 1000,
                                protocol,
                                chain: 'Ethereum',
                                tvl: parseFloat(d.totalLiquidityUSD.toFixed(2)),
                                source: 'defillama'
                            }))
                            .filter(r => {
                                if (seen.has(r.date)) return false;
                                seen.add(r.date);
                                return true;
                            });
                        
                        log(`    ğŸ“¦ ${protocol}: ${records.length} records`, 'info');
                        
                        if (records.length > 0) {
                            // Batch upsert in chunks of 500 for speed
                            for (let i = 0; i < records.length; i += 500) {
                                const chunk = records.slice(i, i + 500);
                                const { error } = await sb.from('historical_protocol_tvl').upsert(chunk, { onConflict: 'date,protocol,chain' });
                                if (error) {
                                    log(`    âŒ ${protocol} chunk error: ${error.message}`, 'error');
                                    break;
                                }
                            }
                            total += records.length;
                        }
                    } catch (e) {
                        log(`    âš ï¸ ${protocol} error: ${e.message}`, 'warn');
                    }
                    await new Promise(r => setTimeout(r, 200));
                }
                return total;
            },

            // 26. Staking APR - HAS source
            async staking_apr() {
                log('  ğŸ” Fetching staking APR from DefiLlama...', 'info');
                const data = await fetchJSON('https://yields.llama.fi/chart/747c1d2a-c668-4682-b9f9-296708a3dd90');
                
                if (!data?.data || data.data.length === 0) {
                    log('  âš ï¸ DefiLlama yields API failed, using estimates', 'warn');
                    
                    // Fallback: Generate estimated APR data (3-4% range)
                    const today = new Date();
                    const records = [];
                    
                    for (let i = 0; i < 1095; i++) {
                        const date = new Date(today);
                        date.setDate(date.getDate() - i);
                        
                        // APR ì¶”ì„¸: 2022ë…„ ~5% â†’ 2025ë…„ ~3.5%
                        const daysFromStart = 1095 - i;
                        const progress = daysFromStart / 1095;
                        const baseApr = 5.0 - (1.5 * progress);
                        const variation = Math.sin(daysFromStart * 0.05) * 0.3;
                        
                        records.push({
                            date: date.toISOString().split('T')[0],
                            timestamp: date.getTime(),
                            lido_apr: parseFloat((baseApr + variation).toFixed(2)),
                            source: 'estimated'
                        });
                    }
                    
                    const { error } = await batchUpsert('historical_staking_apr', records);
                    if (error) log(`  âŒ ${error.message}`, 'error');
                    // API ì‹¤íŒ¨í•´ì„œ estimate ì‚¬ìš© â†’ 0 ë°˜í™˜ (failed)
                    return 0;
                }
                
                log(`  ğŸ“¦ Got ${data.data.length} records from DefiLlama`, 'info');
                const records = data.data.filter(d => d.apy > 0).map(d => ({
                    date: d.timestamp.split('T')[0],
                    timestamp: new Date(d.timestamp).getTime(),
                    lido_apr: parseFloat(d.apy.toFixed(2)),
                    source: 'defillama'
                }));
                const { error } = await batchUpsert('historical_staking_apr', records);
                if (error) log(`  âŒ ${error.message}`, 'error');
                return error ? 0 : records.length;
            },

            // 27. ETH in DeFi - HAS source
            async eth_in_defi() {
                const { data: tvl } = await sb.from('historical_ethereum_tvl').select('date, tvl').order('date', { ascending: false }).limit(1100);
                const { data: prices } = await sb.from('historical_eth_price').select('date, close').order('date', { ascending: false }).limit(1100);
                if (!tvl || !prices) return 0;
                const priceMap = new Map(prices.map(p => [p.date, p.close]));
                const records = tvl.map(t => {
                    const price = priceMap.get(t.date) || 3000;
                    return { date: t.date, timestamp: Date.now(), eth_locked: parseFloat((t.tvl * 0.3 / price).toFixed(2)), source: 'estimated' };
                }).filter(r => r.eth_locked > 0);
                const { error } = await batchUpsert('historical_eth_in_defi', records);
                if (error) log(`  âŒ ${error.message}`, 'error');
                return error ? 0 : records.length;
            },

            // 28. Global MCap - CoinGecko days=365 (ë¬´ë£Œ ìµœëŒ€)
            async global_mcap() {
                log(`  ğŸ” Fetching global mcap from CoinGecko...`, 'info');
                
                const [btcData, globalData] = await Promise.all([
                    fetchJSON('https://api.coingecko.com/api/v3/coins/bitcoin/market_chart?vs_currency=usd&days=365&interval=daily'),
                    fetchJSON('https://api.coingecko.com/api/v3/global')
                ]);
                
                if (!btcData?.market_caps || !globalData?.data) {
                    log('  âŒ Failed to get CoinGecko data', 'error');
                    return 0;
                }
                
                const btcDominance = globalData.data.market_cap_percentage.btc / 100;
                
                const records = [];
                const seenDates = new Set();
                
                for (const [timestamp, btcMcap] of btcData.market_caps) {
                    const date = new Date(timestamp).toISOString().split('T')[0];
                    if (seenDates.has(date)) continue;
                    seenDates.add(date);
                    
                    const totalMcap = btcMcap / btcDominance;
                    
                    records.push({
                        date,
                        timestamp,
                        total_mcap: totalMcap,
                        source: 'coingecko'
                    });
                }
                
                if (records.length === 0) {
                    log('  âŒ No records generated', 'error');
                    return 0;
                }
                
                log(`  ğŸ“¦ Got ${records.length} days from CoinGecko`, 'info');
                const { error } = await batchUpsert('historical_global_mcap', records);
                if (error) log(`  âŒ ${error.message}`, 'error');
                return error ? 0 : records.length;
            },

            // 29. DEX by Protocol - HAS source
            async dex_by_protocol() {
                const protocols = ['uniswap-v2', 'uniswap-v3', 'uniswap-v4', 'curve-dex', 'balancer'];
                log(`  ğŸ” Fetching volume for ${protocols.length} DEX protocols...`, 'info');
                let total = 0;
                for (const protocol of protocols) {
                    const data = await fetchJSON(`https://api.llama.fi/summary/dexs/${protocol}?dataType=dailyVolume`);
                    if (!data?.totalDataChart) {
                        log(`    âš ï¸ ${protocol}: No data`, 'warn');
                        continue;
                    }
                    const records = data.totalDataChart.filter(d => d[1] > 0).map(d => ({
                        date: new Date(d[0] * 1000).toISOString().split('T')[0],
                        timestamp: d[0] * 1000, protocol,
                        volume: parseFloat(d[1].toFixed(2)),
                        source: 'defillama'
                    }));
                    if (records.length > 0) {
                        log(`    âœ“ ${protocol}: ${records.length} days`, 'info');
                        const { error } = await batchUpsert('historical_dex_by_protocol', records, 'date,protocol');
                        if (!error) total += records.length;
                    }
                    await new Promise(r => setTimeout(r, 200));
                }
                return total;
            },

            // 30. Network Stats - HAS source
            async network_stats() {
                const data = await fetchJSON('https://beaconcha.in/api/v1/epoch/latest');
                if (!data?.data) return 0;
                const today = new Date().toISOString().split('T')[0];
                const records = [{ date: today, timestamp: Date.now(), block_count: 7200, avg_block_time: 12, source: 'beaconchain' }];
                const { error } = await batchUpsert('historical_network_stats', records);
                if (error) log(`  âŒ ${error.message}`, 'error');
                return error ? 0 : 1;
            },

            // REMOVED: l2_native_transfer() function
            // L2 ETH Transfer now uses native_volume_usd from historical_l2_total_volume table
            // Query ID 6352386 is no longer needed

            // L1 Total Volume - Dune API (ETH + all ERC-20 tokens)
            async l1_total_volume() {
                log('  ğŸ” Fetching L1 Total Volume (ETH + all tokens)...', 'info');
                log(`  ğŸ“¡ Query ID: ${DUNE_L1_TOTAL_VOLUME_QUERY_ID}`, 'info');
                
                if (!DUNE_API_KEY) {
                    log('  âš ï¸ No Dune API key', 'warn');
                    return 0;
                }
                
                try {
                    log('  ğŸ“¡ Fetching from Dune API...', 'info');
                    const allRows = await fetchDuneWithRefresh(DUNE_L1_TOTAL_VOLUME_QUERY_ID, 'date');
                    
                    if (allRows && allRows.length > 0) {
                        log(`  ğŸ“Š Got ${allRows.length} L1 Total Volume records from Dune`, 'info');
                        
                        const records = allRows.map(row => ({
                            date: row.date?.split(' ')[0] || row.date,
                            eth_volume_usd: parseFloat(row.eth_volume_usd) || 0,
                            token_volume_usd: parseFloat(row.token_volume_usd) || 0,
                            total_volume_usd: parseFloat(row.total_volume_usd) || 0,
                            updated_at: new Date().toISOString()
                        })).filter(r => r.date && r.total_volume_usd > 0);
                        
                        if (records.length > 0) {
                            const { error } = await batchUpsert('historical_l1_total_volume', records, 'date');
                            if (error) {
                                log(`  âŒ Supabase error: ${error.message}`, 'error');
                                return 0;
                            }
                        }
                        
                        log(`  âœ… L1 Total Volume: ${records.length} records saved from Dune`, 'success');
                        return records.length;
                    }
                    
                    log('  âš ï¸ No data from Dune', 'warn');
                    return 0;
                } catch (e) {
                    log(`  âŒ Dune API error: ${e.message}`, 'error');
                    return 0;
                }
            },

            // L2 Total Volume - Dune API (Native + all tokens, 8 chains)
            async l2_total_volume() {
                log('  ğŸ” Fetching L2 Total Volume (8 chains, Native + all tokens)...', 'info');
                log(`  ğŸ“¡ Query ID: ${DUNE_L2_TOTAL_VOLUME_QUERY_ID}`, 'info');
                
                if (!DUNE_API_KEY) {
                    log('  âš ï¸ No Dune API key', 'warn');
                    return 0;
                }
                
                try {
                    log('  ğŸ“¡ Fetching from Dune API (pagination)...', 'info');
                    const pageSize = 10000;
                    let offset = 0;
                    let allRows = [];
                    let hasMore = true;
                    
                    while (hasMore) {
                        const response = await fetch(`https://api.dune.com/api/v1/query/${DUNE_L2_TOTAL_VOLUME_QUERY_ID}/results?limit=${pageSize}&offset=${offset}`, {
                            headers: { 'X-Dune-API-Key': DUNE_API_KEY }
                        });
                        
                        if (!response.ok) throw new Error(`HTTP ${response.status}`);
                        
                        const data = await response.json();
                        const rows = data.result?.rows || [];
                        allRows = allRows.concat(rows);
                        
                        log(`  ğŸ“Š Fetched ${rows.length} rows (total: ${allRows.length})`, 'info');
                        
                        if (rows.length < pageSize) {
                            hasMore = false;
                        } else {
                            offset += pageSize;
                        }
                    }
                    
                    if (allRows && allRows.length > 0) {
                        log(`  ğŸ“Š Got ${allRows.length} L2 Total Volume records from Dune`, 'info');
                        
                        const records = allRows.map(row => ({
                            date: row.date?.split(' ')[0] || row.date,
                            chain: row.chain,
                            native_volume_usd: parseFloat(row.native_volume_usd) || 0,
                            token_volume_usd: parseFloat(row.token_volume_usd) || 0,
                            total_volume_usd: parseFloat(row.total_volume_usd) || 0,
                            updated_at: new Date().toISOString()
                        })).filter(r => r.date && r.chain && r.total_volume_usd > 0);
                        
                        if (records.length > 0) {
                            const { error } = await batchUpsert('historical_l2_total_volume', records, 'date,chain');
                            if (error) {
                                log(`  âŒ Supabase error: ${error.message}`, 'error');
                                return 0;
                            }
                        }
                        
                        log(`  âœ… L2 Total Volume: ${records.length} records saved from Dune`, 'success');
                        return records.length;
                    }
                    
                    log('  âš ï¸ No data from Dune', 'warn');
                    return 0;
                } catch (e) {
                    log(`  âŒ Dune API error: ${e.message}`, 'error');
                    return 0;
                }
            },

            // Bridge Volume - Dune API (Settlement Layer ê³„ì‚°ìš©)
            async bridge_volume() {
                log('  ğŸ” Fetching Bridge Volume...', 'info');
                log(`  ğŸ“¡ Query ID: ${DUNE_BRIDGE_VOLUME_QUERY_ID}`, 'info');
                
                if (!DUNE_API_KEY) {
                    log('  âš ï¸ No Dune API key', 'warn');
                    return 0;
                }
                
                try {
                    log('  ğŸ“¡ Fetching from Dune API...', 'info');
                    
                    // Paginate through all results
                    let allRows = [];
                    let offset = 0;
                    const pageSize = 1000;
                    
                    while (true) {
                        const response = await fetch(`https://api.dune.com/api/v1/query/${DUNE_BRIDGE_VOLUME_QUERY_ID}/results?limit=${pageSize}&offset=${offset}`, {
                            headers: { 'X-Dune-API-Key': DUNE_API_KEY }
                        });
                        
                        if (!response.ok) break;
                        
                        const data = await response.json();
                        const rows = data.result?.rows || [];
                        
                        // Debug: show first row columns
                        if (rows.length > 0 && offset === 0) {
                            log(`  ğŸ” Sample row keys: ${Object.keys(rows[0]).join(', ')}`, 'info');
                            log(`  ğŸ” Sample row: ${JSON.stringify(rows[0])}`, 'info');
                        }
                        
                        if (rows.length === 0) break;
                        
                        allRows = allRows.concat(rows);
                        log(`  ğŸ“Š Fetched ${rows.length} rows (total: ${allRows.length})`, 'info');
                        
                        if (rows.length < pageSize) break;
                        offset += pageSize;
                    }
                    
                    if (allRows.length > 0) {
                        log(`  ğŸ“Š Got ${allRows.length} Bridge Volume records from Dune`, 'info');
                        
                        const records = allRows.map(row => {
                            let dateStr = row.date || row.day || row.block_date || '';
                            if (typeof dateStr === 'string' && dateStr.includes(' ')) {
                                dateStr = dateStr.split(' ')[0];
                            }
                            
                            // Try multiple column name variations
                            const volume = parseFloat(
                                row.bridge_volume_eth || 
                                row.volume_eth ||
                                row.eth_volume ||
                                row.volume ||
                                row.total_volume ||
                                0
                            );
                            
                            return {
                                date: dateStr,
                                timestamp: new Date(dateStr).getTime(),
                                chain: row.chain || row.l2_name || row.network || 'unknown',
                                bridge_volume_eth: volume,
                                source: 'dune'
                            };
                        }).filter(r => r.bridge_volume_eth > 0);
                        
                        // Show samples by chain
                        const chains = [...new Set(records.map(r => r.chain))];
                        log(`  ğŸ“Š Chains: ${chains.join(', ')}`, 'info');
                        
                        if (records.length > 0) {
                            log(`  ğŸ“… Sample: ${records[0].date} ${records[0].chain} = ${records[0].bridge_volume_eth.toFixed(2)} ETH`, 'info');
                        }
                        
                        const { error } = await batchUpsert('historical_bridge_volume', records, 'date,chain');
                        if (error) {
                            log(`  âŒ Save error: ${error.message}`, 'error');
                            return 0;
                        }
                        
                        log(`  âœ… Bridge Volume: ${records.length} records saved from Dune`, 'success');
                        return records.length;
                    }
                    
                    log('  âš ï¸ No data from Dune', 'warn');
                    return 0;
                } catch (e) {
                    log(`  âŒ Dune API error: ${e.message}`, 'error');
                    return 0;
                }
            },

            // L2 DEX Volume - Dune API (Daily DEX trading volume on L2s)
            async l2_dex_volume() {
                log('  ğŸ” Fetching L2 DEX Volume...', 'info');
                
                const DUNE_L2_DEX_VOLUME_QUERY_ID = 6395472;
                
                try {
                    const allRows = await fetchDuneWithRefresh(DUNE_L2_DEX_VOLUME_QUERY_ID, 'date');
                    if (allRows.length > 0) {
                        log(`  ğŸ“Š Got ${allRows.length} L2 DEX Volume records`, 'info');
                        
                        const records = allRows.map(row => {
                            let dateStr = row.date;
                            if (typeof dateStr === 'string' && dateStr.includes(' ')) {
                                dateStr = dateStr.split(' ')[0];
                            }
                            if (typeof dateStr === 'string' && dateStr.includes('T')) {
                                dateStr = dateStr.split('T')[0];
                            }
                            
                            return {
                                date: dateStr,
                                blockchain: row.blockchain || 'unknown',
                                dex_volume_usd: parseFloat(row.dex_volume_usd) || 0
                            };
                        }).filter(r => r.dex_volume_usd > 0);
                        
                        if (records.length > 0) {
                            log(`  ğŸ“… Sample: ${records[0].date} ${records[0].blockchain} = $${(records[0].dex_volume_usd / 1e6).toFixed(2)}M`, 'info');
                        }
                        
                        const { error } = await batchUpsert('historical_l2_dex_volume', records, 'date,blockchain');
                        if (error) {
                            log(`  âŒ Save error: ${error.message}`, 'error');
                            return 0;
                        }
                        
                        log(`  âœ… L2 DEX Volume: ${records.length} records saved from Dune`, 'success');
                        return records.length;
                    }
                    
                    log('  âš ï¸ No data from Dune', 'warn');
                    return 0;
                } catch (e) {
                    log(`  âŒ Dune API error: ${e.message}`, 'error');
                    return 0;
                }
            },

            // Bridge Total Volume - Dune API (ETH + ERC-20 tokens bridged to L2s)
            async bridge_total_volume() {
                log('  ğŸ” Fetching Bridge Total Volume...', 'info');
                
                const DUNE_BRIDGE_TOTAL_VOLUME_QUERY_ID = 6395474;
                
                try {
                    const allRows = await fetchDuneWithRefresh(DUNE_BRIDGE_TOTAL_VOLUME_QUERY_ID, 'date');
                    if (allRows.length > 0) {
                        log(`  ğŸ“Š Got ${allRows.length} Bridge Total Volume records`, 'info');
                        
                        const records = allRows.map(row => {
                            let dateStr = row.date;
                            if (typeof dateStr === 'string' && dateStr.includes(' ')) {
                                dateStr = dateStr.split(' ')[0];
                            }
                            if (typeof dateStr === 'string' && dateStr.includes('T')) {
                                dateStr = dateStr.split('T')[0];
                            }
                            
                            return {
                                date: dateStr,
                                destination_chain: row.destination_chain || 'unknown',
                                bridge_volume_usd: parseFloat(row.bridge_volume_usd) || 0
                            };
                        }).filter(r => r.bridge_volume_usd > 0);
                        
                        if (records.length > 0) {
                            log(`  ğŸ“… Sample: ${records[0].date} ${records[0].destination_chain} = $${(records[0].bridge_volume_usd / 1e6).toFixed(2)}M`, 'info');
                        }
                        
                        const { error } = await batchUpsert('historical_bridge_total_volume', records, 'date,destination_chain');
                        if (error) {
                            log(`  âŒ Save error: ${error.message}`, 'error');
                            return 0;
                        }
                        
                        log(`  âœ… Bridge Total Volume: ${records.length} records saved from Dune`, 'success');
                        return records.length;
                    }
                    
                    log('  âš ï¸ No data from Dune', 'warn');
                    return 0;
                } catch (e) {
                    log(`  âŒ Dune API error: ${e.message}`, 'error');
                    return 0;
                }
            },

            // Whale Transactions - Dune API (1000+ ETH transactions)
            async whale_tx() {
                log('  ğŸ” Fetching Whale Transactions...', 'info');
                
                const allRows = await fetchDuneWithRefresh(DUNE_WHALE_TX_QUERY_ID, 'date');
                if (allRows.length === 0) return 0;
                
                log(`  ğŸ“Š Got ${allRows.length} Whale TX records`, 'info');
                
                const records = allRows.map(row => {
                    let dateStr = row.date;
                    if (typeof dateStr === 'string' && dateStr.includes(' ')) {
                        dateStr = dateStr.split(' ')[0];
                    }
                    
                    return {
                        date: dateStr,
                        timestamp: new Date(dateStr).getTime(),
                        whale_tx_count: parseInt(row.whale_tx_count) || 0,
                        whale_volume_eth: parseFloat(row.whale_volume_eth) || 0,
                        source: 'dune'
                    };
                }).filter(r => r.whale_tx_count > 0);
                
                const { error } = await batchUpsert('historical_whale_tx', records, 'date');
                if (error) {
                    log(`  âŒ Save error: ${error.message}`, 'error');
                    return 0;
                }
                
                return records.length;
            },

            // MVRV Ratio - Dune API
            async mvrv_ratio() {
                log('  ğŸ” Fetching MVRV Ratio...', 'info');
                
                const allRows = await fetchDuneWithRefresh(DUNE_MVRV_QUERY_ID, 'day');
                if (allRows.length === 0) return 0;
                
                log(`  ğŸ“Š Got ${allRows.length} MVRV records`, 'info');
                
                const records = allRows.map(row => {
                    let dateStr = row.day || row.date;
                    if (typeof dateStr === 'string' && dateStr.includes(' ')) {
                        dateStr = dateStr.split(' ')[0];
                    }
                    
                    const mvrvPct = parseFloat(row.mvrv_proxy_pct) || 0;
                    const mvrvRatio = 1 + (mvrvPct / 100);
                    
                    return {
                        date: dateStr,
                        timestamp: new Date(dateStr).getTime(),
                        spot_price: parseFloat(row.spot_price) || 0,
                        realized_price: parseFloat(row.estimated_realized_price) || 0,
                        mvrv_ratio: mvrvRatio,
                        mvrv_pct: mvrvPct,
                        source: 'dune'
                    };
                }).filter(r => r.realized_price > 0);
                
                const { error } = await batchUpsert('historical_mvrv', records, 'date');
                if (error) {
                    log(`  âŒ Save error: ${error.message}`, 'error');
                    return 0;
                }
                
                return records.length;
            },

            // Stablecoin Volume - Dune API
            async stablecoin_volume() {
                const allRows = await fetchDuneWithRefresh(DUNE_STABLECOIN_VOL_QUERY_ID, 'block_date');
                if (allRows.length === 0) return 0;
                
                const records = allRows.map(row => {
                    let dateStr = row.block_date || row.day || row.date;
                    if (typeof dateStr === 'string' && dateStr.includes(' ')) {
                        dateStr = dateStr.split(' ')[0];
                    }
                    
                    return {
                        date: dateStr,
                        timestamp: new Date(dateStr).getTime(),
                        daily_volume: parseFloat(row.daily_volume_usd || row.total_volume || row.volume) || 0,
                        source: 'dune'
                    };
                }).filter(r => r.daily_volume > 0 && r.date);
                
                const { error } = await batchUpsert('historical_stablecoin_volume', records, 'date');
                if (error) {
                    log(`  âŒ ${error.message}`, 'error');
                    return 0;
                }
                
                return records.length;
            },

            // New Addresses - Dune API (first transaction from address)
            async new_addresses() {
                const allRows = await fetchDuneWithRefresh(DUNE_NEW_ADDR_QUERY_ID, 'date');
                if (allRows.length === 0) return 0;
                
                const records = allRows.map(row => {
                    let dateStr = row.date;
                    if (typeof dateStr === 'string' && dateStr.includes(' ')) {
                        dateStr = dateStr.split(' ')[0];
                    }
                    
                    return {
                        date: dateStr,
                        timestamp: new Date(dateStr).getTime(),
                        new_addresses: parseInt(row.new_addresses) || 0,
                        source: 'dune'
                    };
                }).filter(r => r.new_addresses > 0);
                
                const { error } = await batchUpsert('historical_new_addresses', records, 'date');
                if (error) {
                    log(`  âŒ ${error.message}`, 'error');
                    return 0;
                }
                
                return records.length;
            },
            
            async gas_price() {
                const allRows = await fetchDuneWithRefresh(DUNE_GAS_PRICE_QUERY_ID, 'block_date');
                if (allRows.length === 0) return 0;
                
                const records = allRows.map(row => {
                    let dateStr = row.block_date || row.date || row.day || '';
                    if (typeof dateStr === 'string') {
                        if (dateStr.includes(' ')) dateStr = dateStr.split(' ')[0];
                        else if (dateStr.includes('T')) dateStr = dateStr.split('T')[0];
                    }
                    
                    const gasPrice = parseFloat(
                        row.avg_gas_price_gwei || row.gas_price_gwei || row.avg_gas_price || row.gas_price || row.median_gas_price || 0
                    );
                    
                    // Use eth_burnt directly from Dune if available
                    const ethBurnt = parseFloat(row.eth_burnt || 0);
                    
                    return {
                        date: dateStr,
                        avg_gas_price_gwei: gasPrice,
                        gas_utilization: parseFloat(row.gas_utilization || row.utilization || 0),
                        transaction_count: parseInt(row.tx_count || row.transaction_count || row.txn_count || 0),
                        eth_burnt: ethBurnt > 0 ? parseFloat(ethBurnt.toFixed(2)) : null
                    };
                }).filter(r => r.date && r.avg_gas_price_gwei > 0);
                
                const { error } = await batchUpsert('historical_gas_burn', records, 'date');
                if (error) {
                    log(`  âŒ ${error.message}`, 'error');
                    return 0;
                }
                
                return records.length;
            }
        };

        async function collectOne(key) {
            const ds = DATASETS[key];
            log(`ğŸ“¥ ${ds.icon} ${ds.name}...`, 'info');
            try {
                const count = await collectors[key]();
                const expected = ds.expectedDays || 1095;
                const ratio = count / expected;
                lastCollectResult[key] = { count, expected, ratio, time: new Date() };
                
                if (count === -1) {
                    // skipì€ ë¡œê·¸ ì—†ì´
                } else if (count === 0) {
                    log(`  âŒ Failed`, 'error');
                } else if (ratio < 0.1) {
                    log(`  âš ï¸ ${count} (${(ratio*100).toFixed(0)}%)`, 'warn');
                } else {
                    log(`  âœ… ${count}`, 'success');
                }
            } catch (e) { 
                log(`  âŒ ${e.message}`, 'error'); 
                lastCollectResult[key] = { count: 0, expected: ds.expectedDays || 1095, ratio: 0, error: e.message, time: new Date() };
            }
            await loadDataStatus();
        }

        async function collectAll() {
            const el = document.getElementById('log');
            el.innerHTML = ''; // ë¡œê·¸ ì´ˆê¸°í™”
            log('ğŸš€ ë°ì´í„° ìˆ˜ì§‘ ì‹œì‘...', 'info');
            
            const keys = Object.keys(DATASETS);
            let ok = 0, fail = 0, skipped = 0;
            let currentPhase = 0;
            let phaseResults = [];
            lastCollectResult = {};
            
            for (let i = 0; i < keys.length; i++) {
                const key = keys[i];
                const ds = DATASETS[key];
                
                // Phase ë³€ê²½ ì‹œ ì´ì „ Phase ê²°ê³¼ ì¶œë ¥
                if (ds.phase && ds.phase !== currentPhase) {
                    if (currentPhase > 0 && phaseResults.length > 0) {
                        const phaseOk = phaseResults.filter(r => r.ok).length;
                        const phaseFail = phaseResults.filter(r => !r.ok).length;
                        log(`Phase ${currentPhase}: ${phaseOk}âœ“ ${phaseFail > 0 ? phaseFail + 'âœ—' : ''}`, phaseFail > 0 ? 'warn' : 'success');
                    }
                    currentPhase = ds.phase;
                    phaseResults = [];
                    log(`\nâ”â”â” Phase ${currentPhase} â”â”â”`, 'info');
                }
                
                if (ds.noCollect) {
                    skipped++;
                    ok++;
                    phaseResults.push({ key, ok: true });
                    continue;
                }
                
                // ì§„í–‰ í‘œì‹œ (í˜„ì¬ ì‘ì—…ë§Œ)
                document.getElementById('stats-total').textContent = `${i+1}/${keys.length}`;
                
                try {
                    const count = await Promise.race([
                        collectors[key](),
                        new Promise((_, rej) => setTimeout(() => rej(new Error('Timeout')), 300000))
                    ]);
                    
                    const expected = ds.expectedDays || 1095;
                    const ratio = count / expected;
                    lastCollectResult[key] = { count, expected, ratio, time: new Date() };
                    
                    if (count === -1) {
                        skipped++;
                        ok++;
                        phaseResults.push({ key, ok: true });
                    } else if (count === 0 || ratio < 0.1) {
                        // ì‹¤íŒ¨ë§Œ ìƒì„¸ ë¡œê·¸
                        log(`  âŒ ${ds.icon} ${ds.name}: ${count === 0 ? 'Failed' : count + ' (' + (ratio*100).toFixed(0) + '%)'}`, 'error');
                        fail++;
                        phaseResults.push({ key, ok: false });
                    } else {
                        ok++;
                        phaseResults.push({ key, ok: true, count });
                    }
                } catch (e) { 
                    log(`  âŒ ${ds.icon} ${ds.name}: ${e.message}`, 'error'); 
                    lastCollectResult[key] = { count: 0, expected: ds.expectedDays || 1095, ratio: 0, error: e.message, time: new Date() };
                    fail++; 
                    phaseResults.push({ key, ok: false });
                }
                await new Promise(r => setTimeout(r, 300));
            }
            
            // ë§ˆì§€ë§‰ Phase ê²°ê³¼
            if (phaseResults.length > 0) {
                const phaseOk = phaseResults.filter(r => r.ok).length;
                const phaseFail = phaseResults.filter(r => !r.ok).length;
                log(`Phase ${currentPhase}: ${phaseOk}âœ“ ${phaseFail > 0 ? phaseFail + 'âœ—' : ''}`, phaseFail > 0 ? 'warn' : 'success');
            }
            
            // ìµœì¢… ìš”ì•½
            log(`\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`, 'info');
            log(`ğŸ“Š ì™„ë£Œ: ${ok} ì„±ê³µ, ${fail} ì‹¤íŒ¨`, ok > fail ? 'success' : 'warn');
            
            await autoFillNewData();
            await loadDataStatus();
        }

        async function refreshData() { await loadDataStatus(); }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SCHEDULER LOGS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        async function refreshSchedulerLogs() {
            const tbody = document.getElementById('scheduler-logs-table');
            tbody.innerHTML = '<tr><td colspan="7" style="text-align: center; padding: 20px; color: var(--text-muted);">Loading...</td></tr>';
            
            try {
                // Get last 10 runs (not limited by date)
                const { data: logs, error } = await sb
                    .from('scheduler_logs')
                    .select('*')
                    .order('run_timestamp', { ascending: false })
                    .limit(10);
                
                if (error) {
                    console.error('Scheduler logs error:', error);
                    // Table might not exist yet
                    tbody.innerHTML = `<tr><td colspan="7" style="text-align: center; padding: 20px; color: var(--text-muted);">
                        No scheduler logs yet. Logs will appear after the first automated run.<br>
                        <small style="opacity: 0.7;">Schedule: Daily at KST 13:30 (UTC 04:30)</small>
                    </td></tr>`;
                    updateSchedulerSummary([]);
                    return;
                }
                
                if (!logs || logs.length === 0) {
                    tbody.innerHTML = `<tr><td colspan="7" style="text-align: center; padding: 20px; color: var(--text-muted);">
                        No scheduler runs yet.<br>
                        <small style="opacity: 0.7;">Schedule: Daily at KST 13:30 (UTC 04:30)</small>
                    </td></tr>`;
                    updateSchedulerSummary([]);
                    return;
                }
                
                updateSchedulerSummary(logs);
                
                tbody.innerHTML = logs.map(log => {
                    const statusClass = log.status === 'success' ? 'success' : log.status === 'partial' ? 'warning' : 'error';
                    const statusIcon = log.status === 'success' ? 'âœ…' : log.status === 'partial' ? 'âš ï¸' : 'âŒ';
                    const failedDatasets = log.failed_datasets ? JSON.parse(log.failed_datasets) : [];
                    const failedList = failedDatasets.length > 0 
                        ? `<span style="color: var(--error); font-size: 11px;">${failedDatasets.join(', ')}</span>`
                        : '<span style="color: var(--text-muted);">-</span>';
                    
                    // Format datetime with local timezone
                    const runTime = log.run_timestamp ? new Date(log.run_timestamp) : new Date(log.run_date);
                    const dateStr = runTime.toLocaleDateString('ko-KR', { month: 'short', day: 'numeric', weekday: 'short' });
                    const timeStr = runTime.toLocaleTimeString('ko-KR', { hour: '2-digit', minute: '2-digit' });
                    
                    // Trigger type badge
                    const triggerType = log.trigger_type || 'schedule';
                    const triggerIcon = triggerType === 'manual' ? 'ğŸ‘†' : 'ğŸ•';
                    const triggerColor = triggerType === 'manual' ? '#58a6ff' : '#8b949e';
                    const triggerLabel = triggerType === 'manual' ? 'Manual' : 'Scheduled';
                    
                    return `<tr>
                        <td style="white-space: nowrap;">
                            <div style="font-size: 12px;">${dateStr}</div>
                            <div style="font-size: 11px; color: var(--text-muted);">${timeStr}</div>
                        </td>
                        <td>
                            <span style="color: ${triggerColor}; font-size: 11px;">${triggerIcon} ${triggerLabel}</span>
                        </td>
                        <td><span class="badge ${statusClass}">${statusIcon} ${log.status}</span></td>
                        <td>${log.duration_seconds ? log.duration_seconds + 's' : '-'}</td>
                        <td style="color: var(--success);">${log.success_count || 0}</td>
                        <td style="color: ${log.failed_count > 0 ? 'var(--error)' : 'var(--text-muted)'};">${log.failed_count || 0}</td>
                        <td>${failedList}</td>
                    </tr>`;
                }).join('');
                
            } catch (e) {
                console.error('Failed to load scheduler logs:', e);
                tbody.innerHTML = '<tr><td colspan="7" style="text-align: center; padding: 20px; color: var(--error);">Failed to load logs</td></tr>';
            }
        }
        
        function updateSchedulerSummary(logs) {
            const total = logs.length;
            const success = logs.filter(l => l.status === 'success').length;
            const partial = logs.filter(l => l.status === 'partial').length;
            const failed = logs.filter(l => l.status === 'failed').length;
            
            // Format last run with timestamp
            let lastRun = '-';
            if (logs[0]) {
                const runTime = logs[0].run_timestamp ? new Date(logs[0].run_timestamp) : new Date(logs[0].run_date);
                lastRun = runTime.toLocaleDateString('ko-KR', { month: 'short', day: 'numeric' }) + ' ' +
                          runTime.toLocaleTimeString('ko-KR', { hour: '2-digit', minute: '2-digit' });
            }
            
            document.getElementById('sched-total').textContent = total;
            document.getElementById('sched-success').textContent = success;
            document.getElementById('sched-partial').textContent = partial;
            document.getElementById('sched-failed').textContent = failed;
            document.getElementById('sched-last').textContent = lastRun;
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // VERIFICATION - Compare cache vs live API
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const verifiers = {
            async eth_price() {
                const data = await fetchJSON('https://api.binance.com/api/v3/ticker/price?symbol=ETHUSDT');
                return data ? { live: parseFloat(data.price), label: 'ETH Price', unit: '$' } : null;
            },
            async ethereum_tvl() {
                const data = await fetchJSON('https://api.llama.fi/v2/chains');
                const eth = data?.find(c => c.name === 'Ethereum');
                return eth ? { live: eth.tvl, label: 'Ethereum TVL', unit: '$', format: 'tvl' } : null;
            },
            async fear_greed() {
                const data = await fetchJSON('https://api.alternative.me/fng/?limit=1');
                return data?.data?.[0] ? { live: parseInt(data.data[0].value), label: 'Fear & Greed', unit: '' } : null;
            },
            async eth_btc() {
                const data = await fetchJSON('https://api.binance.com/api/v3/ticker/price?symbol=ETHBTC');
                return data ? { live: parseFloat(data.price), label: 'ETH/BTC', unit: '', decimals: 6 } : null;
            },
            async eth_dominance() {
                const data = await fetchJSON('https://api.coingecko.com/api/v3/global');
                return data?.data ? { live: data.data.market_cap_percentage.eth, label: 'ETH Dominance', unit: '%', decimals: 2 } : null;
            },
            async global_mcap() {
                const data = await fetchJSON('https://api.coingecko.com/api/v3/global');
                return data?.data ? { live: data.data.total_market_cap.usd, label: 'Global MCap', unit: '$', format: 'tvl' } : null;
            },
            async staking_apr() {
                const data = await fetchJSON('https://yields.llama.fi/chart/747c1d2a-c668-4682-b9f9-296708a3dd90');
                const latest = data?.data?.[data.data.length - 1];
                return latest ? { live: latest.apy, label: 'Lido APR', unit: '%', decimals: 2 } : null;
            },
            async dex_volume() {
                const data = await fetchJSON('https://api.llama.fi/overview/dexs/ethereum?excludeTotalDataChart=true&excludeTotalDataChartBreakdown=true&dataType=dailyVolume');
                // total24hëŠ” rolling 24h, totalDataChartì˜ ë§ˆì§€ë§‰ì´ ì–´ì œ ê°’
                return data ? { live: data.total24h, label: 'DEX Volume 24h (rolling)', unit: '$', format: 'tvl', tolerance: 25 } : null;
            },
            async funding_rate() {
                const data = await fetchJSON('https://fapi.binance.com/fapi/v1/fundingRate?symbol=ETHUSDT&limit=3');
                // ìµœê·¼ 3ê°œ í‰ê·  (í•˜ë£¨ì¹˜)
                if (!data || data.length === 0) return null;
                const avg = data.reduce((sum, d) => sum + parseFloat(d.fundingRate), 0) / data.length;
                return { live: avg, label: 'Funding Rate (8h avg)', unit: '', decimals: 6, tolerance: 20 };
            },
            async stablecoins() {
                const data = await fetchJSON('https://stablecoins.llama.fi/stablecoincharts/all');
                const latest = data?.[data.length - 1];
                const mcap = latest?.totalCirculatingUSD?.peggedUSD || latest?.totalCirculating?.peggedUSD;
                return mcap ? { live: mcap, label: 'Stablecoin MCap', unit: '$', format: 'tvl' } : null;
            },
            async stablecoins_eth() {
                const data = await fetchJSON('https://stablecoins.llama.fi/stablecoincharts/Ethereum');
                const latest = data?.[data.length - 1];
                const mcap = latest?.totalCirculatingUSD?.peggedUSD || latest?.totalCirculating?.peggedUSD;
                return mcap ? { live: mcap, label: 'ETH Stablecoin MCap', unit: '$', format: 'tvl' } : null;
            },
            async lending_tvl() {
                const data = await fetchJSON('https://api.llama.fi/v2/chains');
                const eth = data?.find(c => c.name === 'Ethereum');
                // Lending is roughly 50% of TVL
                return eth ? { live: eth.tvl * 0.5, label: 'Lending TVL (est)', unit: '$', format: 'tvl' } : null;
            }
        };
        
        function formatVerifyValue(val, opts = {}) {
            if (val === null || val === undefined) return '-';
            if (opts.format === 'tvl') {
                return opts.unit + (val >= 1e9 ? (val/1e9).toFixed(2) + 'B' : val >= 1e6 ? (val/1e6).toFixed(2) + 'M' : val.toFixed(0));
            }
            const decimals = opts.decimals ?? 2;
            return opts.unit + parseFloat(val).toFixed(decimals);
        }
        
        function getDiffClass(diff) {
            const absDiff = Math.abs(diff);
            if (absDiff <= 1) return 'diff-good';
            if (absDiff <= 5) return 'diff-warn';
            return 'diff-bad';
        }
        
        async function verifyOne(key) {
            const ds = DATASETS[key];
            const verifier = verifiers[key];
            
            if (!verifier) {
                return { key, status: 'skip', reason: 'No live API' };
            }
            
            try {
                // Get cached value
                const { data: cached } = await sb.from(ds.table).select('*').order('date', { ascending: false }).limit(1);
                const cachedValue = cached?.[0]?.[ds.valueField];
                
                // Get live value
                const liveResult = await verifier();
                if (!liveResult) {
                    return { key, status: 'error', reason: 'API failed' };
                }
                
                // Calculate difference
                const diff = cachedValue && liveResult.live ? ((cachedValue - liveResult.live) / liveResult.live * 100) : null;
                const tolerance = liveResult.tolerance || 5; // default 5%
                
                return {
                    key,
                    status: Math.abs(diff) <= tolerance ? 'match' : 'mismatch',
                    cached: cachedValue,
                    live: liveResult.live,
                    diff,
                    label: liveResult.label,
                    unit: liveResult.unit || '',
                    format: liveResult.format,
                    decimals: liveResult.decimals,
                    tolerance
                };
            } catch (e) {
                return { key, status: 'error', reason: e.message };
            }
        }
        
        async function verifyAll() {
            log('ğŸ” Starting verification...', 'info');
            document.getElementById('verifyModal').classList.add('show');
            document.getElementById('verifyResults').innerHTML = '<p style="text-align:center;padding:40px;">Loading...</p>';
            
            const results = [];
            const keys = Object.keys(DATASETS);
            
            for (const key of keys) {
                const result = await verifyOne(key);
                results.push(result);
            }
            
            // Render results
            const matches = results.filter(r => r.status === 'match').length;
            const mismatches = results.filter(r => r.status === 'mismatch').length;
            const skipped = results.filter(r => r.status === 'skip').length;
            const errors = results.filter(r => r.status === 'error').length;
            
            let html = `
                <div style="display:flex;gap:20px;margin-bottom:20px;">
                    <div style="padding:12px 20px;background:rgba(34,197,94,0.15);border-radius:8px;">
                        <span style="color:var(--success);font-weight:600;">âœ… ${matches} Match</span>
                    </div>
                    <div style="padding:12px 20px;background:rgba(239,68,68,0.15);border-radius:8px;">
                        <span style="color:var(--error);font-weight:600;">âŒ ${mismatches} Mismatch</span>
                    </div>
                    <div style="padding:12px 20px;background:rgba(136,136,136,0.15);border-radius:8px;">
                        <span style="color:var(--text-muted);font-weight:600;">â­ï¸ ${skipped} Skipped</span>
                    </div>
                </div>
                <table class="verify-table">
                    <thead>
                        <tr>
                            <th>Dataset</th>
                            <th>Cached (Supabase)</th>
                            <th>Live (API)</th>
                            <th>Diff</th>
                            <th>Status</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            for (const r of results) {
                const ds = DATASETS[r.key];
                let statusHtml, cachedHtml, liveHtml, diffHtml;
                
                if (r.status === 'skip') {
                    statusHtml = '<span class="verify-skip">â­ï¸ Skip</span>';
                    cachedHtml = '-';
                    liveHtml = '<span style="color:var(--text-muted)">No live API</span>';
                    diffHtml = '-';
                } else if (r.status === 'error') {
                    statusHtml = '<span class="verify-mismatch">âš ï¸ Error</span>';
                    cachedHtml = '-';
                    liveHtml = `<span style="color:var(--text-muted)">${r.reason}</span>`;
                    diffHtml = '-';
                } else {
                    statusHtml = r.status === 'match' 
                        ? '<span class="verify-match">âœ… Match</span>' 
                        : '<span class="verify-mismatch">âŒ Mismatch</span>';
                    cachedHtml = formatVerifyValue(r.cached, r);
                    liveHtml = formatVerifyValue(r.live, r);
                    diffHtml = r.diff !== null 
                        ? `<span class="${getDiffClass(r.diff)}">${r.diff > 0 ? '+' : ''}${r.diff.toFixed(2)}%</span>` 
                        : '-';
                }
                
                html += `
                    <tr>
                        <td>${ds.icon} ${ds.name}</td>
                        <td class="mono">${cachedHtml}</td>
                        <td class="mono">${liveHtml}</td>
                        <td class="mono">${diffHtml}</td>
                        <td>${statusHtml}</td>
                    </tr>
                `;
            }
            
            html += '</tbody></table>';
            document.getElementById('verifyResults').innerHTML = html;
            
            log(`ğŸ” Verification complete: ${matches} match, ${mismatches} mismatch, ${skipped} skipped`, matches >= mismatches ? 'success' : 'warn');
        }
        
        function closeModal() {
            document.getElementById('verifyModal').classList.remove('show');
        }

        async function init() {
            console.log('ğŸš€ init() started');
            try {
                log('ğŸš€ ETHval Admin v7.5 (Schema Aligned)', 'info');
                
                // Etherscan API í‚¤ ìƒíƒœ í‘œì‹œ
                if (ETHERSCAN_API_KEY) {
                    log('âœ… Etherscan API key configured', 'success');
                } else {
                    log('âš ï¸ Etherscan API key not set - click âš™ï¸ Config', 'warn');
                }
                
                if (!SUPABASE_URL || !SUPABASE_ANON_KEY) {
                    document.getElementById('connStatus').className = 'connection-status disconnected';
                    document.getElementById('connText').textContent = 'Not Configured';
                    log('âš ï¸ Supabase not configured - click âš™ï¸ Config', 'warn');
                    return;
                }
                
                // SDK ë¡œë“œ ì²´í¬
                if (!window.supabase) {
                    document.getElementById('connStatus').className = 'connection-status disconnected';
                    document.getElementById('connText').textContent = 'SDK Error';
                    log('âŒ Supabase SDK not loaded', 'error');
                    return;
                }
                
                console.log('Creating Supabase client...');
                sb = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                
                // íƒ€ì„ì•„ì›ƒì´ ìˆëŠ” ì—°ê²° í…ŒìŠ¤íŠ¸
                const testPromise = sb.from('historical_eth_price').select('date').limit(1);
                const timeoutPromise = new Promise((_, reject) => 
                    setTimeout(() => reject(new Error('Connection timeout')), 10000)
                );
                
                await Promise.race([testPromise, timeoutPromise]);
                
                document.getElementById('connStatus').className = 'connection-status connected';
                document.getElementById('connText').textContent = 'Connected';
                log('âœ… Supabase connected', 'success');
                await loadDataStatus();
                await refreshSchedulerLogs();
                
                // Auto-collect if more than 12 hours since last collection
                await checkAutoCollect();
            } catch (e) {
                console.error('Init error:', e);
                document.getElementById('connStatus').className = 'connection-status disconnected';
                document.getElementById('connText').textContent = 'Error';
                log('âŒ Init error: ' + e.message, 'error');
            }
        }
        
        // Check if auto-collection is needed (every 12 hours)
        async function checkAutoCollect() {
            const lastCollect = localStorage.getItem('ethval_last_collect');
            const now = Date.now();
            const TWELVE_HOURS = 12 * 60 * 60 * 1000;
            
            if (!lastCollect || (now - parseInt(lastCollect)) > TWELVE_HOURS) {
                log('\nâ° Auto-collection triggered (>12h since last run)', 'info');
                localStorage.setItem('ethval_last_collect', now.toString());
                
                // Run collection after a short delay
                setTimeout(async () => {
                    await collectAll();
                }, 2000);
            } else {
                const hoursAgo = ((now - parseInt(lastCollect)) / (60 * 60 * 1000)).toFixed(1);
                log(`â° Last collection: ${hoursAgo}h ago (auto-collect in ${(12 - hoursAgo).toFixed(1)}h)`, 'info');
            }
        }
        
        // DOM ë¡œë“œ í›„ ì‹¤í–‰
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
        
        // ============================================================
        // AI COMMENTARY REGENERATION
        // ============================================================
        
        const COMMENTARY_SECTIONS = {
            // 02.1 íˆ¬ìì ì‹¬ë¦¬ - 7ê°œ ì°¨íŠ¸
            // Charts: Realized Price, MVRV Ratio, Fear & Greed, Funding Rate, Open Interest, Exchange ETH Reserve, Whale Transactions
            investor_sentiment: {
                title: 'Investor Sentiment',
                title_ko: 'íˆ¬ìì ì‹¬ë¦¬',
                charts: ['Realized Price', 'MVRV Ratio', 'Fear & Greed', 'Funding Rate', 'Open Interest', 'Exchange ETH Reserve', 'Whale Transactions'],
                tables: {
                    mvrv: 'historical_mvrv',  // mvrv_ratio + realized_price
                    fear_greed: 'historical_fear_greed',  // value
                    funding_rate: 'historical_funding_rate',  // funding_rate
                    open_interest: 'historical_open_interest',  // open_interest
                    exchange_reserve: 'historical_exchange_reserve',  // reserve_eth
                    whale_tx: 'historical_whale_tx'  // whale_tx_count
                }
            },
            // 02.2 ì‹œì¥ í¬ì§€ì…˜ - 5ê°œ ì°¨íŠ¸
            // Charts: ETH/BTC Ratio, ETH Dominance, Stablecoin Mcap, Volatility, NVT Ratio
            market_position: {
                title: 'Market Position',
                title_ko: 'ì‹œì¥ í¬ì§€ì…˜',
                charts: ['ETH/BTC Ratio', 'ETH Dominance', 'Stablecoin Mcap', 'Volatility', 'NVT Ratio'],
                tables: {
                    eth_btc: 'historical_eth_btc',  // ratio
                    eth_dominance: 'historical_eth_dominance',  // eth_dominance
                    stablecoins: 'historical_stablecoins',  // total_mcap (ì „ì²´ ìŠ¤í…Œì´ë¸”ì½”ì¸)
                    volatility: 'historical_volatility',  // volatility_30d
                    nvt: 'historical_nvt'  // nvt_ratio
                }
            },
            // 02.3 ê³µê¸‰ ì—­í•™ - 6ê°œ ì°¨íŠ¸
            // Charts: Staking Yield (APR), Staked ETH, ETH Burned, ETH Issued, Net Supply, Effective Float
            supply_dynamics: {
                title: 'Supply Dynamics',
                title_ko: 'ê³µê¸‰ ì—­í•™',
                charts: ['Staking Yield (APR)', 'Staked ETH', 'ETH Burned', 'ETH Issued', 'Net Supply', 'Effective Float'],
                tables: {
                    staking_apr: 'historical_staking_apr',  // lido_apr
                    staking: 'historical_staking',  // total_staked_eth
                    eth_burnt: 'historical_gas_burn',  // eth_burnt
                    eth_issued: 'historical_daily_issuance',  // daily_issuance
                    eth_supply: 'historical_eth_supply'  // eth_supply
                },
                fieldOverrides: {
                    eth_burnt: 'eth_burnt',
                    eth_issued: 'daily_issuance'
                },
                context: `Net Supplyì™€ Effective FloatëŠ” ê³„ì‚°ê°’ì…ë‹ˆë‹¤:
- Net Supply Change = (ETH Burned - ETH Issued) / Total Supply * 365 * 100 (ì—°ê°„ %)
- Effective Float = Total Supply - Staked ETH - Contract Balances
í˜„ì¬ ETHëŠ” ì•½ +0.5%/ë…„ ì¸í”Œë ˆì´ì…˜ (burn < issuance ìƒíƒœ).`
            },
            // 02.4 ë„¤íŠ¸ì›Œí¬ ìˆ˜ìš” - 5ê°œ ì°¨íŠ¸
            // Charts: Gas Price, Gas Utilization, Network Fees, Blob Fees, Blob Count
            network_demand: {
                title: 'Network Demand',
                title_ko: 'ë„¤íŠ¸ì›Œí¬ ìˆ˜ìš”',
                charts: ['Gas Price', 'Gas Utilization', 'Network Fees', 'Blob Fees', 'Blob Count'],
                tables: {
                    gas_price: 'historical_gas_burn',  // avg_gas_price_gwei
                    gas_utilization: 'historical_gas_burn',  // gas_utilization
                    fees: 'historical_protocol_fees',  // fees
                    blob_count: 'historical_blob_data',  // blob_count
                    blob_fees: 'historical_blob_data'  // blob_fee_eth
                },
                fieldOverrides: {
                    gas_price: 'avg_gas_price_gwei',
                    gas_utilization: 'gas_utilization',
                    blob_count: 'blob_count',
                    blob_fees: 'blob_fee_eth'
                }
            },
            // 02.5 ì‚¬ìš©ì í™œë™ - 5ê°œ ì°¨íŠ¸
            // Charts: New Addresses, L1 Active Addresses, L2 Active Addresses, L1 Transactions, L2 Transactions
            user_activity: {
                title: 'User Activity',
                title_ko: 'ì‚¬ìš©ì í™œë™',
                charts: ['New Addresses', 'L1 Active Addresses', 'L2 Active Addresses', 'L1 Transactions', 'L2 Transactions'],
                tables: {
                    new_addresses: 'historical_new_addresses',  // new_addresses
                    active_addresses: 'historical_active_addresses',  // active_addresses
                    l2_addresses: 'historical_l2_addresses',  // active_addresses (aggregate)
                    transactions: 'historical_transactions',  // tx_count
                    l2_transactions: 'historical_l2_transactions'  // tx_count (aggregate)
                }
            },
            // 02.6 ì˜ˆì¹˜ ìë³¸ - 6ê°œ ì°¨íŠ¸
            // Charts: L1 TVL, L2 TVL, DeFi Lending TVL, L1 Stablecoin Supply, L2 Stablecoin Supply, App Capital
            locked_capital: {
                title: 'Locked Capital',
                title_ko: 'ì˜ˆì¹˜ ìë³¸',
                charts: ['L1 TVL', 'L2 TVL', 'DeFi Lending TVL', 'L1 Stablecoin Supply', 'L2 Stablecoin Supply', 'App Capital'],
                tables: {
                    ethereum_tvl: 'historical_ethereum_tvl',  // tvl
                    l2_tvl: 'historical_l2_tvl',  // tvl (aggregate)
                    lending_tvl: 'historical_lending_tvl',  // total_tvl
                    stablecoins_eth: 'historical_stablecoins_eth',  // total_mcap (L1 ìŠ¤í…Œì´ë¸”ì½”ì¸)
                    l2_stablecoins: 'historical_l2_stablecoin_daily',  // total (L2 ìŠ¤í…Œì´ë¸”ì½”ì¸)
                    staking: 'historical_staking'  // total_staked_eth (App Capitalìš©)
                },
                fieldOverrides: {
                    l2_stablecoins: 'total'
                }
            },
            // 02.7 ê²°ì œëŸ‰ - 6ê°œ ì°¨íŠ¸
            // NOTE: L1/L2 Volumeì€ ì „ì²´ í† í° ì „ì†¡ í¬í•¨, L1/L2 ETH TransferëŠ” ETHë§Œ
            // ERC-20 í† í° ì „ì†¡, DEX ìŠ¤ì™‘ ë“±ì€ ë³„ë„ ì§€í‘œë¡œ ì¸¡ì •
            // Charts: L1 Total Volume, L1 Stablecoin Volume, L1 ETH Transfer, L2 Total Volume, L2 Stablecoin Volume, L2 ETH Transfer, L1 DEX Volume, Bridge Volume
            settlement_volume: {
                title: 'Settlement Volume',
                title_ko: 'ê²°ì œëŸ‰',
                charts: ['L1 Total Volume', 'L1 Stablecoin Volume', 'L1 ETH Transfer', 'L2 Total Volume', 'L2 Stablecoin Volume', 'L2 ETH Transfer', 'L1 DEX Volume', 'Bridge Volume'],
                // AIì—ê²Œ ì „ë‹¬í•  ì»¨í…ìŠ¤íŠ¸: ê° ì§€í‘œì˜ ì •í™•í•œ ì •ì˜
                context: `âš ï¸ CRITICAL: 8 DIFFERENT METRICS - DO NOT CONFUSE âš ï¸

=== SIZE REFERENCE (biggest to smallest) ===
1. L1 ì „ì²´ ë³¼ë¥¨ (L1 Total Volume): $100-600B/day â† BIGGEST
2. L2 ì „ì²´ ë³¼ë¥¨ (L2 Total Volume): $50-300B/day
3. L1 ìŠ¤í…Œì´ë¸”ì½”ì¸ ë³¼ë¥¨: $80-200B/day
4. L2 ìŠ¤í…Œì´ë¸”ì½”ì¸ ë³¼ë¥¨: $70-100B/day
5. L1 ETH ì „ì†¡ëŸ‰ (L1 ETH Transfer): $5-10B/day â† MUCH SMALLER!
6. L1 DEX ë³¼ë¥¨: $1-3B/day
7. L2 ETH ì „ì†¡ëŸ‰ (L2 ETH Transfer): $200-500M/day (Mantle ì œì™¸)
8. ë¸Œë¦¿ì§€ ë³¼ë¥¨: $10-50M/day

=== THE KEY DISTINCTION ===
âŒ WRONG: "L1 ì „ì²´ ë³¼ë¥¨ì´ $7B" (X)
âœ… RIGHT: "L1 ETH ì „ì†¡ëŸ‰ì´ $7B, L1 ì „ì²´ ë³¼ë¥¨ì€ $200B+" (O)

â€¢ "L1 ì „ì²´ ë³¼ë¥¨" = ETH + ëª¨ë“  í† í° = $100B+ (í° ìˆ«ì)
â€¢ "L1 ETH ì „ì†¡ëŸ‰" = ë„¤ì´í‹°ë¸Œ ETHë§Œ = $5-10B (ì‘ì€ ìˆ«ì)

ì´ ë‘ ì§€í‘œì˜ ì°¨ì´ëŠ” 10ë°°~50ë°°ì…ë‹ˆë‹¤!

=== WHAT EACH METRIC MEASURES ===
â€¢ L1 Total Volume: L1ì˜ ëª¨ë“  ì˜¨ì²´ì¸ ì „ì†¡ (ETH + ëª¨ë“  ERC-20)
â€¢ L1 ETH Transfer: L1ì˜ ë„¤ì´í‹°ë¸Œ ETH ì „ì†¡ë§Œ (í† í° ì œì™¸)
â€¢ L1 Stablecoin Volume: L1ì˜ ìŠ¤í…Œì´ë¸”ì½”ì¸ ì „ì†¡ë§Œ
â€¢ L2 Total Volume: L2 8ê°œ ì²´ì¸ì˜ ëª¨ë“  ì „ì†¡
â€¢ L2 ETH Transfer: L2ì˜ ETH ì „ì†¡ë§Œ (Mantle MNT ì œì™¸, Settlement Layerìš©)
â€¢ L2 Stablecoin Volume: L2ì˜ ìŠ¤í…Œì´ë¸”ì½”ì¸ë§Œ
â€¢ L1 DEX Volume: L1 DEX ê±°ë˜ëŸ‰ (ì£¼ê°„ ë°ì´í„°)
â€¢ Bridge Volume: ë¸Œë¦¿ì§€ ì „ì†¡ëŸ‰

When you see data, check the VALUE RANGE to identify which metric it is!`,
                tables: {
                    l1_eth_transfer: 'historical_l1_total_volume',  // eth_volume_usd (L1 ETH Transfer - native ETH only, ~$7B)
                    l1_total_volume: 'historical_l1_total_volume',  // total_volume_usd (ETH + all tokens, ~$200B)
                    l2_native_transfer: 'historical_l2_total_volume',  // native_volume_usd (L2 ETH Transfer - excl Mantle, ~$300M)
                    l2_total_volume: 'historical_l2_total_volume',  // total_volume_usd (Native + all tokens, ~$100B)
                    bridge_volume: 'historical_bridge_volume',  // bridge_volume_eth (aggregate)
                    l2_dex_volume: 'historical_l2_dex_volume',  // dex_volume_usd (aggregate)
                    bridge_total_volume: 'historical_bridge_total_volume',  // bridge_volume_usd (aggregate)
                    stablecoin_volume: 'historical_stablecoin_volume',  // daily_volume (~$80B)
                    l2_stablecoin_volume: 'historical_l2_stablecoin_volume',  // total_volume (~$77B)
                    dex_volume: 'historical_dex_volume'  // volume (~$2B weekly)
                }
            }
        };
        
        const LANGUAGES = ['en', 'ko', 'zh', 'ja'];
        
        function commentaryLog(msg, type = 'info') {
            const logEl = document.getElementById('commentary-log');
            logEl.style.display = 'block';
            const colors = { info: '#8b949e', success: '#3fb950', error: '#f85149', warning: '#d29922' };
            const time = new Date().toLocaleTimeString();
            logEl.innerHTML += `<div style="color: ${colors[type] || colors.info}">[${time}] ${msg}</div>`;
            logEl.scrollTop = logEl.scrollHeight;
        }
        
        function setCommentaryStatus(status, color = 'var(--text-muted)') {
            const el = document.getElementById('commentary-status');
            el.textContent = status;
            el.style.color = color;
        }
        
        // ì—­ì‚¬ì  í†µê³„ ê°€ì ¸ì˜¤ê¸° (3ë…„ì¹˜ ë°ì´í„°ë¡œ percentile ê³„ì‚°)
        async function fetchHistoricalStats(client, tableName, fieldName) {
            try {
                const { data, error } = await client
                    .from(tableName)
                    .select(`date, ${fieldName}`)
                    .order('date', { ascending: false })
                    .limit(1100);
                
                if (error || !data || data.length < 30) return null;
                
                const values = data
                    .map(d => d[fieldName])
                    .filter(v => v !== null && v !== undefined && !isNaN(v) && isFinite(v));
                
                if (values.length < 30) return null;
                
                const sorted = [...values].sort((a, b) => a - b);
                const n = sorted.length;
                
                const min = sorted[0];
                const max = sorted[n - 1];
                const median = sorted[Math.floor(n / 2)];
                const p10 = sorted[Math.floor(n * 0.1)];
                const p25 = sorted[Math.floor(n * 0.25)];
                const p75 = sorted[Math.floor(n * 0.75)];
                const p90 = sorted[Math.floor(n * 0.9)];
                
                const currentVal = values[0];
                const belowCount = sorted.filter(v => v < currentVal).length;
                const currentPercentile = Math.round((belowCount / n) * 100);
                
                return { min, max, median, p10, p25, p75, p90, currentVal, currentPercentile, dataPoints: n };
            } catch (e) {
                console.error(`Error fetching stats for ${tableName}.${fieldName}:`, e.message);
                return null;
            }
        }
        
        async function fetchSectionMetricsForCommentary(sectionKey) {
            const section = COMMENTARY_SECTIONS[sectionKey];
            if (!section) return null;
            
            const metricsData = {};
            const today = new Date().toISOString().split('T')[0];
            const fourteenDaysAgo = new Date(Date.now() - 14 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
            const ninetyDaysAgo = new Date(Date.now() - 90 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
            const ninetyFiveDaysAgo = new Date(Date.now() - 95 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
            
            const client = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // ë§ˆì§€ë§‰ ë‚  ë¯¸ì·¨í•© ë°ì´í„° ì œì™¸ í•¨ìˆ˜ (í™”ë©´ê³¼ ë™ì¼ ë¡œì§)
            // ì¡°ê±´: ë§ˆì§€ë§‰ ê°’ì´ ì§ì „ 7ì¼ í‰ê· ì˜ 30% ë¯¸ë§Œì´ë©´ ì œì™¸
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            function checkAndRemoveIncomplete(records, valueField) {
                if (!records || records.length < 3) return records;
                
                // ë§ˆì§€ë§‰ ë°ì´í„° í•­ìƒ ì œì™¸ (ìˆ˜ì§‘ ì¤‘ì¼ ìˆ˜ ìˆìŒ)
                return records.slice(1);
            }
            
            // í…Œì´ë¸”ë³„ ê°’ í•„ë“œ ë§¤í•‘ (DATASETS ê¸°ì¤€ - ì‹¤ì œ DB í•„ë“œëª…)
            const valueFieldMap = {
                'historical_ethereum_tvl': 'tvl',
                'historical_staking': 'total_staked_eth',
                'historical_l2_tvl': 'tvl',
                'historical_protocol_fees': 'fees',
                'historical_dex_volume': 'volume',
                'historical_stablecoins': 'total_mcap',
                'historical_stablecoins_eth': 'total_mcap',
                'historical_eth_btc': 'ratio',
                'historical_funding_rate': 'funding_rate',
                'historical_eth_dominance': 'eth_dominance',
                'historical_lending_tvl': 'total_tvl',
                'historical_staking_apr': 'lido_apr',
                'historical_blob_data': 'blob_count',
                'historical_l2_transactions': 'tx_count',
                // REMOVED: 'historical_l2_tx_volume' - now using historical_l2_total_volume.native_volume_usd
                'historical_bridge_volume': 'bridge_volume_eth',
                'historical_l2_dex_volume': 'dex_volume_usd',
                'historical_bridge_total_volume': 'bridge_volume_usd',
                'historical_whale_tx': 'whale_tx_count',
                'historical_mvrv': 'mvrv_ratio',
                'historical_stablecoin_volume': 'daily_volume',
                'historical_l2_stablecoin_daily': 'total',  // L2 Stablecoin Supply
                'historical_daily_issuance': 'daily_issuance',  // ETH Issued
                'historical_new_addresses': 'new_addresses',
                'historical_gas_burn': 'avg_gas_price_gwei',
                'historical_transactions': 'tx_count',
                'historical_volatility': 'volatility_30d',
                'historical_exchange_reserve': 'reserve_eth',
                'historical_eth_supply': 'eth_supply',
                'historical_l2_addresses': 'active_addresses',
                'historical_active_addresses': 'active_addresses',
                'historical_fear_greed': 'value',
                'historical_nvt': 'nvt_ratio',
                'historical_open_interest': 'open_interest',
                'historical_daily_issuance': 'daily_issuance',
                'historical_l2_stablecoin_daily': 'total',
                // REMOVED: 'historical_l1_volume' - now using historical_l1_total_volume.eth_volume_usd
                'historical_l1_total_volume': 'total_volume_usd',  // L1 Total Volume (also has eth_volume_usd)
                'historical_l2_total_volume': 'total_volume_usd',  // L2 Total Volume (also has native_volume_usd)
            };
            
            // ë©”íŠ¸ë¦­ í‚¤ë³„ í•„ë“œ ì˜¤ë²„ë¼ì´ë“œ (ê°™ì€ í…Œì´ë¸”ì—ì„œ ë‹¤ë¥¸ í•„ë“œ ì‚¬ìš© ì‹œ)
            const metricFieldOverride = {
                'l1_eth_transfer': 'eth_volume_usd',  // historical_l1_total_volumeì—ì„œ eth_volume_usd ì‚¬ìš©
                'l2_native_transfer': 'native_volume_usd',  // historical_l2_total_volumeì—ì„œ native_volume_usd ì‚¬ìš©
            };
            
            for (const [metricKey, tableName] of Object.entries(section.tables)) {
                try {
                    // Special handling for L1 Total Volume table (used by both l1_eth_transfer and l1_total_volume)
                    if (tableName === 'historical_l1_total_volume') {
                        const fieldToUse = metricKey === 'l1_eth_transfer' ? 'eth_volume_usd' : 'total_volume_usd';
                        const { data: recent } = await client
                            .from(tableName)
                            .select(`date, ${fieldToUse}`)
                            .gte('date', ninetyFiveDaysAgo)
                            .order('date', { ascending: false })
                            .limit(95);
                        
                        if (recent && recent.length > 0) {
                            // ë§ˆì§€ë§‰ ë°ì´í„° ì œì™¸ (ìˆ˜ì§‘ ì¤‘ì¼ ìˆ˜ ìˆìŒ)
                            let cleaned = recent.filter(r => r[fieldToUse] > 0);
                            if (cleaned.length > 2) {
                                cleaned = cleaned.slice(1);
                            }
                            
                            metricsData[metricKey] = {
                                latest: cleaned[0],
                                all90d: cleaned,
                                ninetyDaysAgo: cleaned.length > 90 ? cleaned[90] : null
                            };
                        }
                        continue;
                    }
                    
                    // Special handling for L2 addresses (stored by chain)
                    if (tableName === 'historical_l2_addresses') {
                        const { data: recent } = await client
                            .from(tableName)
                            .select('date, active_addresses')
                            .gte('date', ninetyFiveDaysAgo)
                            .order('date', { ascending: false });
                        
                        if (recent && recent.length > 0) {
                            const byDate = {};
                            for (const r of recent) {
                                if (!byDate[r.date]) byDate[r.date] = 0;
                                byDate[r.date] += parseInt(r.active_addresses || 0);
                            }
                            let dates = Object.keys(byDate).sort().reverse();
                            
                            // ë§ˆì§€ë§‰ ë°ì´í„° ì œì™¸ (ìˆ˜ì§‘ ì¤‘ì¼ ìˆ˜ ìˆìŒ)
                            if (dates.length > 2) {
                                dates = dates.slice(1);
                            }
                            
                            const latestDate = dates[0];
                            
                            metricsData[metricKey] = {
                                latest: { date: latestDate, active_addresses: byDate[latestDate] },
                                all90d: dates.map(d => ({ date: d, active_addresses: byDate[d] })),
                                ninetyDaysAgo: dates.length > 90 ? { date: dates[90], active_addresses: byDate[dates[90]] } : null
                            };
                        }
                        continue;
                    }
                    
                    // Special handling for L2 Transactions (stored by chain)
                    if (tableName === 'historical_l2_transactions') {
                        const { data: recent } = await client
                            .from(tableName)
                            .select('date, tx_count')
                            .gte('date', ninetyFiveDaysAgo)
                            .order('date', { ascending: false });
                        
                        if (recent && recent.length > 0) {
                            const byDate = {};
                            for (const r of recent) {
                                if (!byDate[r.date]) byDate[r.date] = 0;
                                byDate[r.date] += parseInt(r.tx_count || 0);
                            }
                            let dates = Object.keys(byDate).sort().reverse();
                            
                            // ë§ˆì§€ë§‰ ë°ì´í„° ì œì™¸ (ìˆ˜ì§‘ ì¤‘ì¼ ìˆ˜ ìˆìŒ)
                            if (dates.length > 2) {
                                dates = dates.slice(1);
                            }
                            
                            const latestDate = dates[0];
                            
                            metricsData[metricKey] = {
                                latest: { date: latestDate, tx_count: byDate[latestDate] },
                                all90d: dates.map(d => ({ date: d, tx_count: byDate[d] })),
                                ninetyDaysAgo: dates.length > 90 ? { date: dates[90], tx_count: byDate[dates[90]] } : null
                            };
                        }
                        continue;
                    }
                    
                    // REMOVED: historical_l2_tx_volume handling
                    // L2 ETH Transfer now uses historical_l2_total_volume.native_volume_usd
                    
                    // Special handling for Bridge Volume (stored by chain)
                    if (tableName === 'historical_bridge_volume') {
                        const { data: recent } = await client
                            .from(tableName)
                            .select('date, bridge_volume_eth')
                            .gte('date', ninetyFiveDaysAgo)
                            .order('date', { ascending: false });
                        
                        if (recent && recent.length > 0) {
                            const byDate = {};
                            for (const r of recent) {
                                if (!byDate[r.date]) byDate[r.date] = 0;
                                byDate[r.date] += parseFloat(r.bridge_volume_eth || 0);
                            }
                            let dates = Object.keys(byDate).sort().reverse();
                            
                            // ë§ˆì§€ë§‰ ë°ì´í„° ì œì™¸ (ìˆ˜ì§‘ ì¤‘ì¼ ìˆ˜ ìˆìŒ)
                            if (dates.length > 2) {
                                dates = dates.slice(1);
                            }
                            
                            const latestDate = dates[0];
                            
                            metricsData[metricKey] = {
                                latest: { date: latestDate, bridge_volume_eth: byDate[latestDate] },
                                all90d: dates.map(d => ({ date: d, bridge_volume_eth: byDate[d] })),
                                ninetyDaysAgo: dates.length > 90 ? { date: dates[90], bridge_volume_eth: byDate[dates[90]] } : null
                            };
                        }
                        continue;
                    }
                    
                    // Special handling for L2 DEX Volume (stored by blockchain)
                    if (tableName === 'historical_l2_dex_volume') {
                        const { data: recent } = await client
                            .from(tableName)
                            .select('date, dex_volume_usd')
                            .gte('date', ninetyFiveDaysAgo)
                            .order('date', { ascending: false });
                        
                        if (recent && recent.length > 0) {
                            const byDate = {};
                            for (const r of recent) {
                                if (!byDate[r.date]) byDate[r.date] = 0;
                                byDate[r.date] += parseFloat(r.dex_volume_usd || 0);
                            }
                            let dates = Object.keys(byDate).sort().reverse();
                            
                            if (dates.length > 2) {
                                dates = dates.slice(1);
                            }
                            
                            const latestDate = dates[0];
                            
                            metricsData[metricKey] = {
                                latest: { date: latestDate, dex_volume_usd: byDate[latestDate] },
                                all90d: dates.map(d => ({ date: d, dex_volume_usd: byDate[d] })),
                                ninetyDaysAgo: dates.length > 90 ? { date: dates[90], dex_volume_usd: byDate[dates[90]] } : null
                            };
                        }
                        continue;
                    }
                    
                    // Special handling for Bridge Total Volume (stored by destination_chain)
                    if (tableName === 'historical_bridge_total_volume') {
                        const { data: recent } = await client
                            .from(tableName)
                            .select('date, bridge_volume_usd')
                            .gte('date', ninetyFiveDaysAgo)
                            .order('date', { ascending: false });
                        
                        if (recent && recent.length > 0) {
                            const byDate = {};
                            for (const r of recent) {
                                if (!byDate[r.date]) byDate[r.date] = 0;
                                byDate[r.date] += parseFloat(r.bridge_volume_usd || 0);
                            }
                            let dates = Object.keys(byDate).sort().reverse();
                            
                            if (dates.length > 2) {
                                dates = dates.slice(1);
                            }
                            
                            const latestDate = dates[0];
                            
                            metricsData[metricKey] = {
                                latest: { date: latestDate, bridge_volume_usd: byDate[latestDate] },
                                all90d: dates.map(d => ({ date: d, bridge_volume_usd: byDate[d] })),
                                ninetyDaysAgo: dates.length > 90 ? { date: dates[90], bridge_volume_usd: byDate[dates[90]] } : null
                            };
                        }
                        continue;
                    }
                    
                    // Special handling for L2 Total Volume table (used by both l2_native_transfer and l2_total_volume)
                    // l2_native_transfer (L2 ETH Transfer) uses native_volume_usd, l2_total_volume uses total_volume_usd
                    if (tableName === 'historical_l2_total_volume') {
                        const fieldToUse = metricKey === 'l2_native_transfer' ? 'native_volume_usd' : 'total_volume_usd';
                        const { data: recent } = await client
                            .from(tableName)
                            .select(`date, ${fieldToUse}`)
                            .gte('date', ninetyFiveDaysAgo)
                            .order('date', { ascending: false });
                        
                        if (recent && recent.length > 0) {
                            const byDate = {};
                            for (const r of recent) {
                                if (!byDate[r.date]) byDate[r.date] = 0;
                                byDate[r.date] += parseFloat(r[fieldToUse] || 0);
                            }
                            let dates = Object.keys(byDate).sort().reverse();
                            
                            console.log(`ğŸ“Š L2 ${metricKey === 'l2_native_transfer' ? 'ETH Transfer' : 'Total Volume'} aggregated: ${dates.length} dates, latest=$${(byDate[dates[0]]/1e9)?.toFixed(2)}B`);
                            
                            // ë§ˆì§€ë§‰ ë°ì´í„° ì œì™¸ (ìˆ˜ì§‘ ì¤‘ì¼ ìˆ˜ ìˆìŒ)
                            if (dates.length > 2) {
                                dates = dates.slice(1);
                            }
                            
                            const latestDate = dates[0];
                            
                            metricsData[metricKey] = {
                                latest: { date: latestDate, [fieldToUse]: byDate[latestDate] },
                                all90d: dates.map(d => ({ date: d, [fieldToUse]: byDate[d] })),
                                ninetyDaysAgo: dates.length > 90 ? { date: dates[90], [fieldToUse]: byDate[dates[90]] } : null
                            };
                        }
                        continue;
                    }
                    
                    // Special handling for L2 Stablecoin Volume (stored by chain)
                    if (tableName === 'historical_l2_stablecoin_volume') {
                        const { data: recent } = await client
                            .from(tableName)
                            .select('date, total_volume')
                            .gte('date', ninetyFiveDaysAgo)
                            .order('date', { ascending: false });
                        
                        if (recent && recent.length > 0) {
                            const byDate = {};
                            for (const r of recent) {
                                if (!byDate[r.date]) byDate[r.date] = 0;
                                byDate[r.date] += parseFloat(r.total_volume || 0);
                            }
                            let dates = Object.keys(byDate).sort().reverse();
                            
                            console.log(`ğŸ“Š L2 Stablecoin Volume aggregated: ${dates.length} dates, latest=$${(byDate[dates[0]]/1e9)?.toFixed(2)}B`);
                            
                            // ë§ˆì§€ë§‰ ë°ì´í„° ì œì™¸ (ìˆ˜ì§‘ ì¤‘ì¼ ìˆ˜ ìˆìŒ)
                            if (dates.length > 2) {
                                dates = dates.slice(1);
                            }
                            
                            const latestDate = dates[0];
                            
                            metricsData[metricKey] = {
                                latest: { date: latestDate, total_volume: byDate[latestDate] },
                                all90d: dates.map(d => ({ date: d, total_volume: byDate[d] })),
                                ninetyDaysAgo: dates.length > 90 ? { date: dates[90], total_volume: byDate[dates[90]] } : null
                            };
                        }
                        continue;
                    }
                    
                    // Special handling for L2 TVL (stored by chain)
                    if (tableName === 'historical_l2_tvl') {
                        const { data: recent } = await client
                            .from(tableName)
                            .select('date, tvl')
                            .gte('date', ninetyFiveDaysAgo)
                            .order('date', { ascending: false });
                        
                        if (recent && recent.length > 0) {
                            const byDate = {};
                            for (const r of recent) {
                                if (!byDate[r.date]) byDate[r.date] = 0;
                                byDate[r.date] += parseFloat(r.tvl || 0);
                            }
                            let dates = Object.keys(byDate).sort().reverse();
                            
                            // ë§ˆì§€ë§‰ ë°ì´í„° ì œì™¸ (ìˆ˜ì§‘ ì¤‘ì¼ ìˆ˜ ìˆìŒ)
                            if (dates.length > 2) {
                                dates = dates.slice(1);
                            }
                            
                            const latestDate = dates[0];
                            
                            metricsData[metricKey] = {
                                latest: { date: latestDate, tvl: byDate[latestDate] },
                                all90d: dates.map(d => ({ date: d, tvl: byDate[d] })),
                                ninetyDaysAgo: dates.length > 90 ? { date: dates[90], tvl: byDate[dates[90]] } : null
                            };
                        }
                        continue;
                    }
                    
                    // 95ì¼ì¹˜ ë°ì´í„° ê°€ì ¸ì˜¤ê¸° (ë¯¸ì·¨í•© ì œì™¸ + 90ì¼ íŠ¸ë Œë“œìš©)
                    const { data: recent } = await client
                        .from(tableName)
                        .select('*')
                        .gte('date', ninetyFiveDaysAgo)
                        .order('date', { ascending: false })
                        .limit(95);
                    
                    const { data: older } = await client
                        .from(tableName)
                        .select('*')
                        .lte('date', ninetyDaysAgo)
                        .order('date', { ascending: false })
                        .limit(1);
                    
                    if (recent && recent.length > 0) {
                        // fieldOverridesê°€ ìˆìœ¼ë©´ í•´ë‹¹ í•„ë“œë¥¼ ë©”ì¸ìœ¼ë¡œ ì‚¬ìš©
                        let valueField = valueFieldMap[tableName];
                        if (section.fieldOverrides && section.fieldOverrides[metricKey]) {
                            valueField = section.fieldOverrides[metricKey];
                        }
                        
                        // ë¯¸ì·¨í•© ë°ì´í„° ì œì™¸ (í™”ë©´ê³¼ ë™ì¼ ë¡œì§)
                        let cleanedRecent = recent;
                        if (valueField) {
                            cleanedRecent = checkAndRemoveIncomplete(recent, valueField);
                        }
                        
                        // ì—­ì‚¬ì  í†µê³„ ê°€ì ¸ì˜¤ê¸°
                        const historicalStats = await fetchHistoricalStats(client, tableName, valueField);
                        
                        // fieldOverridesê°€ ìˆìœ¼ë©´ í•´ë‹¹ í•„ë“œë§Œ ì¶”ì¶œí•´ì„œ ì €ì¥
                        if (section.fieldOverrides && section.fieldOverrides[metricKey]) {
                            const targetField = section.fieldOverrides[metricKey];
                            metricsData[metricKey] = {
                                latest: { date: cleanedRecent[0]?.date, [targetField]: cleanedRecent[0]?.[targetField] },
                                all90d: cleanedRecent.map(r => ({ date: r.date, [targetField]: r[targetField] })),
                                ninetyDaysAgo: older?.[0] ? { date: older[0].date, [targetField]: older[0][targetField] } : null,
                                historicalStats: historicalStats
                            };
                        } else {
                            metricsData[metricKey] = {
                                latest: cleanedRecent[0],
                                all90d: cleanedRecent,  // ì „ì²´ 90ì¼+ ë°ì´í„° (ì¢…í•© ë¶„ì„ìš©)
                                ninetyDaysAgo: older?.[0] || null,
                                historicalStats: historicalStats
                            };
                        }
                    }
                } catch (e) {
                    commentaryLog(`Error fetching ${tableName}: ${e.message}`, 'error');
                }
            }
            
            // Also get ETH price
            try {
                const { data: priceData } = await client
                    .from('historical_eth_price')
                    .select('*')
                    .order('date', { ascending: false })
                    .limit(2);
                
                if (priceData && priceData.length > 0) {
                    metricsData.eth_price = {
                        latest: priceData[0],
                        previous: priceData[1] || null
                    };
                }
            } catch (e) {
                commentaryLog(`Error fetching ETH price: ${e.message}`, 'warning');
            }
            
            return metricsData;
        }
        
        // ============================================================
        // Data Preview Function - ëª¨ë“  ì„¹ì…˜ ë°ì´í„° ê²€ì¦
        // ============================================================
        async function previewAllSectionsData() {
            const btn = document.getElementById('btn-data-preview');
            const panel = document.getElementById('data-preview-panel');
            const content = document.getElementById('data-preview-content');
            
            btn.disabled = true;
            btn.textContent = 'â³ Loading...';
            panel.style.display = 'block';
            content.innerHTML = '<div style="color: var(--text-muted); padding: 20px; text-align: center;">Loading all section data...</div>';
            
            const sections = Object.keys(COMMENTARY_SECTIONS);
            let html = '';
            
            // í•„ë“œë³„ ê°’ ì¶”ì¶œ í•¨ìˆ˜ (DATASETS ê¸°ì¤€)
            // ìˆœì„œ ì¤‘ìš”: êµ¬ì²´ì ì¸ í•„ë“œëª…ì´ ë¨¼ì € ì™€ì•¼ í•¨
            const extractValue = (latest) => {
                if (!latest) return { field: 'N/A', value: null };
                
                const fieldMap = [
                    // êµ¬ì²´ì ì¸ í•„ë“œëª… ë¨¼ì € (ì´ í•„ë“œë“¤ì€ í•´ë‹¹ í…Œì´ë¸”ì—ë§Œ ì¡´ì¬)
                    { field: 'value', label: 'Fear & Greed' },  // fear_greed
                    { field: 'funding_rate', label: 'Funding Rate' },
                    { field: 'open_interest', label: 'Open Interest' },  // open_interest
                    { field: 'lido_apr', label: 'Staking APR' },  // staking_apr
                    { field: 'eth_dominance', label: 'ETH Dominance' },
                    { field: 'ratio', label: 'Ratio' },  // eth_btc
                    { field: 'reserve_eth', label: 'Reserve ETH' },  // exchange_reserve
                    { field: 'mvrv_ratio', label: 'MVRV Ratio' },
                    { field: 'realized_price', label: 'Realized Price' },  // mvrv table
                    { field: 'nvt_ratio', label: 'NVT Ratio' },  // nvt
                    { field: 'volatility_30d', label: 'Volatility' },  // volatility
                    { field: 'whale_tx_count', label: 'Whale TX' },
                    { field: 'blob_count', label: 'Blob Count' },  // blob_data
                    { field: 'blob_fee_eth', label: 'Blob Fee' },
                    { field: 'new_addresses', label: 'New Addr' },
                    { field: 'active_addresses', label: 'Active Addr' },
                    { field: 'tx_count', label: 'TX Count' },
                    { field: 'eth_supply', label: 'ETH Supply' },
                    { field: 'total_staked_eth', label: 'Staked ETH' },
                    { field: 'avg_gas_price_gwei', label: 'Gas Price' },  // gas_burn
                    { field: 'gas_utilization', label: 'gas_utilization' },  // gas_burn
                    { field: 'eth_burnt', label: 'ETH Burnt' },  // gas_burn
                    { field: 'daily_issuance', label: 'daily_issuance' },  // daily_issuance
                    { field: 'tx_volume_usd', label: 'TX Volume USD' },  // nvt table
                    { field: 'total_volume_usd', label: 'Total Volume USD' },  // l1/l2_total_volume
                    { field: 'eth_volume_usd', label: 'ETH Volume USD' },  // l1_total_volume (L1 ETH Transfer)
                    { field: 'native_volume_usd', label: 'Native Volume USD' },  // l2_total_volume (L2 ETH Transfer)
                    { field: 'total_volume', label: 'Total Volume' },  // l2_stablecoin_volume
                    { field: 'total', label: 'total' },  // l2_stablecoin_daily
                    { field: 'daily_volume', label: 'Daily Volume' },  // stablecoin_volume
                    { field: 'tx_volume_usd', label: 'TX Volume USD' },  // l2_tx_volume
                    { field: 'bridge_volume_eth', label: 'Bridge ETH Volume' },  // bridge_volume
                    { field: 'dex_volume_usd', label: 'DEX Volume USD' },  // l2_dex_volume
                    { field: 'bridge_volume_usd', label: 'Bridge Volume USD' },  // bridge_total_volume
                    // ì¼ë°˜ì ì¸ í•„ë“œëª… (ì—¬ëŸ¬ í…Œì´ë¸”ì—ì„œ ê³µìœ )
                    { field: 'volume', label: 'Volume' },  // dex_volume
                    { field: 'fees', label: 'Fees' },  // protocol_fees
                    { field: 'tvl', label: 'TVL' },
                    { field: 'total_tvl', label: 'Total TVL' },  // lending_tvl
                    { field: 'total_mcap', label: 'Total Mcap' },  // stablecoins
                ];
                
                for (const { field, label } of fieldMap) {
                    if (latest[field] !== undefined && latest[field] !== null) {
                        return { field, label, value: latest[field] };
                    }
                }
                
                // ë°œê²¬ëœ ëª¨ë“  í•„ë“œ ë‚˜ì—´
                const foundFields = Object.keys(latest).filter(k => k !== 'date' && k !== 'source' && k !== 'id');
                return { field: foundFields.join(', ') || 'unknown', value: null };
            };
            
            // ê°’ í¬ë§·íŒ… í•¨ìˆ˜
            const formatVal = (v) => {
                if (v === null || v === undefined) return '<span style="color: #f85149;">NULL</span>';
                if (typeof v === 'number') {
                    if (v >= 1e12) return (v / 1e12).toFixed(2) + 'T';
                    if (v >= 1e9) return (v / 1e9).toFixed(2) + 'B';
                    if (v >= 1e6) return (v / 1e6).toFixed(2) + 'M';
                    if (v >= 1e3) return (v / 1e3).toFixed(2) + 'K';
                    if (v < 1 && v > 0) return v.toFixed(4);
                    return v.toFixed(2);
                }
                return String(v);
            };
            
            for (const sectionKey of sections) {
                const section = COMMENTARY_SECTIONS[sectionKey];
                
                try {
                    const metricsData = await fetchSectionMetricsForCommentary(sectionKey);
                    
                    let tableRows = '';
                    let successCount = 0;
                    let totalCount = Object.keys(section.tables).length;
                    
                    for (const [metricKey, tableName] of Object.entries(section.tables)) {
                        const data = metricsData[metricKey];
                        const hasLatest = !!data?.latest;
                        const all90d = data?.all90d || [];
                        const dataCount = all90d.length;
                        
                        const extracted = extractValue(data?.latest);
                        
                        // 90ì¼ ë³€í™”ìœ¨ ë° íŠ¸ë Œë“œ ê³„ì‚°
                        let change90d = null;
                        let trend = '-';
                        
                        if (all90d.length >= 2) {
                            const values = all90d.map(r => extractValue(r)?.value).filter(v => v !== null);
                            if (values.length >= 2) {
                                const latest = values[0];
                                const oldest = values[values.length - 1];
                                if (oldest !== 0) {
                                    change90d = ((latest - oldest) / Math.abs(oldest) * 100).toFixed(1);
                                }
                                
                                // íŠ¸ë Œë“œ íŒë‹¨
                                if (values.length >= 5) {
                                    const avg = values.reduce((a, b) => a + b, 0) / values.length;
                                    let numerator = 0, denominator = 0;
                                    const xMean = (values.length - 1) / 2;
                                    for (let i = 0; i < values.length; i++) {
                                        numerator += (i - xMean) * (values[values.length - 1 - i] - avg);
                                        denominator += (i - xMean) ** 2;
                                    }
                                    const slope = denominator !== 0 ? numerator / denominator : 0;
                                    const normalizedSlope = avg !== 0 ? (slope / avg) * 100 : 0;
                                    
                                    if (normalizedSlope > 1) trend = 'â†‘';
                                    else if (normalizedSlope < -1) trend = 'â†“';
                                    else trend = 'â†’';
                                }
                            }
                        }
                        
                        if (hasLatest && extracted.value !== null) successCount++;
                        
                        const statusColor = hasLatest && extracted.value !== null ? '#3fb950' : '#f85149';
                        const statusIcon = hasLatest && extracted.value !== null ? 'âœ“' : 'âœ—';
                        
                        const historyColor = dataCount >= 25 ? '#3fb950' : (dataCount >= 7 ? '#d29922' : '#f85149');
                        
                        tableRows += `
                            <tr style="border-bottom: 1px solid #21262d;">
                                <td style="padding: 6px 8px; font-size: 11px; color: #8b949e;">${metricKey}</td>
                                <td style="padding: 6px 8px; font-size: 10px; color: #6e7681; font-family: monospace;">${tableName.replace('historical_', '')}</td>
                                <td style="padding: 6px 8px; text-align: center;">
                                    <span style="color: ${statusColor}; font-weight: bold;">${statusIcon}</span>
                                </td>
                                <td style="padding: 6px 8px; font-size: 10px; color: #58a6ff;">${extracted.label || extracted.field}</td>
                                <td style="padding: 6px 8px; font-size: 11px; font-family: monospace; color: ${extracted.value !== null ? '#e6edf3' : '#f85149'};">
                                    ${formatVal(extracted.value)}
                                </td>
                                <td style="padding: 6px 8px; font-size: 10px; font-family: monospace; color: ${historyColor};">
                                    ${dataCount}d
                                </td>
                                <td style="padding: 6px 8px; font-size: 10px; font-family: monospace;">
                                    <span style="color: ${change90d !== null ? (change90d >= 0 ? '#3fb950' : '#f85149') : '#6e7681'};">
                                        ${change90d !== null ? '~' + (change90d >= 0 ? '+' : '') + change90d + '%' : '-'}
                                    </span>
                                    <span style="margin-left: 4px; color: ${trend === 'â†‘' ? '#3fb950' : trend === 'â†“' ? '#f85149' : '#8b949e'};">${trend}</span>
                                </td>
                            </tr>
                        `;
                    }
                    
                    const successRate = Math.round(successCount / totalCount * 100);
                    const bgColor = successRate === 100 ? '#1a2e1a' : (successRate >= 50 ? '#2e2a1a' : '#2e1a1a');
                    const headerColor = successRate === 100 ? '#3fb950' : (successRate >= 50 ? '#d29922' : '#f85149');
                    
                    html += `
                        <div style="background: ${bgColor}; border: 1px solid #30363d; border-radius: 8px; overflow: hidden;">
                            <div style="padding: 10px 12px; background: #161b22; border-bottom: 1px solid #30363d; display: flex; justify-content: space-between; align-items: center;">
                                <span style="font-weight: 600; font-size: 12px;">${section.title}</span>
                                <span style="font-size: 11px; color: ${headerColor}; font-weight: bold;">
                                    ${successCount}/${totalCount} (${successRate}%)
                                </span>
                            </div>
                            <div style="padding: 4px; font-size: 10px; color: #8b949e; background: #0d1117;">
                                Charts: ${section.charts.join(', ')}
                            </div>
                            <table style="width: 100%; border-collapse: collapse;">
                                <thead>
                                    <tr style="background: #161b22; font-size: 10px; color: #8b949e;">
                                        <th style="padding: 6px 8px; text-align: left;">Metric</th>
                                        <th style="padding: 6px 8px; text-align: left;">Table</th>
                                        <th style="padding: 6px 8px; text-align: center;">OK</th>
                                        <th style="padding: 6px 8px; text-align: left;">Field</th>
                                        <th style="padding: 6px 8px; text-align: left;">Value</th>
                                        <th style="padding: 6px 8px; text-align: left;" title="Days of data available">Days</th>
                                        <th style="padding: 6px 8px; text-align: left;" title="Approximate 90-day change (based on recent data average)">~90d</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${tableRows}
                                </tbody>
                            </table>
                        </div>
                    `;
                } catch (e) {
                    html += `
                        <div style="background: #2e1a1a; border: 1px solid #f85149; border-radius: 8px; padding: 12px;">
                            <div style="font-weight: 600; color: #f85149;">${section.title}</div>
                            <div style="font-size: 11px; color: #8b949e; margin-top: 4px;">Error: ${e.message}</div>
                        </div>
                    `;
                }
            }
            
            content.innerHTML = html;
            btn.disabled = false;
            btn.textContent = 'ğŸ” Data Preview (All Sections)';
        }
        
        function formatMetricsForPrompt(sectionKey, metricsData) {
            const section = COMMENTARY_SECTIONS[sectionKey];
            const ethPrice = metricsData.eth_price?.latest?.close || 3900;  // fallback price
            
            let prompt = `Section: ${section.title} (${section.title_ko})\n`;
            prompt += `Charts in this section: ${section.charts.join(', ')}\n\n`;
            prompt += `Current ETH Price: $${ethPrice.toFixed(2)}\n\n`;
            
            // í•„ë“œì—ì„œ ê°’ì„ ì¶”ì¶œí•˜ëŠ” í—¬í¼ í•¨ìˆ˜ (DATASETS ê¸°ì¤€)
            const extractValue = (record) => {
                if (!record) return null;
                const fields = ['value', 'tvl', 'total_tvl', 'total_mcap', 'total', 'funding_rate', 'total_staked_eth', 
                    'lido_apr', 'eth_dominance', 'ratio', 'reserve_eth', 'avg_gas_price_gwei', 'gas_utilization', 'eth_burnt',
                    'mvrv_ratio', 'realized_price', 'nvt_ratio', 'tx_volume_usd', 'eth_volume_usd', 'native_volume_usd',
                    'total_volume_usd', 'total_volume', 'daily_volume', 'volume', 'open_interest', 'daily_issuance',
                    'bridge_volume_eth', 'blob_count', 'blob_fee_eth',
                    'active_addresses', 'new_addresses', 'tx_count', 'volatility_30d', 'eth_supply', 
                    'fees', 'whale_tx_count'];
                for (const f of fields) {
                    if (record[f] !== undefined && record[f] !== null) {
                        return { field: f, value: record[f] };
                    }
                }
                return null;
            };
            
            // ì°¨íŠ¸ì—ì„œ USDë¡œ í‘œì‹œí•˜ëŠ” ETH ë³¼ë¥¨ í•„ë“œë“¤ (ETHâ†’USD ë³€í™˜ í•„ìš”)
            // Note: tx_volume_usdëŠ” ì´ë¯¸ USDë¡œ ì €ì¥ë˜ë¯€ë¡œ ë³€í™˜ ë¶ˆí•„ìš”
            const ethToUsdFields = ['bridge_volume_eth'];
            
            // ê°’ í¬ë§·íŒ… í•¨ìˆ˜
            const formatVal = (v, unit = '') => {
                if (v === null || v === undefined) return 'N/A';
                if (typeof v === 'number') {
                    if (Math.abs(v) >= 1e12) return (v / 1e12).toFixed(2) + 'T' + unit;
                    if (Math.abs(v) >= 1e9) return (v / 1e9).toFixed(2) + 'B' + unit;
                    if (Math.abs(v) >= 1e6) return (v / 1e6).toFixed(2) + 'M' + unit;
                    if (Math.abs(v) >= 1e3) return (v / 1e3).toFixed(2) + 'K' + unit;
                    if (Math.abs(v) < 0.01 && v !== 0) return v.toFixed(4) + unit;
                    return v.toFixed(2) + unit;
                }
                return String(v) + unit;
            };
            
            // ë‹¨ìœ„ ê²°ì • í•¨ìˆ˜ (ì°¨íŠ¸ í‘œì‹œ ë‹¨ìœ„ ê¸°ì¤€)
            const getUnit = (fieldName) => {
                // ì°¨íŠ¸ì—ì„œ USDë¡œ í‘œì‹œí•˜ëŠ” í•„ë“œë“¤
                if (['tvl', 'total_tvl', 'realized_price', 'daily_volume', 'volume', 'tx_volume_usd', 'eth_volume_usd', 'native_volume_usd', 'total_volume_usd', 'total_volume', 'total_mcap', 'total', 'fees', 'open_interest'].includes(fieldName)) return ' USD';
                // ETH ë³¼ë¥¨ â†’ ì°¨íŠ¸ì—ì„œ USDë¡œ í‘œì‹œí•˜ë¯€ë¡œ USD
                if (ethToUsdFields.includes(fieldName)) return ' USD';
                // ì°¨íŠ¸ì—ì„œ ETHë¡œ í‘œì‹œí•˜ëŠ” í•„ë“œë“¤
                if (['total_staked_eth', 'reserve_eth', 'eth_burnt', 'eth_supply', 'blob_fee_eth', 'daily_issuance'].includes(fieldName)) return ' ETH';
                if (['funding_rate', 'eth_dominance', 'volatility_30d', 'lido_apr', 'gas_utilization'].includes(fieldName)) return '%';
                if (fieldName === 'avg_gas_price_gwei') return ' Gwei';
                return '';
            };
            
            // í¼ì„¼íŠ¸ë¡œ ë³€í™˜ì´ í•„ìš”í•œ í•„ë“œë“¤ (ì†Œìˆ˜ â†’ í¼ì„¼íŠ¸, * 100)
            const percentConversionFields = ['funding_rate'];
            
            prompt += `â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n`;
            prompt += `COMPREHENSIVE 30-DAY METRICS ANALYSIS\n`;
            prompt += `â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n`;
            
            for (const [key, data] of Object.entries(metricsData)) {
                if (key === 'eth_price') continue;
                if (!data?.latest || !data?.all90d || data.all90d.length === 0) continue;
                
                const extracted = extractValue(data.latest);
                if (!extracted) continue;
                
                const fieldName = extracted.field;
                const unit = getUnit(fieldName);
                const all = data.all90d;
                
                // ETHâ†’USD ë³€í™˜ ì—¬ë¶€
                const needsUsdConversion = ethToUsdFields.includes(fieldName);
                const usdMultiplier = needsUsdConversion ? ethPrice : 1;
                
                // ì†Œìˆ˜â†’í¼ì„¼íŠ¸ ë³€í™˜ ì—¬ë¶€ (funding_rateëŠ” 0.0001 â†’ 0.01%ë¡œ ë³€í™˜ í•„ìš”)
                const needsPercentConversion = percentConversionFields.includes(fieldName);
                const percentMultiplier = needsPercentConversion ? 100 : 1;
                
                const multiplier = usdMultiplier * percentMultiplier;
                
                // ë‚ ì§œì™€ ê°’ì„ í•¨ê»˜ ì¶”ì¶œ
                const dataWithDates = all.map(r => {
                    const v = extractValue(r)?.value;
                    return {
                        date: r.date,
                        value: (v !== null && v !== undefined) ? v * multiplier : null
                    };
                }).filter(d => d.value !== null);
                
                if (dataWithDates.length === 0) continue;
                
                // í˜„ì¬ê°’: ë¯¸ì™„ì„± ì œì™¸ ë§ˆì§€ë§‰ ë‚  (ì°¨íŠ¸ì™€ ë™ì¼)
                const latest = dataWithDates[0].value;
                const latestDate = new Date(dataWithDates[0].date);
                
                // 90ì¼ ì „ ë‚ ì§œ ê³„ì‚° (Â±1ì¼ = 89~91ì¼ ì „)
                const target90dAgo = new Date(latestDate);
                target90dAgo.setDate(target90dAgo.getDate() - 90);
                
                // 90ì¼ ì „ Â±1ì¼ ë²”ìœ„ì˜ ë°ì´í„° ì°¾ê¸° (3ì¼ í‰ê· )
                const day89Ago = new Date(latestDate); day89Ago.setDate(day89Ago.getDate() - 89);
                const day91Ago = new Date(latestDate); day91Ago.setDate(day91Ago.getDate() - 91);
                
                const around90dAgoData = dataWithDates.filter(d => {
                    const date = new Date(d.date);
                    return date >= day91Ago && date <= day89Ago;
                });
                
                // 90ì¼ ì „ 3ì¼ í‰ê·  ê³„ì‚°
                let avg90dAgo = null;
                if (around90dAgoData.length > 0) {
                    avg90dAgo = around90dAgoData.reduce((sum, d) => sum + d.value, 0) / around90dAgoData.length;
                }
                
                // 90ì¼ ë³€í™”ìœ¨: (í˜„ì¬ - 90ì¼ì „í‰ê· ) / 90ì¼ì „í‰ê·  * 100
                const change90d = avg90dAgo && avg90dAgo !== 0 
                    ? ((latest - avg90dAgo) / Math.abs(avg90dAgo) * 100) 
                    : null;
                
                // ì „ì²´ 90ì¼ í†µê³„
                const values = dataWithDates.map(d => d.value);
                const avg90d = values.reduce((a, b) => a + b, 0) / values.length;
                const max90d = Math.max(...values);
                const min90d = Math.min(...values);
                
                // ì¶”ì„¸ ë°©í–¥ íŒë‹¨ (ì„ í˜• íšŒê·€ ê¸°ìš¸ê¸°)
                let trendDirection = 'stable';
                if (values.length >= 5) {
                    const n = values.length;
                    const xMean = (n - 1) / 2;
                    const yMean = avg90d;
                    let numerator = 0, denominator = 0;
                    for (let i = 0; i < n; i++) {
                        numerator += (i - xMean) * (values[n - 1 - i] - yMean);
                        denominator += (i - xMean) ** 2;
                    }
                    const slope = denominator !== 0 ? numerator / denominator : 0;
                    const normalizedSlope = avg90d !== 0 ? (slope / avg90d) * 100 : 0;
                    
                    if (normalizedSlope > 1) trendDirection = 'uptrend';
                    else if (normalizedSlope < -1) trendDirection = 'downtrend';
                    else trendDirection = 'sideways';
                }
                
                // ë³€ë™ì„± (í‘œì¤€í¸ì°¨ / í‰ê· )
                const variance = values.reduce((sum, v) => sum + Math.pow(v - avg90d, 2), 0) / values.length;
                const stdDev = Math.sqrt(variance);
                const volatility = avg90d !== 0 ? (stdDev / Math.abs(avg90d) * 100) : 0;
                
                prompt += `â–¶ ${key.toUpperCase()}\n`;
                prompt += `  Current (${dataWithDates[0].date}): ${formatVal(latest, unit)}\n`;
                if (avg90dAgo !== null) {
                    prompt += `  90 Days Ago (3-day avg): ${formatVal(avg90dAgo, unit)}\n`;
                    prompt += `  90-Day Change: ${change90d > 0 ? '+' : ''}${change90d.toFixed(1)}%\n`;
                }
                prompt += `  90-Day Range: ${formatVal(min90d, unit)} ~ ${formatVal(max90d, unit)}\n`;
                prompt += `  Trend: ${trendDirection.toUpperCase()} | Volatility: ${volatility.toFixed(1)}%\n`;
                
                // ì—­ì‚¬ì  í†µê³„ ì¶”ê°€ (AIê°€ ë§¥ë½ì„ ì´í•´í•˜ë„ë¡)
                const stats = data.historicalStats;
                if (stats) {
                    const percentileLabel = stats.currentPercentile < 25 ? 'LOW - bottom quartile' 
                        : stats.currentPercentile < 50 ? 'BELOW median' 
                        : stats.currentPercentile < 75 ? 'ABOVE median' 
                        : 'HIGH - top quartile';
                    prompt += `  ğŸ“Š Historical Context (${stats.dataPoints} days):\n`;
                    prompt += `    â€¢ Current Percentile: ${stats.currentPercentile}% (${percentileLabel})\n`;
                    prompt += `    â€¢ All-time Range: ${formatVal(stats.min, unit)} ~ ${formatVal(stats.max, unit)}\n`;
                    prompt += `    â€¢ Median: ${formatVal(stats.median, unit)}, P25: ${formatVal(stats.p25, unit)}, P75: ${formatVal(stats.p75, unit)}\n`;
                }
                
                // ì¶”ê°€ í•„ë“œ
                if (data.latest.lido_apr !== undefined && fieldName !== 'lido_apr') {
                    prompt += `  â”” Staking APR: ${data.latest.lido_apr?.toFixed(2) || 'N/A'}%\n`;
                }
                if (data.latest.gas_utilization !== undefined && fieldName !== 'gas_utilization') {
                    prompt += `  â”” Gas Utilization: ${data.latest.gas_utilization?.toFixed(1) || 'N/A'}%\n`;
                }
                if (data.latest.blob_fee_eth !== undefined && fieldName !== 'blob_fee_eth') {
                    prompt += `  â”” Blob Fees: ${data.latest.blob_fee_eth?.toFixed(4) || 'N/A'} ETH\n`;
                }
                if (data.latest.whale_volume_eth !== undefined) {
                    prompt += `  â”” Whale Volume: ${formatVal(data.latest.whale_volume_eth, ' ETH')}\n`;
                }
                if (data.latest.realized_price !== undefined && key !== 'mvrv' && fieldName !== 'realized_price') {
                    prompt += `  â”” Realized Price: $${data.latest.realized_price?.toFixed(2) || 'N/A'}\n`;
                }
                if (data.latest.mvrv_ratio !== undefined && fieldName !== 'mvrv_ratio') {
                    prompt += `  â”” MVRV Ratio: ${data.latest.mvrv_ratio?.toFixed(2) || 'N/A'}\n`;
                }
                if (data.latest.eth_burnt !== undefined && fieldName !== 'eth_burnt') {
                    prompt += `  â”” ETH Burnt: ${data.latest.eth_burnt?.toFixed(2) || 'N/A'} ETH\n`;
                }
                if (data.latest.open_interest !== undefined && fieldName !== 'open_interest') {
                    const oiVal = data.latest.open_interest >= 1e9 ? (data.latest.open_interest / 1e9).toFixed(2) + 'B' : (data.latest.open_interest / 1e6).toFixed(2) + 'M';
                    prompt += `  â”” Open Interest: $${oiVal}\n`;
                }
                
                prompt += `\n`;
            }
            
            return prompt;
        }
        
        async function generateCommentaryWithClaude(sectionKey, metricsData, lang = 'en', existingScores = null) {
            if (!ANTHROPIC_API_KEY) {
                throw new Error('No Anthropic API key configured. Add it in API Config section.');
            }
            
            const section = COMMENTARY_SECTIONS[sectionKey];
            const metricsPrompt = formatMetricsForPrompt(sectionKey, metricsData);
            
            // ë””ë²„ê¹…: AIì—ê²Œ ì „ë‹¬ë˜ëŠ” ë©”íŠ¸ë¦­ìŠ¤ ì¶œë ¥
            console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            console.log(`ğŸ“Š AI Metrics for ${sectionKey}:`);
            console.log(metricsPrompt);
            console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            
            const langInstructions = {
                en: 'Write in English.',
                ko: 'Write in Korean (í•œêµ­ì–´ë¡œ ì‘ì„±). Use natural Korean financial terminology. For crypto terms, write Korean first then English in parentheses.',
                zh: 'Write in Simplified Chinese (ç”¨ç®€ä½“ä¸­æ–‡å†™). Use natural Chinese financial terminology.',
                ja: 'Write in Japanese (æ—¥æœ¬èªã§ä½œæˆ). Use natural Japanese financial terminology.'
            };
            
            const isEnglish = (lang === 'en');
            let systemPrompt, userPrompt;
            
            if (isEnglish) {
                // ì˜ì–´: ì ìˆ˜ + reasoning + ë³¸ë¬¸ ìƒì„±
                systemPrompt = `You are an expert Ethereum market analyst. Write analysis for the "${section.title}" section.

STRICT OUTPUT FORMAT:
You must output a JSON object with scores, reasoning for each score, AND 3 paragraphs.

REQUIRED JSON FORMAT (output ONLY this, no markdown):
{"scores":[X,Y,Z],"reasoning":["reason for score1","reason for score2","reason for score3"],"text":"paragraph1|||paragraph2|||paragraph3"}

SCORE DEFINITIONS (0-100 scale, 50 is neutral):
- Score 1 (Current Status - Market Temperature): 0-44=cold/fear, 45-55=neutral, 56-100=hot/greed
  * Based on: Fear & Greed Index, Funding Rate, current percentile vs historical
  
- Score 2 (90-Day Trend - Momentum): 0-44=downtrend, 45-55=sideways, 56-100=uptrend  
  * Based on: 90-day % changes in the data
  * Changes > +20% â†’ high score (70-90), Changes < -20% â†’ low score (10-30)
  
- Score 3 (Valuation - Bullish/Bearish Signal): 0-44=bearish, 45-55=neutral, 56-100=bullish
  * IMPORTANT: Use the "Current Percentile" data provided
  * Percentile < 25% (bottom quartile) = UNDERVALUED â†’ Bullish score (70-90)
  * Percentile 25-50% = Slightly undervalued â†’ Score 55-70
  * Percentile 50-75% = Slightly overvalued â†’ Score 30-45
  * Percentile > 75% (top quartile) = OVERVALUED â†’ Bearish score (10-30)

REASONING FORMAT:
- Each reasoning string should be 1-2 sentences explaining why you chose that score
- Include specific data points that influenced the score (percentiles, % changes)
- Example: "Score 65: Fear & Greed at 72 (75th percentile) indicates greed, Funding Rate positive"
- Example: "Score 28: 90d change of -35% across key metrics shows strong downtrend"

SCORING GUIDELINES USING HISTORICAL CONTEXT:
- The data includes "Current Percentile" for each metric (0-100%)
- Percentile shows where current value sits in 3-year history
- For VALUATION score: Lower percentile = more undervalued = HIGHER score (inverted!)
- For SENTIMENT score: Use Fear & Greed percentile directly
- For TREND score: Focus on 90-day % change direction and magnitude

CRITICAL RULES:
- ${langInstructions[lang]}
- Output ONLY valid JSON, no markdown code blocks
- scores array must have exactly 3 integers between 0-100
- reasoning array must have exactly 3 strings explaining each score
- text field contains 3 paragraphs separated by |||
- EACH PARAGRAPH MUST HAVE EXACTLY 5 SENTENCES - this is mandatory
- âš ï¸ ABSOLUTELY NO NUMBERS IN TEXT paragraphs - describe trends qualitatively only
- âš ï¸ Use descriptive words: "historically low", "near all-time highs", "below median"
- Professional analyst tone, qualitative analysis only
- Minimum 180 words per paragraph`;

                userPrompt = `Analyze these ${section.title} metrics. Output JSON with scores, reasoning, and text.

${section.context ? `CRITICAL CONTEXT FOR THIS SECTION:\n${section.context}\n\n` : ''}${metricsPrompt}

IMPORTANT REQUIREMENTS:
1. Each paragraph MUST contain exactly 5 sentences
2. Provide clear reasoning for each score using the data above
3. NO NUMBERS in the text paragraphs
4. Output format: {"scores":[X,Y,Z],"reasoning":["...","...","..."],"text":"para1|||para2|||para3"}`;
            } else {
                // ë‹¤ë¥¸ ì–¸ì–´: ë³¸ë¬¸ë§Œ ìƒì„±
                systemPrompt = `You are an expert Ethereum market analyst. Write analysis for the "${section.title}" section.

OUTPUT FORMAT:
Write exactly 3 paragraphs separated by ||| (three pipe characters).
Output ONLY the text, no JSON, no scores.

CRITICAL RULES:
- ${langInstructions[lang]}
- EACH PARAGRAPH MUST HAVE EXACTLY 5 SENTENCES
- âš ï¸ ABSOLUTELY NO NUMBERS IN TEXT - describe trends qualitatively only
- âš ï¸ Use descriptive words only (ìƒìŠ¹/í•˜ë½/íš¡ë³´, ä¸Šæ¶¨/ä¸‹è·Œ, ä¸Šæ˜‡/ä¸‹è½)
- Professional analyst tone
- Minimum 180 words per paragraph`;

                userPrompt = `Analyze these ${section.title} metrics. Output ONLY 3 paragraphs separated by |||

${section.context ? `CRITICAL CONTEXT FOR THIS SECTION:\n${section.context}\n\n` : ''}${metricsPrompt}

IMPORTANT: 
1. Each paragraph MUST contain exactly 5 sentences
2. Output format: para1|||para2|||para3 (no JSON, no scores)
3. NO NUMBERS in the text`;
            }
            
            const response = await fetch('https://api.anthropic.com/v1/messages', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-api-key': ANTHROPIC_API_KEY,
                    'anthropic-version': '2023-06-01',
                    'anthropic-dangerous-direct-browser-access': 'true'
                },
                body: JSON.stringify({
                    model: 'claude-3-5-haiku-20241022',
                    max_tokens: 3000,
                    system: systemPrompt,
                    messages: [{ role: 'user', content: userPrompt }]
                })
            });
            
            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`API Error ${response.status}: ${errorText}`);
            }
            
            const result = await response.json();
            const content = result.content?.[0]?.text || null;
            
            if (!content) return null;
            
            if (isEnglish) {
                // ì˜ì–´: JSON íŒŒì‹± (scores + reasoning + text)
                try {
                    const parsed = JSON.parse(content);
                    return {
                        scores: parsed.scores || [50, 50, 50],
                        reasoning: parsed.reasoning || ['No reasoning provided', 'No reasoning provided', 'No reasoning provided'],
                        text: parsed.text || content
                    };
                } catch (e) {
                    console.warn('JSON parse failed, using text fallback');
                    return {
                        scores: [50, 50, 50],
                        reasoning: ['Parse error', 'Parse error', 'Parse error'],
                        text: content
                    };
                }
            } else {
                // ë‹¤ë¥¸ ì–¸ì–´: í…ìŠ¤íŠ¸ë§Œ ë°˜í™˜ (ê¸°ì¡´ scores ì‚¬ìš©)
                return {
                    scores: existingScores || [50, 50, 50],
                    reasoning: null,
                    text: content
                };
            }
        }
        
        async function saveCommentaryToSupabase(sectionKey, commentaries, scores, reasoning, metricsData) {
            const client = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
            const today = new Date().toISOString().split('T')[0];
            const now = new Date().toISOString();
            
            try {
                const { error } = await client
                    .from('daily_commentary')
                    .upsert({
                        date: today,
                        section_key: sectionKey,
                        commentary: commentaries.en,
                        commentary_ko: commentaries.ko || null,
                        commentary_zh: commentaries.zh || null,
                        commentary_ja: commentaries.ja || null,
                        scores: scores || [50, 50, 50],
                        score_reasoning: reasoning || null,
                        metrics_snapshot: metricsData,
                        updated_at: now
                    }, { onConflict: 'date,section_key' });
                
                if (error) throw error;
                return true;
            } catch (e) {
                commentaryLog(`Error saving to Supabase: ${e.message}`, 'error');
                return false;
            }
        }
        
        async function regenerateSingleCommentary() {
            const sectionKey = document.getElementById('section-select').value;
            if (!sectionKey) {
                alert('Please select a section first.');
                return;
            }
            
            const btn = document.getElementById('btn-regen-single');
            btn.disabled = true;
            btn.textContent = 'â³ Generating...';
            
            document.getElementById('commentary-log').innerHTML = '';
            setCommentaryStatus('Generating...', '#d29922');
            
            try {
                const section = COMMENTARY_SECTIONS[sectionKey];
                commentaryLog(`ğŸ“ [${sectionKey}] ${section.title}...`);
                
                // Fetch metrics
                commentaryLog('  Fetching metrics...');
                const metricsData = await fetchSectionMetricsForCommentary(sectionKey);
                if (!metricsData || Object.keys(metricsData).length === 0) {
                    throw new Error('No metrics data available');
                }
                commentaryLog(`  âœ“ Fetched ${Object.keys(metricsData).length} metric groups`, 'success');
                
                // Generate for all languages
                // ì˜ì–´ ë¨¼ì € ìƒì„±í•´ì„œ ì ìˆ˜ í™•ì •
                const commentaries = {};
                let scores = [50, 50, 50];
                let reasoning = null;
                
                // 1. ì˜ì–´ ë¨¼ì € (ì ìˆ˜ + reasoning í¬í•¨)
                commentaryLog(`  Generating EN (with scores & reasoning)...`);
                const enResult = await generateCommentaryWithClaude(sectionKey, metricsData, 'en', null);
                if (enResult) {
                    commentaries.en = enResult.text;
                    scores = enResult.scores;
                    reasoning = enResult.reasoning;
                    const hasDelimiter = enResult.text.includes('|||');
                    commentaryLog(`  âœ“ EN: ${enResult.text.length} chars, scores: [${scores.join(',')}] ${hasDelimiter ? 'âœ“' : 'âš ï¸ NO |||'}`, hasDelimiter ? 'success' : 'warning');
                    
                    // Reasoning ì¶œë ¥
                    if (reasoning && reasoning.length === 3) {
                        commentaryLog(`  ğŸ“ Score Reasoning:`, 'info');
                        commentaryLog(`     Status: ${reasoning[0]}`, 'info');
                        commentaryLog(`     Trend: ${reasoning[1]}`, 'info');
                        commentaryLog(`     Valuation: ${reasoning[2]}`, 'info');
                    }
                } else {
                    throw new Error('Failed to generate English commentary');
                }
                await new Promise(r => setTimeout(r, 500));
                
                // 2. ë‹¤ë¥¸ ì–¸ì–´ (ì˜ì–´ ì ìˆ˜ ì „ë‹¬)
                for (const lang of ['ko', 'zh', 'ja']) {
                    commentaryLog(`  Generating ${lang.toUpperCase()} (text only)...`);
                    const result = await generateCommentaryWithClaude(sectionKey, metricsData, lang, scores);
                    if (result) {
                        commentaries[lang] = result.text;
                        const hasDelimiter = result.text.includes('|||');
                        commentaryLog(`  âœ“ ${lang.toUpperCase()}: ${result.text.length} chars ${hasDelimiter ? 'âœ“' : 'âš ï¸ NO |||'}`, hasDelimiter ? 'success' : 'warning');
                    } else {
                        commentaryLog(`  âš ï¸ ${lang.toUpperCase()}: Failed`, 'warning');
                    }
                    await new Promise(r => setTimeout(r, 500));
                }
                
                // Save to Supabase (with scores and reasoning)
                commentaryLog('  Saving to Supabase...');
                commentaryLog(`  Scores: [${scores.join(', ')}]`);
                const saved = await saveCommentaryToSupabase(sectionKey, commentaries, scores, reasoning, metricsData);
                if (saved) {
                    commentaryLog(`âœ… Successfully saved ${sectionKey}!`, 'success');
                    setCommentaryStatus('Completed', '#3fb950');
                    
                    // Auto-load today's commentary
                    await loadTodayCommentary();
                } else {
                    throw new Error('Failed to save to Supabase');
                }
                
            } catch (e) {
                commentaryLog(`âŒ Error: ${e.message}`, 'error');
                setCommentaryStatus('Error', '#f85149');
            } finally {
                btn.disabled = false;
                btn.textContent = 'ğŸ¯ Regenerate Selected';
            }
        }
        
        // Store loaded commentary data for language switching
        let loadedCommentaryData = [];
        let currentCommentaryLang = 'en';
        
        async function loadTodayCommentary() {
            const btn = document.getElementById('btn-view-today');
            btn.disabled = true;
            btn.textContent = 'â³ Loading...';
            
            try {
                const client = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                const today = new Date().toISOString().split('T')[0];
                
                const { data, error } = await client
                    .from('daily_commentary')
                    .select('*')
                    .eq('date', today)
                    .order('section_key');
                
                if (error) throw error;
                
                if (!data || data.length === 0) {
                    alert('No commentary found for today. Generate some first!');
                    return;
                }
                
                loadedCommentaryData = data;
                currentCommentaryLang = 'en';
                
                document.getElementById('commentary-date').textContent = today;
                document.getElementById('commentary-viewer').style.display = 'block';
                
                renderCommentaryCards('en');
                updateLangButtons('en');
                
                commentaryLog(`ğŸ“‹ Loaded ${data.length} commentaries for ${today}`, 'success');
                
            } catch (e) {
                commentaryLog(`âŒ Error loading commentary: ${e.message}`, 'error');
                alert('Error loading commentary: ' + e.message);
            } finally {
                btn.disabled = false;
                btn.textContent = 'ğŸ“‹ View Today\'s Commentary';
            }
        }
        
        function switchCommentaryLang(lang) {
            currentCommentaryLang = lang;
            renderCommentaryCards(lang);
            updateLangButtons(lang);
        }
        
        function updateLangButtons(activeLang) {
            ['en', 'ko', 'zh', 'ja'].forEach(lang => {
                const btn = document.getElementById(`lang-btn-${lang}`);
                if (lang === activeLang) {
                    btn.style.background = 'var(--primary)';
                    btn.style.color = 'white';
                } else {
                    btn.style.background = 'var(--bg-secondary)';
                    btn.style.color = 'var(--text)';
                }
            });
        }
        
        function renderCommentaryCards(lang) {
            const container = document.getElementById('commentary-cards');
            const langField = lang === 'en' ? 'commentary' : `commentary_${lang}`;
            
            const sectionNames = {
                investor_sentiment: { icon: 'ğŸ˜°', name: 'Investor Sentiment', name_ko: 'íˆ¬ìì ì‹¬ë¦¬' },
                market_position: { icon: 'ğŸ“Š', name: 'Market Position', name_ko: 'ì‹œì¥ í¬ì§€ì…˜' },
                supply_dynamics: { icon: 'âš¡', name: 'Supply Dynamics', name_ko: 'ê³µê¸‰ ë™í•™' },
                network_demand: { icon: 'ğŸ”¥', name: 'Network Demand', name_ko: 'ë„¤íŠ¸ì›Œí¬ ìˆ˜ìš”' },
                user_activity: { icon: 'ğŸ‘¥', name: 'User Activity', name_ko: 'ì‚¬ìš©ì í™œë™' },
                locked_capital: { icon: 'ğŸ”’', name: 'Locked Capital', name_ko: 'ì˜ˆì¹˜ ìë³¸' },
                settlement_volume: { icon: 'ğŸ’¸', name: 'Settlement Volume', name_ko: 'ê²°ì œëŸ‰' }
            };
            
            container.innerHTML = loadedCommentaryData.map(item => {
                const section = sectionNames[item.section_key] || { icon: 'ğŸ“', name: item.section_key };
                const content = item[langField] || item.commentary || '(No translation available)';
                const charCount = content.length;
                const scores = item.scores || [50, 50, 50];
                const reasoning = item.score_reasoning || [];
                
                // Score labels
                const scoreLabels = ['Status', 'Trend', 'Valuation'];
                const scoreColors = scores.map(s => s < 45 ? '#f85149' : s > 55 ? '#3fb950' : '#d29922');
                
                // Reasoning display
                let reasoningHtml = '';
                if (reasoning && reasoning.length === 3) {
                    reasoningHtml = `
                        <div style="margin-top: 10px; padding: 8px; background: var(--bg); border-radius: 4px; font-size: 10px;">
                            <div style="font-weight: 600; color: var(--text-muted); margin-bottom: 6px;">ğŸ“ Score Reasoning:</div>
                            ${reasoning.map((r, i) => `
                                <div style="margin-bottom: 4px; color: var(--text-muted);">
                                    <span style="color: ${scoreColors[i]}; font-weight: 600;">${scoreLabels[i]} (${scores[i]}):</span> ${escapeHtml(r)}
                                </div>
                            `).join('')}
                        </div>
                    `;
                }
                
                return `
                    <div style="background: var(--bg-secondary); border-radius: 8px; padding: 16px; border: 1px solid var(--border);">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <div style="font-weight: 600; color: var(--primary);">${section.icon} ${section.name}</div>
                            <div style="display: flex; gap: 8px; align-items: center;">
                                <span style="font-size: 10px; padding: 2px 6px; background: ${scoreColors[0]}22; color: ${scoreColors[0]}; border-radius: 4px;">S:${scores[0]}</span>
                                <span style="font-size: 10px; padding: 2px 6px; background: ${scoreColors[1]}22; color: ${scoreColors[1]}; border-radius: 4px;">T:${scores[1]}</span>
                                <span style="font-size: 10px; padding: 2px 6px; background: ${scoreColors[2]}22; color: ${scoreColors[2]}; border-radius: 4px;">V:${scores[2]}</span>
                                <span style="font-size: 10px; color: var(--text-muted);">${charCount} chars</span>
                            </div>
                        </div>
                        <div style="font-size: 12px; line-height: 1.6; color: var(--text); max-height: 200px; overflow-y: auto; white-space: pre-wrap;">${escapeHtml(content)}</div>
                        ${reasoningHtml}
                    </div>
                `;
            }).join('');
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        async function regenerateAllCommentary() {
            if (!confirm('This will regenerate AI commentary for all 7 sections. This may take 2-3 minutes. Continue?')) {
                return;
            }
            
            const btn = document.getElementById('btn-regen-all');
            btn.disabled = true;
            
            document.getElementById('commentary-log').innerHTML = '';
            setCommentaryStatus('Generating all...', '#d29922');
            
            let success = 0, failed = 0;
            const totalSections = Object.keys(COMMENTARY_SECTIONS).length;
            
            try {
                for (const sectionKey of Object.keys(COMMENTARY_SECTIONS)) {
                    btn.textContent = `â³ ${success + failed + 1}/${totalSections}...`;
                    
                    const section = COMMENTARY_SECTIONS[sectionKey];
                    commentaryLog(`\nğŸ“ [${sectionKey}] ${section.title}...`);
                    
                    try {
                        // Fetch metrics
                        const metricsData = await fetchSectionMetricsForCommentary(sectionKey);
                        if (!metricsData || Object.keys(metricsData).length === 0) {
                            commentaryLog(`  âŒ No metrics data available`, 'error');
                            failed++;
                            continue;
                        }
                        commentaryLog(`  âœ“ Fetched ${Object.keys(metricsData).length} metric groups`, 'success');
                        
                        // Generate for all languages
                        // ì˜ì–´ ë¨¼ì € ìƒì„±í•´ì„œ ì ìˆ˜ í™•ì •
                        const commentaries = {};
                        let scores = [50, 50, 50];
                        let reasoning = null;
                        
                        // 1. ì˜ì–´ ë¨¼ì € (ì ìˆ˜ + reasoning í¬í•¨)
                        const enResult = await generateCommentaryWithClaude(sectionKey, metricsData, 'en', null);
                        if (enResult) {
                            commentaries.en = enResult.text;
                            scores = enResult.scores;
                            reasoning = enResult.reasoning;
                            commentaryLog(`  âœ“ EN: ${enResult.text.length} chars, scores: [${scores.join(',')}]`, 'success');
                            if (reasoning) {
                                commentaryLog(`  ğŸ“ Reasoning: ${reasoning[0].substring(0, 50)}...`, 'info');
                            }
                        } else {
                            commentaryLog(`  âŒ Failed to generate English`, 'error');
                            failed++;
                            continue;
                        }
                        await new Promise(r => setTimeout(r, 500));
                        
                        // 2. ë‹¤ë¥¸ ì–¸ì–´ (ì˜ì–´ ì ìˆ˜ ì „ë‹¬)
                        for (const lang of ['ko', 'zh', 'ja']) {
                            const result = await generateCommentaryWithClaude(sectionKey, metricsData, lang, scores);
                            if (result) {
                                commentaries[lang] = result.text;
                                commentaryLog(`  âœ“ ${lang.toUpperCase()}: ${result.text.length} chars`, 'success');
                            } else {
                                commentaryLog(`  âš ï¸ ${lang.toUpperCase()}: Failed`, 'warning');
                            }
                            await new Promise(r => setTimeout(r, 500));
                        }
                        
                        // Save (with scores and reasoning)
                        const saved = await saveCommentaryToSupabase(sectionKey, commentaries, scores, reasoning, metricsData);
                        if (saved) {
                            commentaryLog(`  âœ… Saved!`, 'success');
                            success++;
                        } else {
                            failed++;
                        }
                        
                    } catch (e) {
                        commentaryLog(`  âŒ Error: ${e.message}`, 'error');
                        failed++;
                    }
                    
                    // Rate limit between sections
                    await new Promise(r => setTimeout(r, 1000));
                }
                
                commentaryLog(`\n${'='.repeat(40)}`);
                commentaryLog(`ğŸ“Š Results: âœ… ${success}/${totalSections}  |  âŒ ${failed}/${totalSections}`, success === totalSections ? 'success' : 'warning');
                setCommentaryStatus(`Done: ${success}/${totalSections}`, success === totalSections ? '#3fb950' : '#d29922');
                
                // Auto-load today's commentary after completion
                if (success > 0) {
                    await loadTodayCommentary();
                }
                
            } catch (e) {
                commentaryLog(`âŒ Fatal error: ${e.message}`, 'error');
                setCommentaryStatus('Error', '#f85149');
            } finally {
                btn.disabled = false;
                btn.textContent = 'ğŸ”„ Regenerate All (7 Sections)';
            }
        }
    </script>
</body>
</html>
